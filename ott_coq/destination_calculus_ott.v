(* generated by Ott 0.33 from: rules.ott grammar.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Import EqNotations.
Require Import Dest.ext_nat.
Require Import Coq.Structures.Equalities.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.Arith.Compare_dec.
Require Import Coq.MSets.MSetList.
Require Import Coq.MSets.MSetFacts.
Require Import Coq.Logic.FunctionalExtensionality.
(* Grumble, grumble: we shouldn't need to Import Dest.Finitely, but if
   we don't we can't use the coercions. *)
Require Import Dest.Finitely.
Require Dest.Permutation.

Module Nat' <: OrderedTypeWithLeibniz.
  Include PeanoNat.Nat.
  Lemma eq_leibniz : forall x y, eq x y -> x = y.
  Proof. trivial.
  Qed.
End Nat'.
Module HVars := MSetList.MakeWithLeibniz(Nat').
Module HVarsFacts := MSetFacts.Facts(HVars).

(* We need to predefine eq_dec for mode so that Ott can generate eq_dec for type *)
(* Will be aliased later to mul *)
Inductive _mul : Type :=
  | Lin : _mul
  | Ur : _mul.
Theorem mul_eq_dec : forall (p1 p2: _mul), {p1 = p2} + {p1 <> p2}.
Proof.
  decide equality.
Defined.
Definition age_eq_dec : forall (a1 a2: ext_nat), {a1 = a2} + {a1 <> a2} := ext_eq_dec.
Theorem mode_eq_dec : forall (m1 m2: option (_mul * ext_nat)), {m1 = m2} + {m1 <> m2}.
Proof.
  decide equality. destruct a, p.
  - destruct (mul_eq_dec _m _m0), (age_eq_dec e e0); subst; auto.
    * right. congruence.
    * right. congruence.
    * right. congruence.
Defined.

Definition var : Type := nat. (*r Variable names *)
Definition k : Type := nat. (*r Index for ranges *)

Definition age : Type := ext_nat.

Definition mul : Type := _mul.

Definition hvar : Type := nat.

Definition mode : Type := option (mul * age).

Definition hvars : Type := HVars.t.

Inductive term : Type :=  (*r Term *)
 | term_Val (v:val) (*r Value *)
 | term_Var (x:var) (*r Variable *)
 | term_App (t':term) (t:term) (*r Application *)
 | term_PatU (t:term) (u:term) (*r Pattern-match on unit *)
 | term_PatS (t:term) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term) (*r Pattern-match on sum *)
 | term_PatP (t:term) (m:mode) (x1:var) (x2:var) (u:term) (*r Pattern-match on product *)
 | term_PatE (t:term) (m:mode) (n:mode) (x:var) (u:term) (*r Pattern-match on exponential *)
 | term_Map (t:term) (x:var) (t':term) (*r Map over the right side of ampar *)
 | term_ToA (u:term) (*r Wrap into a trivial ampar *)
 | term_FromA (t:term) (*r Convert ampar to a pair *)
 | term_FillU (t:term) (*r Fill destination with unit *)
 | term_FillL (t:term) (*r Fill destination with left variant *)
 | term_FillR (t:term) (*r Fill destination with right variant *)
 | term_FillE (t:term) (m:mode) (*r Fill destination with exponential constructor *)
 | term_FillP (t:term) (*r Fill destination with product constructor *)
 | term_FillF (t:term) (x:var) (m:mode) (u:term) (*r Fill destination with function *)
 | term_FillComp (t:term) (t':term) (*r Fill destination with root of other ampar *)
with val : Type :=  (*r Value *)
 | val_Hole (h:hvar) (*r Hole *)
 | val_Dest (h:hvar) (*r Destination *)
 | val_Unit : val (*r Unit *)
 | val_Fun (x:var) (m:mode) (u:term) (*r Function with no free variable *)
 | val_Left (v:val) (*r Left variant for sum *)
 | val_Right (v:val) (*r Right variant for sum *)
 | val_Exp (m:mode) (v:val) (*r Exponential *)
 | val_Prod (v1:val) (v2:val) (*r Product *)
 | val_Ampar (H:hvars) (v2:val) (v1:val) (*r Ampar *).

Inductive ectx : Type :=  (*r Evaluation context component *)
 | ectx_App_Foc1 (t':term)
 | ectx_App_Foc2 (v:val)
 | ectx_PatU_Foc (u:term)
 | ectx_PatS_Foc (m:mode) (x1:var) (u1:term) (x2:var) (u2:term)
 | ectx_PatP_Foc (m:mode) (x1:var) (x2:var) (u:term)
 | ectx_PatE_Foc (m:mode) (n:mode) (x:var) (u:term)
 | ectx_Map_Foc (x:var) (t':term)
 | ectx_ToA_Foc : ectx
 | ectx_FromA_Foc : ectx
 | ectx_FillU_Foc : ectx
 | ectx_FillL_Foc : ectx
 | ectx_FillR_Foc : ectx
 | ectx_FillE_Foc (m:mode)
 | ectx_FillP_Foc : ectx
 | ectx_FillF_Foc (x:var) (m:mode) (u:term)
 | ectx_FillComp_Foc1 (t':term)
 | ectx_FillComp_Foc2 (v:val)
 | ectx_OpenAmpar_Foc (H:hvars) (v2:val) (*r Open ampar, binding hole names in the next components *).

Inductive type : Type :=  (*r Type *)
 | type_Unit : type (*r Unit *)
 | type_Sum (T1:type) (T2:type) (*r Sum *)
 | type_Prod (T1:type) (T2:type) (*r Product *)
 | type_Exp (m:mode) (T:type) (*r Exponential *)
 | type_Ampar (U:type) (T:type) (*r Ampar *)
 | type_Fun (T:type) (m:mode) (U:type) (*r Function *)
 | type_Dest (T:type) (m:mode) (*r Destination *).

Inductive name : Type := 
 | name_Var (x:var)
 | name_DH (h:hvar).

Definition ectxs : Type := (list ectx).

Definition casem : Type := mode.

Inductive binding_var : Type := 
 | binding_Var (m:mode) (T:type).

Inductive binding_dh : Type := 
 | binding_Dest (m:mode) (T:type) (n:mode)
 | binding_Hole (T:type) (n:mode).
Lemma eq_type: forall (x y : type), {x = y} + {x <> y}.
Proof.
decide equality. apply mode_eq_dec. apply mode_eq_dec. apply mode_eq_dec.
Defined.
Hint Resolve eq_type : ott_coq_equality.
(** induction principles *)
Section val_term_rect.

Variables
  (P_val : val -> Prop)
  (P_term : term -> Prop).

Hypothesis
  (H_val_Hole : forall (h:hvar), P_val (val_Hole h))
  (H_val_Dest : forall (h:hvar), P_val (val_Dest h))
  (H_val_Unit : P_val val_Unit)
  (H_val_Fun : forall (x:var), forall (m:mode), forall (u:term), P_term u -> P_val (val_Fun x m u))
  (H_val_Left : forall (v:val), P_val v -> P_val (val_Left v))
  (H_val_Right : forall (v:val), P_val v -> P_val (val_Right v))
  (H_val_Exp : forall (m:mode), forall (v:val), P_val v -> P_val (val_Exp m v))
  (H_val_Prod : forall (v1:val), P_val v1 -> forall (v2:val), P_val v2 -> P_val (val_Prod v1 v2))
  (H_val_Ampar : forall (H:hvars), forall (v2:val), P_val v2 -> forall (v1:val), P_val v1 -> P_val (val_Ampar H v2 v1))
  (H_term_Val : forall (v:val), P_val v -> P_term (term_Val v))
  (H_term_Var : forall (x:var), P_term (term_Var x))
  (H_term_App : forall (t':term), P_term t' -> forall (t:term), P_term t -> P_term (term_App t' t))
  (H_term_PatU : forall (t:term), P_term t -> forall (u:term), P_term u -> P_term (term_PatU t u))
  (H_term_PatS : forall (t:term), P_term t -> forall (m:mode), forall (x1:var), forall (u1:term), P_term u1 -> forall (x2:var), forall (u2:term), P_term u2 -> P_term (term_PatS t m x1 u1 x2 u2))
  (H_term_PatP : forall (t:term), P_term t -> forall (m:mode), forall (x1:var), forall (x2:var), forall (u:term), P_term u -> P_term (term_PatP t m x1 x2 u))
  (H_term_PatE : forall (t:term), P_term t -> forall (m:mode), forall (n:mode), forall (x:var), forall (u:term), P_term u -> P_term (term_PatE t m n x u))
  (H_term_Map : forall (t:term), P_term t -> forall (x:var), forall (t':term), P_term t' -> P_term (term_Map t x t'))
  (H_term_ToA : forall (u:term), P_term u -> P_term (term_ToA u))
  (H_term_FromA : forall (t:term), P_term t -> P_term (term_FromA t))
  (H_term_FillU : forall (t:term), P_term t -> P_term (term_FillU t))
  (H_term_FillL : forall (t:term), P_term t -> P_term (term_FillL t))
  (H_term_FillR : forall (t:term), P_term t -> P_term (term_FillR t))
  (H_term_FillE : forall (t:term), P_term t -> forall (m:mode), P_term (term_FillE t m))
  (H_term_FillP : forall (t:term), P_term t -> P_term (term_FillP t))
  (H_term_FillF : forall (t:term), P_term t -> forall (x:var), forall (m:mode), forall (u:term), P_term u -> P_term (term_FillF t x m u))
  (H_term_FillComp : forall (t:term), P_term t -> forall (t':term), P_term t' -> P_term (term_FillComp t t'))
.

Fixpoint term_ott_ind (n:term) : P_term n :=
  match n as x return P_term x with
  | (term_Val v) => H_term_Val v (val_ott_ind v)
  | (term_Var x) => H_term_Var x
  | (term_App t' t) => H_term_App t' (term_ott_ind t') t (term_ott_ind t)
  | (term_PatU t u) => H_term_PatU t (term_ott_ind t) u (term_ott_ind u)
  | (term_PatS t m x1 u1 x2 u2) => H_term_PatS t (term_ott_ind t) m x1 u1 (term_ott_ind u1) x2 u2 (term_ott_ind u2)
  | (term_PatP t m x1 x2 u) => H_term_PatP t (term_ott_ind t) m x1 x2 u (term_ott_ind u)
  | (term_PatE t m n x u) => H_term_PatE t (term_ott_ind t) m n x u (term_ott_ind u)
  | (term_Map t x t') => H_term_Map t (term_ott_ind t) x t' (term_ott_ind t')
  | (term_ToA u) => H_term_ToA u (term_ott_ind u)
  | (term_FromA t) => H_term_FromA t (term_ott_ind t)
  | (term_FillU t) => H_term_FillU t (term_ott_ind t)
  | (term_FillL t) => H_term_FillL t (term_ott_ind t)
  | (term_FillR t) => H_term_FillR t (term_ott_ind t)
  | (term_FillE t m) => H_term_FillE t (term_ott_ind t) m
  | (term_FillP t) => H_term_FillP t (term_ott_ind t)
  | (term_FillF t x m u) => H_term_FillF t (term_ott_ind t) x m u (term_ott_ind u)
  | (term_FillComp t t') => H_term_FillComp t (term_ott_ind t) t' (term_ott_ind t')
end
with val_ott_ind (n:val) : P_val n :=
  match n as x return P_val x with
  | (val_Hole h) => H_val_Hole h
  | (val_Dest h) => H_val_Dest h
  | val_Unit => H_val_Unit 
  | (val_Fun x m u) => H_val_Fun x m u (term_ott_ind u)
  | (val_Left v) => H_val_Left v (val_ott_ind v)
  | (val_Right v) => H_val_Right v (val_ott_ind v)
  | (val_Exp m v) => H_val_Exp m v (val_ott_ind v)
  | (val_Prod v1 v2) => H_val_Prod v1 (val_ott_ind v1) v2 (val_ott_ind v2)
  | (val_Ampar H v2 v1) => H_val_Ampar H v2 (val_ott_ind v2) v1 (val_ott_ind v1)
end.

End val_term_rect.

(** subrules *)
Definition is_sterm_of_term (t_5:term) : bool :=
  match t_5 with
  | (term_Val v) => false
  | (term_Var x) => false
  | (term_App t' t) => false
  | (term_PatU t u) => false
  | (term_PatS t m x1 u1 x2 u2) => false
  | (term_PatP t m x1 x2 u) => false
  | (term_PatE t m n x u) => false
  | (term_Map t x t') => false
  | (term_ToA u) => false
  | (term_FromA t) => false
  | (term_FillU t) => false
  | (term_FillL t) => false
  | (term_FillR t) => false
  | (term_FillE t m) => false
  | (term_FillP t) => false
  | (term_FillF t x m u) => false
  | (term_FillComp t t') => false
end.


Definition binding_type_of (n : name) : Type :=
  match n with
  | name_Var _ => binding_var
  | name_DH _ => binding_dh
  end.

Definition cast_binding_rename (h : hvar) (h' : hvar) (b : binding_type_of (name_DH h)): binding_type_of (name_DH h') :=
  b.

Definition name_eq_dec (x y : name) : {x = y} + {x<>y}.
Proof.
  decide equality.
  - apply Nat.eq_dec.
  - apply Nat.eq_dec.
Defined.



Definition ctx : Type := Finitely.T name binding_type_of.
(******************************************************************************
 * NAMES
 *****************************************************************************)

Definition shift_one (h' : hvar) (h'' : hvar) : Permutation.Transposition.T :=
  {| Permutation.Transposition.from := h''; Permutation.Transposition.to := h''+h'|}
.

Definition shift_perm (H : hvars) (h' : hvar) : Permutation.T :=
  List.map (shift_one h') (HVars.elements H)
.

Definition hvar_cshift (h : hvar) (H : HVars.t) (h' : hvar) : hvar :=
  Permutation.sem (shift_perm H h') h
.

Fixpoint hvars_ (l : list nat) : HVars.t :=
  match l with
  | nil => HVars.empty
  | h :: t => HVars.add h (hvars_ t)
  end.

Definition hvar_max (H : HVars.t) : nat := match HVars.max_elt H with
  | Some h => h
  | None => 0
  end.

Definition hvars_shift (H : HVars.t) (h' : nat) : HVars.t :=
  HVars.fold (fun h acc => HVars.add (h + h') acc) H HVars.empty.

Definition hvars_cshift (H H': HVars.t) (h' : nat) : HVars.t :=
  HVars.fold (fun h acc => HVars.add (hvar_cshift h H' h') acc) H HVars.empty.

Fixpoint hvars_dom (dom: list name) : HVars.t :=
  match dom with
  | nil => HVars.empty
  | name_Var _ :: xs => hvars_dom xs
  | name_DH h :: xs => HVars.add h (hvars_dom xs)
  end.
Definition hvars_ctx (G : ctx) : HVars.t :=
  hvars_dom (dom G).

Fixpoint hvars_ectxs (C : ectxs) : HVars.t := match C with
  | nil => HVars.empty
  | cons c xs => let H := match c with
    | ectx_OpenAmpar_Foc H' v => H'
    | _ => HVars.empty
  end in (HVars.union H (hvars_ectxs xs))
end.

Definition HDisjoint (H1 H2 : HVars.t) : Prop :=
  HVars.Empty (HVars.inter H1 H2).

Notation "H1 '##' H2" := (HDisjoint H1 H2) (at level 50, no associativity).

(******************************************************************************
 * TERMS
 *****************************************************************************)

Fixpoint term_sub (te: term) (x':var) (v':val) : term := match te with
  (* | term_Val v => val_sub v x' v' *)
  | term_Val v => term_Val v
  | term_Var x => match Nat.eq_dec x x' with | left _ => term_Val v' | right _ => term_Var x end
  | term_App t t' => term_App (term_sub t x' v') (term_sub t' x' v')
  | term_PatU t u => term_PatU (term_sub t x' v') (term_sub u x' v')
  | term_PatS t m x1 u1 x2 u2 =>
    let u1' := match Nat.eq_dec x1 x' with | left _ => u1 | right _ => term_sub u1 x' v' end in
    let u2' := match Nat.eq_dec x2 x' with | left _ => u2 | right _ => term_sub u2 x' v' end in
    term_PatS (term_sub t x' v') m x1 u1' x2 u2'
  | term_PatP t m x1 x2 u =>
    let u' := match Nat.eq_dec x1 x', Nat.eq_dec x2 x' with | left _, left _ | left _, right _ | right _, left _ => u | right _, right _ => term_sub u x' v' end in
    term_PatP (term_sub t x' v') m x1 x2 u'
  | term_PatE t m n x u =>
    let u' := match Nat.eq_dec x x' with | left _ => u | right _ => term_sub u x' v' end in
    term_PatE (term_sub t x' v') m n x u'
  | term_Map t x t' =>
    let t'' := match Nat.eq_dec x x' with | left _ => t' | right _ => term_sub t' x' v' end in
    term_Map (term_sub t x' v') x t''
  | term_ToA u => term_ToA (term_sub u x' v')
  | term_FromA t => term_FromA (term_sub t x' v')
  | term_FillU t => term_FillU (term_sub t x' v')
  | term_FillL t => term_FillL (term_sub t x' v')
  | term_FillR t => term_FillR (term_sub t x' v')
  | term_FillE t m => term_FillE (term_sub t x' v') m
  | term_FillP t => term_FillP (term_sub t x' v')
  | term_FillF t x m u =>
    let u' := match Nat.eq_dec x x' with | left _ => u | right _ => term_sub u x' v' end in
    term_FillF (term_sub t x' v') x m u'
  | term_FillComp t t' => term_FillComp (term_sub t x' v') (term_sub t' x' v')
end.

Definition NotVal (t: term) : Prop := forall (v : val), t <> term_Val v.
Lemma NotVal_dec : forall (t : term), {exists v, t = term_Val v} + {NotVal t}.
Proof.
  intros t. destruct t.
  { left. exists v; tauto. }
  all: right; congruence.
Qed.

Definition sterm_Alloc :=
  (term_Val
    (val_Ampar
      (hvars_ (1 :: nil))
      (val_Hole 1)
      (val_Dest 1)
    )
  ).

Definition sterm_FromA' (t : term) :=
  (term_PatP
    (term_FromA
      (term_Map t 0
        (term_PatU
          (term_Var 0)
          (term_Val (val_Exp (Some (Lin, Inf)) val_Unit))
        )
      )
    )
    (Some (Lin, (Fin 0))) 1 2
    (term_PatE
      (term_Var 2)
      (Some (Lin, (Fin 0))) (Some (Lin, Inf)) 3
      (term_PatU
        (term_Var 3)
        (term_Var 1)
      )
    )
  ).

Definition sterm_FillLeaf (t t' : term) :=
  (term_FillComp t (term_ToA t')).

Definition sterm_Fun (x : var) (m : mode) (u : term) :=
  (sterm_FromA'
    (term_Map
      sterm_Alloc
      0
      (term_FillF
        (term_Var 0)
        x m u
      )
    )
  ).

Definition sterm_Left (t : term) :=
  (sterm_FromA'
    (term_Map
      sterm_Alloc
      0
      (sterm_FillLeaf
        (term_FillL
          (term_Var 0)
        )
        t
      )
    )
  ).

Definition sterm_Right (t : term) :=
  (sterm_FromA'
    (term_Map
      sterm_Alloc
      0
      (sterm_FillLeaf
        (term_FillR
          (term_Var 0)
        )
        t
      )
    )
  ).

Definition sterm_Exp (m : mode) (t : term) :=
  (sterm_FromA'
    (term_Map
      sterm_Alloc
      0
      (sterm_FillLeaf
        (term_FillE
          (term_Var 0)
          m
        )
        t
      )
    )
  ).

Definition sterm_Prod (t1 t2 : term) :=
  (sterm_FromA'
    (term_Map
      sterm_Alloc
      0
      (term_PatP
        (term_FillP
          (term_Var 0)
        )
        (Some (Lin, (Fin 0))) 1 2
        (term_PatU
          (sterm_FillLeaf
            (term_Var 1)
            t1
          )
          (sterm_FillLeaf
            (term_Var 2)
            t2
          )
        )
      )
    )
  ).

(******************************************************************************
 * VALUES
 *****************************************************************************)

Fixpoint val_fill (va: val) (h':hvar) (H':hvars) (v':val) : val := match va with
  | val_Hole h => match Nat.eq_dec h h' with | left _ => v' | right _ => val_Hole h end
  | val_Dest h => val_Dest h
  | val_Unit => val_Unit
  | val_Fun x m u => val_Fun x m u (* No hole in a value function allowed *)
  | val_Left v => val_Left (val_fill v h' H' v')
  | val_Right v => val_Right (val_fill v h' H' v')
  | val_Exp m v => val_Exp m (val_fill v h' H' v')
  | val_Prod v1 v2 => val_Prod (val_fill v1 h' H' v') (val_fill v2 h' H' v')
  | val_Ampar H v2 v1 => val_Ampar H v2 v1 (* No foreign hole allowed in ampar *)
end.

Fixpoint val_cshift (va : val) (H : hvars) (h' : hvar) : val :=
  match va with
  | val_Hole h => val_Hole (hvar_cshift h H h')
  | val_Dest h => val_Dest (hvar_cshift h H h')
  | val_Unit => val_Unit
  | val_Fun x m u => val_Fun x m (term_cshift u H h') (* We can have dests captured in a function *)
  | val_Left v => val_Left (val_cshift v H h')
  | val_Right v => val_Right (val_cshift v H h')
  | val_Exp m v => val_Exp m (val_cshift v H h')
  | val_Prod v1 v2 => val_Prod (val_cshift v1 H h') (val_cshift v2 H h')
  | val_Ampar H' v2 v1 => val_Ampar (hvars_cshift H' H h') (val_cshift v2 H h') (val_cshift v1 H h') (* We can have foreign dests captured in both sides of an ampar, but this shouldn't touch H' *)
  end
with term_cshift (te : term) (H : hvars) (h' : hvar) : term :=
  match te with
  | term_Val v => term_Val (val_cshift v H h')
  | term_Var x => term_Var x
  | term_App t t' => term_App (term_cshift t H h') (term_cshift t' H h')
  | term_PatU t u => term_PatU (term_cshift t H h') (term_cshift u H h')
  | term_PatS t m x1 u1 x2 u2 => term_PatS (term_cshift t H h') m x1 (term_cshift u1 H h') x2 (term_cshift u2 H h')
  | term_PatP t m x1 x2 u => term_PatP (term_cshift t H h') m x1 x2 (term_cshift u H h')
  | term_PatE t m n x u => term_PatE (term_cshift t H h') m n x (term_cshift u H h')
  | term_Map t x t' => term_Map (term_cshift t H h') x (term_cshift t' H h')
  | term_ToA u => term_ToA (term_cshift u H h')
  | term_FromA t => term_FromA (term_cshift t H h')
  | term_FillU t => term_FillU (term_cshift t H h')
  | term_FillL t => term_FillL (term_cshift t H h')
  | term_FillR t => term_FillR (term_cshift t H h')
  | term_FillE t m => term_FillE (term_cshift t H h') m
  | term_FillP t => term_FillP (term_cshift t H h')
  | term_FillF t x m u => term_FillF (term_cshift t H h') x m (term_cshift u H h')
  | term_FillComp t t' => term_FillComp (term_cshift t H h') (term_cshift t' H h')
end.

(******************************************************************************
 * TYPE
 *****************************************************************************)

Definition max_runtime_var : var := 3.

Definition UserDefined (G : ctx) := forall (x : var), Finitely.In (name_Var x) G -> x > max_runtime_var.

(* Alias to the one defined by Ott *)
Definition type_eq_dec : forall (T1 T2: type), {T1 = T2} + {T1 <> T2} := eq_type.

(******************************************************************************
 * MULTIPLICITY
 *****************************************************************************)

Definition mul_plus (p1 p2: _mul) : _mul := Ur.
Definition mul_times (p1 p2: _mul) : _mul :=
  match p1, p2 with
  | Lin, Lin => Lin
  | _, _ => Ur
  end.
Definition mul_times' (pl: list _mul) : _mul :=
  List.fold_right mul_times Lin pl.
Inductive MulSubtype : _mul -> _mul -> Prop :=
  | MulSubtypeProofEq : forall (p : _mul), MulSubtype p p
  | MulSubtypeProofUr : forall (p2 : _mul), MulSubtype Ur p2.
Theorem MulSubtype_dec : forall (p1 p2: _mul), {MulSubtype p1 p2} + {~MulSubtype p1 p2}.
Proof.
  intros p1 p2. destruct p1, p2.
  - left. exact (MulSubtypeProofEq Lin).
  - right. intros contra. inversion contra.
  - left. exact (MulSubtypeProofUr Lin).
  - left. exact (MulSubtypeProofEq Ur).
Defined.

(******************************************************************************
 * AGE
 *****************************************************************************)

Definition age_times (a1 a2 : age) : age := ext_plus a1 a2.
Definition age_times' (al: list age) : age := ext_plus' al.
Definition age_plus (a1 a2: age) : age :=
  match age_eq_dec a1 a2 with
  | left _ => a1
  | right _ => Inf
  end.
Inductive AgeSubtype : age -> age -> Prop :=
  | AgeSubtypeProofEq : forall (a : age), AgeSubtype a a
  | AgeSubtypeProofInf : forall (a2 : age), AgeSubtype Inf a2.
Theorem AgeSubtype_dec : forall (a1 a2: age), {AgeSubtype a1 a2} + {~(AgeSubtype a1 a2)}.
Proof.
  intros a1 a2. destruct a1, a2.
  - assert ({n = n0} + {n <> n0}) by apply Nat.eq_dec. destruct H.
    * rewrite e. left. exact (AgeSubtypeProofEq (Fin n0)).
    * right. intros contra. inversion contra. congruence.
  - right. intros contra. inversion contra.
  - left. exact (AgeSubtypeProofInf (Fin n)).
  - left. exact (AgeSubtypeProofEq Inf).
Defined.

(******************************************************************************
 * MODE
 *****************************************************************************)

Definition mode_plus (m1 m2: mode) : mode :=
  match m1, m2 with
  | None, _ => None
  | _, None => None
  | Some (p1, a1), Some (p2, a2) => Some (mul_plus p1 p2, age_plus a1 a2)end.
Definition mode_times (m1 m2: mode) : mode :=
  match m1, m2 with
  | None, _ => None
  | _, None => None
  | Some (p1, a1), Some (p2, a2) => Some (mul_times p1 p2, age_times a1 a2)
  end.
Definition mode_times' (ml: list mode) : mode :=
  List.fold_right mode_times (Some (Lin, Fin 0)) ml.
Inductive ModeSubtype : mode -> mode -> Prop :=
  | ModeSubtypeProofNone : forall (m2 : mode), ModeSubtype None m2 (* skull represents contradictory requirements, so we must never be able to provide a value with multiplicity skull *)
  | ModeSubtypeProofPair : forall (p1 p2 : _mul) (a1 a2 : age), MulSubtype p1 p2 -> AgeSubtype a1 a2 -> ModeSubtype (Some (p1, a1)) (Some (p2, a2)).
Theorem ModeSubtype_dec : forall (m1 m2: mode), {ModeSubtype m1 m2} + {~ModeSubtype m1 m2}.
Proof.
  intros m1 m2. destruct m1 as [(p1 & a1)|], m2 as [(p2 & a2)|].
  - destruct (MulSubtype_dec p1 p2), (AgeSubtype_dec a1 a2).
    + left. exact (ModeSubtypeProofPair p1 p2 a1 a2 m a).
    + right. intros contra. inversion contra. congruence.
    + right. intros contra. inversion contra. congruence.
    + right. intros contra. inversion contra. congruence.
  - right. intros contra. inversion contra.
  - left. exact (ModeSubtypeProofNone (Some (p2, a2))).
  - left. exact (ModeSubtypeProofNone None).
Defined.

Notation "n '<:' m" := (ModeSubtype m n) (at level 50, no associativity).

(******************************************************************************
 * BINDERS
 *****************************************************************************)

Inductive IsValid : mode -> Prop :=
  IsValidProof : forall (pa : mul * age), IsValid (Some pa).
Theorem IsValid_dec : forall (m : mode), {IsValid m} + {~IsValid m}.
Proof.
  intros m. destruct m as [pa|].
  - left. exact (IsValidProof pa).
  - right. intros contra. inversion contra.
Qed.
Inductive IsLin : mode -> Prop :=
  IsLinProof : forall (a : age), IsLin (Some (Lin, a)).
Theorem IsLin_dec : forall (m : mode), {IsLin m} + {~IsLin m}.
Proof.
  intros m. destruct m as [pa|].
  - destruct pa as [p a]. destruct p.
    + left. exact (IsLinProof a).
    + right. intros contra. inversion contra.
  - right. intros contra. inversion contra.
Qed.
Inductive IsFinAge : mode -> Prop :=
  IsFinAgeProof : forall (p : mul) (k : nat), IsFinAge (Some (p, Fin k)).
Theorem IsFinAge_dec : forall (m : mode), {IsFinAge m} + {~IsFinAge m}.
Proof.
  intros m. destruct m as [pa|].
  - destruct pa as [p a]. destruct a.
    + left. exact (IsFinAgeProof p n).
    + right. intros contra. inversion contra.
  - right. intros contra. inversion contra.
Qed.
Definition IsLinNu (m : mode) : Prop := m = Some (Lin, Fin 0).
Theorem IsLinNu_dec : forall (m : mode), {IsLinNu m} + {~IsLinNu m}.
Proof.
  unfold IsLinNu. intros m. apply mode_eq_dec.
Qed.
Inductive IsUr : mode -> Prop :=
  IsUrProof : forall (a : age), IsUr (Some (Ur, a)).
Theorem IsUr_dec : forall (m : mode), {IsUr m} + {~IsUr m}.
Proof.
  intros m. destruct m as [pa|].
  - destruct pa as [p a]. destruct p.
    + right. intros contra. inversion contra.
    + left. exact (IsUrProof a).
  - right. intros contra. inversion contra.
Qed.

(******************************************************************************
 * BINDERS
 *****************************************************************************)

Definition mode_of {n : name} (binding: binding_type_of n): mode :=
  match n return (binding_type_of n) -> mode with
  | name_Var _ => fun binding => match binding with
    | binding_Var m _ => m
    end
  | name_DH _ => fun binding => match binding with
    | binding_Dest m _ _ => m
    | binding_Hole _ n => n
    end
  end binding.

Definition union_var (b1 b2 : binding_var) : binding_var := match b1, b2 with
  | binding_Var m1 T1, binding_Var m2 T2 => match type_eq_dec T1 T2 with
    | left _ => binding_Var (mode_plus m1 m2) T1
    | right _ => binding_Var None type_Unit
    end
  end.

Definition union_dh (b1 b2 : binding_dh) : binding_dh := match b1, b2 with
  | binding_Dest m11 T1 m12, binding_Dest m21 T2 m22 => match type_eq_dec T1 T2, mode_eq_dec m12 m22 with
    | left _, left _ => binding_Dest (mode_plus m11 m21) T1 m12
    | _, _ => binding_Dest None type_Unit None
    end
  | binding_Hole T1 n1, binding_Hole T2 n2 => match type_eq_dec T1 T2 with
    | left _ => binding_Hole T1 (mode_plus n1 n2)
    | right _ => binding_Hole type_Unit None
    end
  | _, _ => binding_Hole type_Unit None
  end.

Definition stimes_var (m' : mode) (b : binding_var) : binding_var := match b with
  | binding_Var m T => binding_Var (mode_times m' m) T
end.
Definition stimes_dh (m' : mode) (b : binding_dh) : binding_dh := match b with
  | binding_Dest m T n => binding_Dest (mode_times m' m) T n
  | binding_Hole T n => binding_Hole T (mode_times m' n)
end.

Definition IsDisposable x : binding_type_of x -> Prop :=
  match x with
  | name_Var _ => fun binding => IsUr (mode_of binding)
  | name_DH _ => fun _ => False
  end.

Definition IsDest x : binding_type_of x -> Prop :=
  match x with
  | name_Var _ => fun _ => False
  | name_DH h => fun b => match b with binding_Dest _  _  _ => True | _ => False end
  end.

Definition IsVar x : binding_type_of x -> Prop :=
  match x with
  | name_Var _ => fun _ => True
  | name_DH _ => fun _ => False
  end.

(******************************************************************************
 * CONTEXTS
 *****************************************************************************)

Definition ctx_singleton (v : name) (binding: binding_type_of v): ctx :=
  Finitely.singleton v (name_eq_dec) binding.

Definition ctx_empty : ctx := Finitely.empty.

Definition union (G1 G2 : ctx) : ctx :=
  Finitely.merge_with (fun n =>
    match n return (binding_type_of n) -> (binding_type_of n) -> (binding_type_of n) with
    | name_Var _ => union_var
    | name_DH _ => union_dh
    end
  ) G1 G2.

Definition stimes (m' : mode) (G : ctx) : ctx :=
  Finitely.map (fun n =>
    match n return (binding_type_of n) -> (binding_type_of n) with
    | name_Var _ => stimes_var m'
    | name_DH _ => stimes_dh m'
    end
  ) G.

Definition hminus_inv (G : ctx) : ctx :=
  Finitely.map (fun n =>
    match n return (binding_type_of n) -> (binding_type_of n) with
    | name_Var _ => fun binding => binding_Var None type_Unit
    | name_DH _ => fun binding => match binding with
      | binding_Dest (Some (Lin, (Fin 0))) T n => binding_Hole T n
      | binding_Dest _ _ _ => binding_Dest None type_Unit None
      | binding_Hole _ _ => binding_Hole type_Unit None
      end
    end
  ) G.

Definition hminus (G : ctx) : ctx :=
  Finitely.map (fun n =>
    match n return (binding_type_of n) -> (binding_type_of n) with
    | name_Var _ => fun binding => binding_Var None type_Unit
    | name_DH _ => fun binding => match binding with
      | binding_Dest _ _ _ => binding_Dest None type_Unit None
      | binding_Hole T n => binding_Dest (Some (Lin, (Fin 0))) T n
      (* TODO: should we check that n is valid? *)
      end
    end
  ) G.

Definition pre_shift (p : Permutation.T) (n : name) : name :=
  match n with
  | name_Var x => name_Var x
  | name_DH h => name_DH (Permutation.sem p h)
  end.

Definition post_process (p : Permutation.T) n : binding_type_of (pre_shift p n) -> binding_type_of n :=
  match n with
  | name_Var _ => fun b => b
  | name_DH _ => fun b => b
  end.

#[program]
Definition ctx_shift (p : Permutation.T) (G : ctx) : ctx :=
  map (post_process p) (
  precomp (pre_shift p )
    (
      fun n => match n with
      | name_Var x => name_Var x :: nil
      | name_DH h => name_DH (Permutation.sem (List.rev p) h) :: nil
      end
    ) G).
Next Obligation.
  unfold List.In, pre_shift.
  destruct w as [xx|xh].
  { tauto. }
  rewrite Permutation.post_inverse.
  tauto.
Qed.

Definition ctx_cshift (G : ctx) (H : hvars) (h' : hvar) : ctx := ctx_shift (List.rev (shift_perm H h')) G.

Definition DestOnly G : Prop := forall x b, G x = Some b -> IsDest x b.

Definition VarOnly G : Prop := forall x b, G x = Some b -> IsVar x b.

Definition NoVar G : Prop := forall x b, G x = Some b -> ~IsVar x b.

Definition LinNuOnly (G : ctx) : Prop := forall (n : name) (binding: binding_type_of n), G n = Some binding -> IsLinNu (mode_of binding).
Definition LinOnly (G : ctx) : Prop := forall (n : name) (binding: binding_type_of n), G n = Some binding -> IsLin (mode_of binding).
Definition FinAgeOnly (G : ctx) : Prop := forall (n : name) (binding: binding_type_of n), G n = Some binding -> IsFinAge (mode_of binding).
Definition ValidOnly (G: ctx) : Prop := forall (n : name) (binding: binding_type_of n), G n = Some binding -> IsValid (mode_of binding).
Definition Disjoint (G1 G2 : ctx) : Prop :=
  forall x, Finitely.In x G1 -> Finitely.In x G2 -> False.

Notation "G '#' H" := (Disjoint G H) (at level 50, no associativity).

Definition DisposableOnly (G: ctx) : Prop :=
  forall (n : name) (binding: binding_type_of n), G n = Some binding -> IsDisposable n binding.

(*
Inductive CompatibleVar : ctx -> var -> mode -> type -> Prop :=
  | ctx_CompatibleProof : forall (P : ctx) (x : var) (m m': mode) (T : type),
    DisposableOnly P -> P # (ctx_singleton (name_Var x) (binding_Var m' T)) -> ModeSubtype m' m -> CompatibleVar (union P (ctx_singleton (name_Var x) (binding_Var m' T))) x m T.

(* Alternative definition for CompatibleVar, we might want to prove that it is equivalent to the inductive definition *)
Definition CompatibleVar' (P: ctx) (x: var) (m : mode) (T: type) : Prop :=
  forall (n : name) (binding: binding_type_of n), P n = Some binding -> (
    (n = (name_Var x) -> exists m', binding = binding_Var m' T /\ ModeSubtype m' m)
 /\ (n <> (name_Var x) -> IsDisposable binding)).
*)

(******************************************************************************
 * EVALUATION CONTEXTS
 *****************************************************************************)

Definition ectxs_fill (C: ectxs) (h':hvar) (H' : hvars) (v':val) : ectxs := List.map (fun c => match c with
  | ectx_OpenAmpar_Foc H v => ectx_OpenAmpar_Foc (HVars.union (HVars.remove h' H) H') (val_fill v h' H' v')
  | _ => c
end) C.

(*****************************************************************************)


Inductive spacing : Type := 
 | sp_space1 : spacing
 | sp_space2 : spacing
 | sp_space3 : spacing
 | sp_space4 : spacing
 | sp_space5 : spacing
 | sp_space6 : spacing
 | sp_space7 : spacing
 | sp_space8 : spacing
 | sp_space9 : spacing
 | sp_space10 : spacing.

Inductive line_break : Type := 
 | b_break : line_break.

Inductive pred : Type :=  (*r Serves for the .mng file. Isn't used in the actual rules *)
 | _DestOnly (G:ctx)
 | _LinOnly (G:ctx)
 | _ValidOnly (G:ctx)
 | _FinAgeOnly (G:ctx)
 | _DisposableOnly (G:ctx)
 | _Disjoint (G1:ctx) (G2:ctx)
 | _HDisjoint (H1:hvars) (H2:hvars)
 | _IsValid (m:mode)
 | _ModeSubtype (m1:mode) (m2:mode)
 | _NotVal (t:term)
 | _hvar_eq (h1:hvar) (h2:hvar)
 | _Ty_val (G:ctx) (v:val) (T:type)
 | _Ty_term (P:ctx) (t:term) (T:type)
 | _Ty_sterm (P:ctx) (t:term) (T:type)
 | _Ty_ectxs (D:ctx) (C:ectxs) (T1:type) (T2:type) (*r Typing of evaluation contexts *)
 | _Ty (C:ectxs) (t:term) (T:type)
 | _Sem (C:ectxs) (t:term) (C':ectxs) (t':term).
(** definitions *)

(* defns Ty *)
Inductive Ty_val : ctx -> val -> type -> Prop :=    (* defn Ty_val *)
 | Ty_val_Hole : forall (h:hvar) (T:type),
     Ty_val  (ctx_singleton (name_DH  h ) (binding_Hole  T    (Some (pair   Lin     (Fin 0)  ))  ))  (val_Hole h) T
 | Ty_val_Dest : forall (h:hvar) (T:type) (n:mode),
     Ty_val  (ctx_singleton (name_DH  h ) (binding_Dest   (Some (pair   Lin     (Fin 0)  ))    T   n ))  (val_Dest h) (type_Dest T n)
 | Ty_val_Unit : 
     Ty_val  ctx_empty  val_Unit type_Unit
 | Ty_val_Fun : forall (D:ctx) (x:var) (m:mode) (u:term) (T U:type)
     (Validm: IsValid m )
     (Tyu: Ty_term  (union  D    (ctx_singleton (name_Var  x ) (binding_Var  m   T ))  )  u U),
     DestOnly D  ->
     Ty_val D (val_Fun x m u) (type_Fun T m U)
 | Ty_val_Left : forall (G:ctx) (v1:val) (T1 T2:type)
     (Tyv1: Ty_val G v1 T1),
     Ty_val G (val_Left v1) (type_Sum T1 T2)
 | Ty_val_Right : forall (G:ctx) (v2:val) (T1 T2:type)
     (Tyv2: Ty_val G v2 T2),
     Ty_val G (val_Right v2) (type_Sum T1 T2)
 | Ty_val_Prod : forall (G1 G2:ctx) (v1 v2:val) (T1 T2:type)
     (Tyv1: Ty_val G1 v1 T1)
     (Tyv2: Ty_val G2 v2 T2),
     Ty_val  (union  G1   G2 )  (val_Prod v1 v2) (type_Prod T1 T2)
 | Ty_val_Exp : forall (n:mode) (G:ctx) (v':val) (T:type)
     (Tyvp: Ty_val G v' T)
     (Validn: IsValid n ),
     Ty_val  (stimes  n   G )  (val_Exp n v') (type_Exp n T)
 | Ty_val_Ampar : forall (D1 D2 D3:ctx) (v2 v1:val) (U T:type)
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (DestOnlyD3: DestOnly D3 )
     (LinOnlyD3: LinOnly D3 )
     (FinAgeOnlyD3: FinAgeOnly D3 )
     (ValidOnlyD3: ValidOnly D3 )
     (DisjointD1D2: D1 # D2 )
     (DisjointD1D3: D1 # D3 )
     (DisjointD2D3: D2 # D3 )
     (Tyv1: Ty_val  (union   (stimes   (Some (pair   Lin     (Fin 1)  ))    D1 )    D3 )  v1 T)
     (Tyv2: Ty_val  (union  D2     (hminus_inv  D3 )   )  v2 U),
     Ty_val  (union  D1   D2 )  (val_Ampar  (hvars_ctx   (hminus_inv  D3 )  )  v2 v1) (type_Ampar U T)
with Ty_term : ctx -> term -> type -> Prop :=    (* defn Ty_term *)
 | Ty_term_Val : forall (P D:ctx) (v:val) (T:type)
     (DisposP: DisposableOnly P )
     (Tyv: Ty_val D v T),
     DestOnly D  ->
     Ty_term  (union  P   D )  (term_Val v) T
 | Ty_term_Var : forall (P:ctx) (x:var) (m:mode) (T:type)
     (DisposP: DisposableOnly P )
     (DisjointPx: P #  (ctx_singleton (name_Var  x ) (binding_Var  m   T ))  )
     (Subtypem:  (Some (pair   Lin     (Fin 0)  ))  <: m ),
     Ty_term  (union  P    (ctx_singleton (name_Var  x ) (binding_Var  m   T ))  )  (term_Var x) T
 | Ty_term_App : forall (m:mode) (P1 P2:ctx) (t' t:term) (U T:type)
     (Validm: IsValid m )
     (Tyt: Ty_term P1 t T)
     (Tytp: Ty_term P2 t' (type_Fun T m U)),
     Ty_term  (union   (stimes  m   P1 )    P2 )  (term_App t' t) U
 | Ty_term_PatU : forall (P1 P2:ctx) (t u:term) (U:type)
     (Tyt: Ty_term P1 t type_Unit)
     (Tyu: Ty_term P2 u U),
     Ty_term  (union  P1   P2 )  (term_PatU t u) U
 | Ty_term_PatS : forall (m:mode) (P1 P2:ctx) (t:term) (x1:var) (u1:term) (x2:var) (u2:term) (U T1 T2:type)
     (Validm: IsValid m )
     (DisjointP2x1: P2 #  (ctx_singleton (name_Var  x1 ) (binding_Var  m   T1 ))  )
     (DisjointP2x2: P2 #  (ctx_singleton (name_Var  x2 ) (binding_Var  m   T2 ))  )
     (Tyt: Ty_term P1 t (type_Sum T1 T2))
     (Tyu1: Ty_term  (union  P2    (ctx_singleton (name_Var  x1 ) (binding_Var  m   T1 ))  )  u1 U)
     (Tyu2: Ty_term  (union  P2    (ctx_singleton (name_Var  x2 ) (binding_Var  m   T2 ))  )  u2 U),
     Ty_term  (union   (stimes  m   P1 )    P2 )  (term_PatS t m x1 u1 x2 u2) U
 | Ty_term_PatP : forall (m:mode) (P1 P2:ctx) (t:term) (x1 x2:var) (u:term) (U T1 T2:type)
     (Validm: IsValid m )
     (DisjointP2x1: P2 #  (ctx_singleton (name_Var  x1 ) (binding_Var  m   T1 ))  )
     (DisjointP2x2: P2 #  (ctx_singleton (name_Var  x2 ) (binding_Var  m   T2 ))  )
     (Disjointx1x2:  (ctx_singleton (name_Var  x1 ) (binding_Var  m   T1 ))  #  (ctx_singleton (name_Var  x2 ) (binding_Var  m   T2 ))  )
     (Tyt: Ty_term P1 t (type_Prod T1 T2))
     (Tyu: Ty_term  (union   (union  P2    (ctx_singleton (name_Var  x1 ) (binding_Var  m   T1 ))  )     (ctx_singleton (name_Var  x2 ) (binding_Var  m   T2 ))  )  u U),
     Ty_term  (union   (stimes  m   P1 )    P2 )  (term_PatP t m x1 x2 u) U
 | Ty_term_PatE : forall (m:mode) (P1 P2:ctx) (t:term) (n:mode) (x:var) (u:term) (U T:type)
     (Validm: IsValid m )
     (Validn: IsValid n )
     (DisjointP2x: P2 #  (ctx_singleton (name_Var  x ) (binding_Var   (mode_times'  ((app (cons m nil) (app (cons n nil) nil))) )    T ))  )
     (Tyt: Ty_term P1 t (type_Exp n T))
     (Tyu: Ty_term  (union  P2    (ctx_singleton (name_Var  x ) (binding_Var   (mode_times'  ((app (cons m nil) (app (cons n nil) nil))) )    T ))  )  u U),
     Ty_term  (union   (stimes  m   P1 )    P2 )  (term_PatE t m n x u) U
 | Ty_term_Map : forall (P1 P2:ctx) (t:term) (x:var) (t':term) (U T' T:type)
     (DisjointP2x: P2 #  (ctx_singleton (name_Var  x ) (binding_Var   (Some (pair   Lin     (Fin 0)  ))    T ))  )
     (Tyt: Ty_term P1 t (type_Ampar U T))
     (Tytp: Ty_term  (union   (stimes   (Some (pair   Lin     (Fin 1)  ))    P2 )     (ctx_singleton (name_Var  x ) (binding_Var   (Some (pair   Lin     (Fin 0)  ))    T ))  )  t' T'),
     Ty_term  (union  P1   P2 )  (term_Map t x t') (type_Ampar U T')
 | Ty_term_ToA : forall (P:ctx) (u:term) (U:type)
     (Tyu: Ty_term P u U),
     Ty_term P (term_ToA u) (type_Ampar U type_Unit)
 | Ty_term_FromA : forall (P:ctx) (t:term) (U T:type)
     (Tyt: Ty_term P t (type_Ampar U  (type_Exp  (Some (pair   Lin     Inf  ))  T) )),
     Ty_term P (term_FromA t) (type_Prod U  (type_Exp  (Some (pair   Lin     Inf  ))  T) )
 | Ty_term_FillU : forall (P:ctx) (t:term) (n:mode)
     (Tyt: Ty_term P t (type_Dest type_Unit n)),
     Ty_term P (term_FillU t) type_Unit
 | Ty_term_FillL : forall (P:ctx) (t:term) (T1:type) (n:mode) (T2:type)
     (Tyt: Ty_term P t (type_Dest (type_Sum T1 T2) n)),
     Ty_term P (term_FillL t) (type_Dest T1 n)
 | Ty_term_FillR : forall (P:ctx) (t:term) (T2:type) (n:mode) (T1:type)
     (Tyt: Ty_term P t (type_Dest (type_Sum T1 T2) n)),
     Ty_term P (term_FillR t) (type_Dest T2 n)
 | Ty_term_FillP : forall (P:ctx) (t:term) (T1:type) (n:mode) (T2:type)
     (Tyt: Ty_term P t (type_Dest (type_Prod T1 T2) n)),
     Ty_term P (term_FillP t) (type_Prod (type_Dest T1 n) (type_Dest T2 n))
 | Ty_term_FillE : forall (P:ctx) (t:term) (n':mode) (T:type) (n:mode)
     (Validn: IsValid n )
     (Tyt: Ty_term P t (type_Dest (type_Exp n' T) n)),
     Ty_term P (term_FillE t n') (type_Dest T  (mode_times'  ((app (cons n' nil) (app (cons n nil) nil))) ) )
 | Ty_term_FillF : forall (P1:ctx) (n:mode) (P2:ctx) (t:term) (x:var) (m:mode) (u:term) (T U:type)
     (Validm: IsValid m )
     (Validn: IsValid n )
     (DisjointP2x: P2 #  (ctx_singleton (name_Var  x ) (binding_Var  m   T ))  )
     (Tyt: Ty_term P1 t (type_Dest (type_Fun T m U) n))
     (Tyu: Ty_term  (union  P2    (ctx_singleton (name_Var  x ) (binding_Var  m   T ))  )  u U),
     Ty_term  (union  P1    (stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     P2 )  )  (term_FillF t x m u) type_Unit
 | Ty_term_FillComp : forall (P1:ctx) (n:mode) (P2:ctx) (t t':term) (T U:type)
     (Validn: IsValid n )
     (Tyt: Ty_term P1 t (type_Dest U n))
     (Tytp: Ty_term P2 t' (type_Ampar U T)),
     Ty_term  (union  P1    (stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     P2 )  )  (term_FillComp t t') T
with Ty_sterm : ctx -> term -> type -> Prop :=    (* defn Ty_sterm *)
 | Ty_sterm_Alloc : forall (P:ctx) (T:type)
     (DisposP: DisposableOnly P ),
     Ty_sterm P  (sterm_Alloc)  (type_Ampar T  (type_Dest T  (Some (pair   Lin     (Fin 0)  )) ) )
 | Ty_sterm_FromA' : forall (P:ctx) (t:term) (T:type)
     (Tyt: Ty_term P t (type_Ampar T type_Unit)),
     Ty_sterm P  (sterm_FromA'  t )  T
 | Ty_sterm_FillLeaf : forall (P1:ctx) (n:mode) (P2:ctx) (t t':term) (T:type)
     (Validn: IsValid n )
     (Tyt: Ty_term P1 t (type_Dest T n))
     (Tytp: Ty_term P2 t' T),
     Ty_sterm  (union  P1    (stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     P2 )  )   (sterm_FillLeaf  t   t' )  type_Unit
 | Ty_sterm_Fun : forall (P2:ctx) (x:var) (m:mode) (u:term) (T U:type)
     (UserDefinedP2: UserDefined P2 )
     (Validm: IsValid m )
     (DisjointP2x: P2 #  (ctx_singleton (name_Var  x ) (binding_Var  m   T ))  )
     (Tyu: Ty_term  (union  P2    (ctx_singleton (name_Var  x ) (binding_Var  m   T ))  )  u U),
     Ty_sterm P2  (sterm_Fun  x   m   u )  (type_Fun T m U)
 | Ty_sterm_Left : forall (P2:ctx) (t:term) (T1 T2:type)
     (UserDefinedP2: UserDefined P2 ),
     Ty_term P2 t T1 ->
     Ty_sterm P2  (sterm_Left  t )  (type_Sum T1 T2)
 | Ty_sterm_Right : forall (P2:ctx) (t:term) (T1 T2:type)
     (UserDefinedP2: UserDefined P2 ),
     Ty_term P2 t T2 ->
     Ty_sterm P2  (sterm_Right  t )  (type_Sum T1 T2)
 | Ty_sterm_Exp : forall (m:mode) (P2:ctx) (t:term) (T:type)
     (UserDefinedP2: UserDefined P2 )
     (Validm: IsValid m ),
     Ty_term P2 t T ->
     Ty_sterm  (stimes  m   P2 )   (sterm_Exp  m   t )  (type_Exp m T)
 | Ty_sterm_Prod : forall (P21 P22:ctx) (t1 t2:term) (T1 T2:type)
     (UserDefinedP21: UserDefined P21 )
     (UserDefinedP22: UserDefined P22 ),
     Ty_term P21 t1 T1 ->
     Ty_term P22 t2 T2 ->
     Ty_sterm  (union  P21   P22 )   (sterm_Prod  t1   t2 )  (type_Prod T1 T2)
with Ty_ectxs : ctx -> ectxs -> type -> type -> Prop :=    (* defn Ty_ectxs *)
 | Ty_ectxs_Id : forall (U0:type),
     Ty_ectxs  ctx_empty   nil  U0 U0
 | Ty_ectxs_App_Foc1 : forall (D1:ctx) (C:ectxs) (t':term) (T U0:type) (D2:ctx) (m:mode) (U:type)
     (DisjointD1D2: D1 # D2 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (Validm: IsValid m )
     (ValidOnlyD2: ValidOnly D2 )
     (TyC: Ty_ectxs  (union   (stimes  m   D1 )    D2 )  C U U0)
     (Tytp: Ty_term D2 t' (type_Fun T m U)),
     Ty_ectxs D1  (cons   (ectx_App_Foc1 t')    C )  T U0
 | Ty_ectxs_App_Foc2 : forall (D2:ctx) (C:ectxs) (v:val) (T:type) (m:mode) (U U0:type) (D1:ctx)
     (DisjointD1D2: D1 # D2 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (Validm: IsValid m )
     (ValidOnlyD1: ValidOnly D1 )
     (TyC: Ty_ectxs  (union   (stimes  m   D1 )    D2 )  C U U0)
     (Tyv: Ty_term D1 (term_Val v) T),
     Ty_ectxs D2  (cons   (ectx_App_Foc2 v)    C )   (type_Fun T m U)  U0
 | Ty_ectxs_PatU_Foc : forall (D1:ctx) (C:ectxs) (u:term) (U0:type) (D2:ctx) (U:type)
     (DisjointD1D2: D1 # D2 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (ValidOnlyD2: ValidOnly D2 )
     (TyC: Ty_ectxs  (union  D1   D2 )  C U U0)
     (Tyu: Ty_term D2 u U),
     Ty_ectxs D1  (cons   (ectx_PatU_Foc u)    C )  type_Unit U0
 | Ty_ectxs_PatS_Foc : forall (D1:ctx) (C:ectxs) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term) (T1 T2 U0:type) (D2:ctx) (U:type)
     (DisjointD1D2: D1 # D2 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (Validm: IsValid m )
     (ValidOnlyD2: ValidOnly D2 )
     (TyC: Ty_ectxs  (union   (stimes  m   D1 )    D2 )  C U U0)
     (Tyu1: Ty_term  (union  D2    (ctx_singleton (name_Var  x1 ) (binding_Var  m   T1 ))  )  u1 U)
     (Tyu2: Ty_term  (union  D2    (ctx_singleton (name_Var  x2 ) (binding_Var  m   T2 ))  )  u2 U),
     Ty_ectxs D1  (cons   (ectx_PatS_Foc m x1 u1 x2 u2)    C )   (type_Sum T1 T2)  U0
 | Ty_ectxs_PatP_Foc : forall (D1:ctx) (C:ectxs) (m:mode) (x1 x2:var) (u:term) (T1 T2 U0:type) (D2:ctx) (U:type)
     (DisjointD1D2: D1 # D2 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (Disjointx1x2:  (ctx_singleton (name_Var  x1 ) (binding_Var  m   T1 ))  #  (ctx_singleton (name_Var  x2 ) (binding_Var  m   T2 ))  )
     (Validm: IsValid m )
     (ValidOnlyD2: ValidOnly D2 )
     (TyC: Ty_ectxs  (union   (stimes  m   D1 )    D2 )  C U U0)
     (Tyu: Ty_term  (union   (union  D2    (ctx_singleton (name_Var  x1 ) (binding_Var  m   T1 ))  )     (ctx_singleton (name_Var  x2 ) (binding_Var  m   T2 ))  )  u U),
     Ty_ectxs D1  (cons   (ectx_PatP_Foc m x1 x2 u)    C )   (type_Prod T1 T2)  U0
 | Ty_ectxs_PatE_Foc : forall (D1:ctx) (C:ectxs) (m m':mode) (x:var) (u:term) (T U0:type) (D2:ctx) (U:type)
     (DisjointD1D2: D1 # D2 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (Validm: IsValid m )
     (Validmp: IsValid m' )
     (ValidOnlyD2: ValidOnly D2 )
     (TyC: Ty_ectxs  (union   (stimes  m   D1 )    D2 )  C U U0)
     (Tyu: Ty_term  (union  D2    (ctx_singleton (name_Var  x ) (binding_Var   (mode_times'  ((app (cons m nil) (app (cons m' nil) nil))) )    T ))  )  u U),
     Ty_ectxs D1  (cons   (ectx_PatE_Foc m m' x u)    C )  (type_Exp m' T) U0
 | Ty_ectxs_Map_Foc : forall (D1:ctx) (C:ectxs) (x:var) (t':term) (U T U0:type) (D2:ctx) (T':type)
     (DisjointD1D2: D1 # D2 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (ValidOnlyD2: ValidOnly D2 )
     (TyC: Ty_ectxs  (union  D1   D2 )  C (type_Ampar U T') U0)
     (Tytp: Ty_term  (union   (stimes   (Some (pair   Lin     (Fin 1)  ))    D2 )     (ctx_singleton (name_Var  x ) (binding_Var   (Some (pair   Lin     (Fin 0)  ))    T ))  )  t' T'),
     Ty_ectxs D1  (cons   (ectx_Map_Foc x t')    C )   (type_Ampar U T)  U0
 | Ty_ectxs_ToA_Foc : forall (D:ctx) (C:ectxs) (U U0:type)
     (TyC: Ty_ectxs D C  (type_Ampar U type_Unit)  U0),
     Ty_ectxs D  (cons   ectx_ToA_Foc    C )  U U0
 | Ty_ectxs_FromA_Foc : forall (D:ctx) (C:ectxs) (U T U0:type)
     (TyC: Ty_ectxs D C  (type_Prod U  (type_Exp  (Some (pair   Lin     Inf  ))  T) )  U0),
     Ty_ectxs D  (cons   ectx_FromA_Foc    C )   (type_Ampar U  (type_Exp  (Some (pair   Lin     Inf  ))  T) )  U0
 | Ty_ectxs_FillU_Foc : forall (D:ctx) (C:ectxs) (n:mode) (U0:type)
     (TyC: Ty_ectxs D C type_Unit U0),
     Ty_ectxs D  (cons   ectx_FillU_Foc    C )  (type_Dest type_Unit n) U0
 | Ty_ectxs_FillL_Foc : forall (D:ctx) (C:ectxs) (T1 T2:type) (n:mode) (U0:type)
     (TyC: Ty_ectxs D C (type_Dest T1 n) U0),
     Ty_ectxs D  (cons   ectx_FillL_Foc    C )  (type_Dest (type_Sum T1 T2) n) U0
 | Ty_ectxs_FillR_Foc : forall (D:ctx) (C:ectxs) (T1 T2:type) (n:mode) (U0:type)
     (TyC: Ty_ectxs D C (type_Dest T2 n) U0),
     Ty_ectxs D  (cons   ectx_FillR_Foc    C )  (type_Dest (type_Sum T1 T2) n) U0
 | Ty_ectxs_FillP_Foc : forall (D:ctx) (C:ectxs) (T1 T2:type) (n:mode) (U0:type)
     (TyC: Ty_ectxs D C  (type_Prod (type_Dest T1 n) (type_Dest T2 n))  U0),
     Ty_ectxs D  (cons   ectx_FillP_Foc    C )  (type_Dest (type_Prod T1 T2) n) U0
 | Ty_ectxs_FillE_Foc : forall (D:ctx) (C:ectxs) (m:mode) (T:type) (n:mode) (U0:type)
     (Validm: IsValid m )
     (TyC: Ty_ectxs D C (type_Dest T  (mode_times'  ((app (cons m nil) (app (cons n nil) nil))) ) ) U0),
     Ty_ectxs D  (cons   (ectx_FillE_Foc m)    C )  (type_Dest (type_Exp m T) n) U0
 | Ty_ectxs_FillF_Foc : forall (D1:ctx) (C:ectxs) (x:var) (m:mode) (u:term) (T U:type) (n:mode) (U0:type) (D2:ctx)
     (DisjointD1D2: D1 # D2 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (ValidOnlyD2: ValidOnly D2 )
     (Validm: IsValid m )
     (Validn: IsValid n )
     (TyC: Ty_ectxs  (union  D1    (stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     D2 )  )  C type_Unit U0)
     (Tyu: Ty_term  (union  D2    (ctx_singleton (name_Var  x ) (binding_Var  m   T ))  )  u U),
     Ty_ectxs D1  (cons   (ectx_FillF_Foc x m u)    C )  (type_Dest (type_Fun T m U) n) U0
 | Ty_ectxs_FillComp_Foc1 : forall (D1:ctx) (C:ectxs) (t':term) (U:type) (n:mode) (U0:type) (D2:ctx) (T:type)
     (DisjointD1D2: D1 # D2 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (ValidOnlyD2: ValidOnly D2 )
     (Validn: IsValid n )
     (TyC: Ty_ectxs  (union  D1    (stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     D2 )  )  C T U0)
     (Tytp: Ty_term D2 t' (type_Ampar U T)),
     Ty_ectxs D1  (cons   (ectx_FillComp_Foc1 t')    C )  (type_Dest U n) U0
 | Ty_ectxs_FillComp_Foc2 : forall (D2:ctx) (C:ectxs) (v:val) (U T U0:type) (D1:ctx) (n:mode)
     (DisjointD1D2: D1 # D2 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (ValidOnlyD1: ValidOnly D1 )
     (Validn: IsValid n )
     (TyC: Ty_ectxs  (union  D1    (stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     D2 )  )  C T U0)
     (Tyt: Ty_term D1 (term_Val v) (type_Dest U n)),
     Ty_ectxs D2  (cons   (ectx_FillComp_Foc2 v)    C )  (type_Ampar U T) U0
 | Ty_ectxs_OpenAmpar_Foc : forall (D1 D3:ctx) (C:ectxs) (v2:val) (T' U0:type) (D2:ctx) (U:type)
     (Disjoint1D2: D1 # D2 )
     (Disjoint1D3: D1 # D3 )
     (Disjoint2D3: D2 # D3 )
     (DestOnlyD1: DestOnly D1 )
     (DestOnlyD2: DestOnly D2 )
     (DestOnlyD3: DestOnly D3 )
     (LinOnlyD3: LinOnly D3 )
     (FinAgeOnlyD3: FinAgeOnly D3 )
     (ValidOnlyD3: ValidOnly D3 )
     (TyC: Ty_ectxs  (union  D1   D2 )  C  (type_Ampar U T')  U0)
     (Tyv2: Ty_val  (union  D2    (hminus_inv  D3 )  )  v2 U),
      (hvars_ectxs  C )  ##  (hvars_ctx   (hminus_inv  D3 )  )   ->
     Ty_ectxs  (union   (stimes   (Some (pair   Lin     (Fin 1)  ))    D1 )    D3 )   (cons   (ectx_OpenAmpar_Foc  (hvars_ctx   (hminus_inv  D3 )  )  v2)    C )  T' U0
with Ty : ectxs -> term -> type -> Prop :=    (* defn Ty *)
 | Ty_cmd : forall (C:ectxs) (t:term) (U0:type) (D:ctx) (T:type)
     (ValidOnlyD: ValidOnly D )
     (DestOnlyD: DestOnly D )
     (TyC: Ty_ectxs D C T U0)
     (Tyt: Ty_term D t T),
     Ty C t U0.
(** definitions *)

(* defns Sem *)
Inductive Sem : ectxs -> term -> ectxs -> term -> Prop :=    (* defn Sem *)
 | Sem_App_Foc1 : forall (C:ectxs) (t' t:term)
     (NotValt: NotVal t ),
     Sem C (term_App t' t)   (cons   (ectx_App_Foc1 t')    C )   t
 | Sem_App_Unfoc1 : forall (C:ectxs) (t':term) (v:val),
     Sem   (cons   (ectx_App_Foc1 t')    C )   (term_Val v) C (term_App t' (term_Val v))
 | Sem_App_Foc2 : forall (C:ectxs) (t':term) (v:val)
     (NotValtp: NotVal t' ),
     Sem C (term_App t' (term_Val v))   (cons   (ectx_App_Foc2 v)    C )   t'
 | Sem_App_Unfoc2 : forall (C:ectxs) (v v':val),
     Sem   (cons   (ectx_App_Foc2 v)    C )   (term_Val v') C (term_App (term_Val v') (term_Val v))
 | Sem_App_Red : forall (C:ectxs) (x:var) (m:mode) (u:term) (v:val),
     Sem C (term_App (term_Val  (val_Fun x m u) ) (term_Val v)) C  (term_sub  u   x   v ) 
 | Sem_PatU_Foc : forall (C:ectxs) (t u:term)
     (NotValt: NotVal t ),
     Sem C (term_PatU t u)   (cons   (ectx_PatU_Foc u)    C )   t
 | Sem_PatU_Unfoc : forall (C:ectxs) (u:term) (v:val),
     Sem   (cons   (ectx_PatU_Foc u)    C )   (term_Val v) C (term_PatU (term_Val v) u)
 | Sem_PatU_Red : forall (C:ectxs) (u:term),
     Sem C (term_PatU (term_Val val_Unit) u) C u
 | Sem_PatS_Foc : forall (C:ectxs) (t:term) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term)
     (NotValt: NotVal t ),
     Sem C (term_PatS t m x1 u1 x2 u2)   (cons   (ectx_PatS_Foc m x1 u1 x2 u2)    C )   t
 | Sem_PatS_Unfoc : forall (C:ectxs) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term) (v:val),
     Sem   (cons   (ectx_PatS_Foc m x1 u1 x2 u2)    C )   (term_Val v) C (term_PatS (term_Val v) m x1 u1 x2 u2)
 | Sem_PatL_Red : forall (C:ectxs) (v1:val) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term),
     Sem C (term_PatS (term_Val  (val_Left v1) ) m x1 u1 x2 u2) C  (term_sub  u1   x1   v1 ) 
 | Sem_PatR_Red : forall (C:ectxs) (v2:val) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term),
     Sem C (term_PatS (term_Val  (val_Right v2) ) m x1 u1 x2 u2) C  (term_sub  u2   x2   v2 ) 
 | Sem_PatP_Foc : forall (C:ectxs) (t:term) (m:mode) (x1 x2:var) (u:term)
     (NotValt: NotVal t ),
     Sem C (term_PatP t m x1 x2 u)   (cons   (ectx_PatP_Foc m x1 x2 u)    C )   t
 | Sem_PatP_Unfoc : forall (C:ectxs) (m:mode) (x1 x2:var) (u:term) (v:val),
     Sem   (cons   (ectx_PatP_Foc m x1 x2 u)    C )   (term_Val v) C (term_PatP (term_Val v) m x1 x2 u)
 | Sem_PatP_Red : forall (C:ectxs) (v1 v2:val) (m:mode) (x1 x2:var) (u:term),
     Sem C (term_PatP (term_Val (val_Prod v1 v2)) m x1 x2 u) C  (term_sub   (term_sub  u   x1   v1 )    x2   v2 ) 
 | Sem_PatE_Foc : forall (C:ectxs) (t:term) (m n:mode) (x:var) (u:term)
     (NotValt: NotVal t ),
     Sem C (term_PatE t m n x u)   (cons   (ectx_PatE_Foc m n x u)    C )   t
 | Sem_PatE_Unfoc : forall (C:ectxs) (m n:mode) (x:var) (u:term) (v:val),
     Sem   (cons   (ectx_PatE_Foc m n x u)    C )   (term_Val v) C (term_PatE (term_Val v) m n x u)
 | Sem_PatE_Red : forall (C:ectxs) (n:mode) (v':val) (m:mode) (x:var) (u:term),
     Sem C (term_PatE (term_Val (val_Exp n v')) m n x u) C  (term_sub  u   x   v' ) 
 | Sem_Map_Foc : forall (C:ectxs) (t:term) (x:var) (t':term)
     (NotValt: NotVal t ),
     Sem C (term_Map t x t')   (cons   (ectx_Map_Foc x t')    C )   t
 | Sem_Map_Unfoc : forall (C:ectxs) (x:var) (t':term) (v:val),
     Sem   (cons   (ectx_Map_Foc x t')    C )   (term_Val v) C (term_Map (term_Val v) x t')
 | Sem_Map_Red_OpenAmpar_Foc : forall (C:ectxs) (H:hvars) (v2 v1:val) (x:var) (t':term) (h':hvar)
     (hpMaxC: h' =  (  (hvar_max   (hvars_ectxs  C )  )   +   1  )  ),
     Sem C (term_Map (term_Val (val_Ampar H v2 v1)) x t')   (cons   (ectx_OpenAmpar_Foc  (hvars_shift  H   h' )   (val_cshift  v2   H   h' ) )    C )    (term_sub  t'   x    (val_cshift  v1   H   h' )  ) 
 | Sem_OpenAmpar_Unfoc : forall (C:ectxs) (H:hvars) (v2 v1:val),
     Sem   (cons  (ectx_OpenAmpar_Foc H v2)   C )   (term_Val v1) C (term_Val (val_Ampar H v2 v1))
 | Sem_ToA_Foc : forall (C:ectxs) (u:term)
     (NotValu: NotVal u ),
     Sem C (term_ToA u)   (cons   ectx_ToA_Foc    C )   u
 | Sem_ToA_Unfoc : forall (C:ectxs) (v2:val),
     Sem   (cons   ectx_ToA_Foc    C )   (term_Val v2) C (term_ToA (term_Val v2))
 | Sem_ToA_Red : forall (C:ectxs) (v2:val),
     Sem C (term_ToA (term_Val v2)) C (term_Val (val_Ampar  (hvars_  nil )  v2 val_Unit))
 | Sem_FromA_Foc : forall (C:ectxs) (t:term)
     (NotValt: NotVal t ),
     Sem C (term_FromA t)   (cons   ectx_FromA_Foc    C )   t
 | Sem_FromA_Unfoc : forall (C:ectxs) (v:val),
     Sem   (cons   ectx_FromA_Foc    C )   (term_Val v) C (term_FromA (term_Val v))
 | Sem_FromA_Red : forall (C:ectxs) (v2 v1:val),
     Sem C (term_FromA (term_Val (val_Ampar  (hvars_  nil )  v2 (val_Exp  (Some (pair   Lin     Inf  ))  v1)))) C (term_Val (val_Prod v2 (val_Exp  (Some (pair   Lin     Inf  ))  v1)))
 | Sem_FillU_Foc : forall (C:ectxs) (t:term)
     (NotValt: NotVal t ),
     Sem C (term_FillU t)   (cons   ectx_FillU_Foc    C )   t
 | Sem_FillU_Unfoc : forall (C:ectxs) (v:val),
     Sem   (cons   ectx_FillU_Foc    C )   (term_Val v) C (term_FillU (term_Val v))
 | Sem_FillU_Red : forall (C:ectxs) (h:hvar),
     Sem C (term_FillU (term_Val (val_Dest h)))  (ectxs_fill  C   h    (hvars_  nil )    val_Unit )  (term_Val val_Unit)
 | Sem_FillL_Foc : forall (C:ectxs) (t:term)
     (NotValt: NotVal t ),
     Sem C (term_FillL t)   (cons   ectx_FillL_Foc    C )   t
 | Sem_FillL_Unfoc : forall (C:ectxs) (v:val),
     Sem   (cons   ectx_FillL_Foc    C )   (term_Val v) C (term_FillL (term_Val v))
 | Sem_FillL_Red : forall (C:ectxs) (h h':hvar)
     (hpMaxCh: h' =  (  (hvar_max   (HVars.union   (hvars_ectxs  C )     (hvars_  (cons h nil) )  )  )   +   1  )  ),
     Sem C (term_FillL (term_Val (val_Dest h)))  (ectxs_fill  C   h    (hvars_  (cons  ( h'  +   1  )  nil) )    (val_Left (val_Hole   ( h'  +   1  )  )) )  (term_Val (val_Dest   ( h'  +   1  )  ))
 | Sem_FillR_Foc : forall (C:ectxs) (t:term)
     (NotValt: NotVal t ),
     Sem C (term_FillR t)   (cons   ectx_FillR_Foc    C )   t
 | Sem_FillR_Unfoc : forall (C:ectxs) (v:val),
     Sem   (cons   ectx_FillR_Foc    C )   (term_Val v) C (term_FillR (term_Val v))
 | Sem_FillR_Red : forall (C:ectxs) (h h':hvar)
     (hpMaxCh: h' =  (  (hvar_max   (HVars.union   (hvars_ectxs  C )     (hvars_  (cons h nil) )  )  )   +   1  )  ),
     Sem C (term_FillR (term_Val (val_Dest h)))  (ectxs_fill  C   h    (hvars_  (cons  ( h'  +   1  )  nil) )    (val_Right (val_Hole   ( h'  +   1  )  )) )  (term_Val (val_Dest   ( h'  +   1  )  ))
 | Sem_FillE_Foc : forall (C:ectxs) (t:term) (m:mode)
     (NotValt: NotVal t ),
     Sem C (term_FillE t m)   (cons   (ectx_FillE_Foc m)    C )   t
 | Sem_FillE_Unfoc : forall (C:ectxs) (m:mode) (v:val),
     Sem   (cons   (ectx_FillE_Foc m)    C )   (term_Val v) C (term_FillE (term_Val v) m)
 | Sem_FillE_Red : forall (C:ectxs) (h:hvar) (m:mode) (h':hvar)
     (hpMaxCh: h' =  (  (hvar_max   (HVars.union   (hvars_ectxs  C )     (hvars_  (cons h nil) )  )  )   +   1  )  ),
     Sem C (term_FillE (term_Val (val_Dest h)) m)  (ectxs_fill  C   h    (hvars_  (cons  ( h'  +   1  )  nil) )    (val_Exp m (val_Hole   ( h'  +   1  )  )) )  (term_Val (val_Dest   ( h'  +   1  )  ))
 | Sem_FillP_Foc : forall (C:ectxs) (t:term)
     (NotValt: NotVal t ),
     Sem C (term_FillP t)   (cons   ectx_FillP_Foc    C )   t
 | Sem_FillP_Unfoc : forall (C:ectxs) (v:val),
     Sem   (cons   ectx_FillP_Foc    C )   (term_Val v) C (term_FillP (term_Val v))
 | Sem_FillP_Red : forall (C:ectxs) (h h':hvar)
     (hpMaxCh: h' =  (  (hvar_max   (HVars.union   (hvars_ectxs  C )     (hvars_  (cons h nil) )  )  )   +   1  )  ),
     Sem C (term_FillP (term_Val (val_Dest h)))  (ectxs_fill  C   h    (hvars_  ((app (cons  ( h'  +   1  )  nil) (app (cons  ( h'  +   2  )  nil) nil))) )    (val_Prod (val_Hole   ( h'  +   1  )  ) (val_Hole   ( h'  +   2  )  )) )  (term_Val (val_Prod (val_Dest   ( h'  +   1  )  ) (val_Dest   ( h'  +   2  )  )))
 | Sem_FillF_Foc : forall (C:ectxs) (t:term) (x:var) (m:mode) (u:term)
     (NotValt: NotVal t ),
     Sem C (term_FillF t x m u)   (cons   (ectx_FillF_Foc x m u)    C )   t
 | Sem_FillF_Unfoc : forall (C:ectxs) (x:var) (m:mode) (u:term) (v:val),
     Sem   (cons   (ectx_FillF_Foc x m u)    C )   (term_Val v) C (term_FillF (term_Val v) x m u)
 | Sem_FillF_Red : forall (C:ectxs) (h:hvar) (x:var) (m:mode) (u:term),
     Sem C (term_FillF (term_Val (val_Dest h)) x m u)  (ectxs_fill  C   h    (hvars_  nil )    (val_Fun x m u) )  (term_Val val_Unit)
 | Sem_FillComp_Foc1 : forall (C:ectxs) (t t':term)
     (NotValt: NotVal t ),
     Sem C (term_FillComp t t')   (cons   (ectx_FillComp_Foc1 t')    C )   t
 | Sem_FillComp_Unfoc1 : forall (C:ectxs) (t':term) (v:val),
     Sem   (cons   (ectx_FillComp_Foc1 t')    C )   (term_Val v) C (term_FillComp (term_Val v) t')
 | Sem_FillComp_Foc2 : forall (C:ectxs) (v:val) (t':term)
     (NotValtp: NotVal t' ),
     Sem C (term_FillComp (term_Val v) t')   (cons   (ectx_FillComp_Foc2 v)    C )   t'
 | Sem_FillComp_Unfoc2 : forall (C:ectxs) (v v':val),
     Sem   (cons   (ectx_FillComp_Foc2 v)    C )   (term_Val v') C (term_FillComp (term_Val v) (term_Val v'))
 | Sem_FillComp_Red : forall (C:ectxs) (h:hvar) (H:hvars) (v2 v1:val) (h':hvar)
     (hpMaxCh: h' =  (  (hvar_max   (HVars.union   (hvars_ectxs  C )     (hvars_  (cons h nil) )  )  )   +   1  )  ),
     Sem C (term_FillComp (term_Val (val_Dest h)) (term_Val (val_Ampar H v2 v1)))  (ectxs_fill  C   h     (hvars_shift  H   h' )      (val_cshift  v2   H   h' )  )  (term_Val  (val_cshift  v1   H   h' ) ).


