(* generated by Ott 0.33 from: rules.ott grammar.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Import Ott.ext_nat.
Require Import Coq.Structures.Equalities.
Require Import Coq.Structures.Orders.
Require Import Coq.Structures.OrdersAlt.
Require Import Coq.Structures.OrdersEx.
Require Import Coq.FSets.FMapList.
Require Import Coq.FSets.FSetList.
Require Import Coq.FSets.FMapFacts.
Require Import Coq.FSets.FSetFacts.

Module Nat_as_OTOrig := Backport_OT(Nat_as_OT).
Module HdnsM := FSetList.Make(Nat_as_OTOrig).
Module NmapM := FMapList.Make(Nat_as_OTOrig).

(* We need to predefine eq_dec for mode so that Ott can generate eq_dec for type *)
(* Will be aliased later to mul *)
Inductive _mul : Type :=
  | Lin : _mul
  | Ur : _mul.
Theorem mul_eq_dec : forall (p1 p2: _mul), {p1 = p2} + {p1 <> p2}.
Proof.
  decide equality.
Defined.
Definition age_eq_dec : forall (a1 a2: ext_nat), {a1 = a2} + {a1 <> a2} := ext_eq_dec.
Theorem mode_eq_dec : forall (m1 m2: option (_mul * ext_nat)), {m1 = m2} + {m1 <> m2}.
Proof.
  decide equality. destruct a, p.
  - destruct (mul_eq_dec _m _m0), (age_eq_dec e e0); subst; auto.
    * right. congruence.
    * right. congruence.
    * right. congruence.
Defined.

Definition var : Type := nat. (*r Term-level variable name *)
Definition k : Type := nat. (*r Index for ranges *)

Definition age : Type := ext_nat.

Definition mul : Type := _mul.

Definition hdn : Type := nat.

Definition mode : Type := option (mul * age).

Definition hdns : Type := HdnsM.t.

Inductive type : Type :=  (*r Type *)
 | type_U : type (*r Unit *)
 | type_S (T1:type) (T2:type) (*r Sum *)
 | type_P (T1:type) (T2:type) (*r Product *)
 | type_E (m:mode) (T:type) (*r Exponential *)
 | type_A (T1:type) (T2:type) (*r Ampar type (consuming $(T2:type)$ yields $(T1:type)$) *)
 | type_F (T1:type) (m1:mode) (T2:type) (*r Function *)
 | type_D (T:type) (m:mode) (*r Destination *).

Inductive term : Type :=  (*r Term *)
 | term_Val (v:val) (*r Value *)
 | term_Var (x:var) (*r Variable *)
 | term_App (t:term) (u:term) (*r Application *)
 | term_PatU (t:term) (u:term) (*r Pattern-match on unit *)
 | term_PatS (t:term) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term) (*r Pattern-match on sum *)
 | term_PatP (t:term) (m:mode) (x1:var) (x2:var) (u:term) (*r Pattern-match on product *)
 | term_PatE (t:term) (m:mode) (n:mode) (x:var) (u:term) (*r Pattern-match on exponential *)
 | term_Map (t:term) (x:var) (u:term) (*r Map over the right side of ampar $(t:term)$ *)
 | term_ToA (t:term) (*r Wrap $(t:term)$ into a trivial ampar *)
 | term_FromA (t:term) (*r Extract value from trivial ampar *)
 | term_Alloc : term (*r Return a fresh "identity" ampar object *)
 | term_FillU (t:term) (*r Fill destination with unit *)
 | term_FillL (t:term) (*r Fill destination with left variant *)
 | term_FillR (t:term) (*r Fill destination with right variant *)
 | term_FillE (t:term) (m:mode) (*r Fill destination with exponential constructor *)
 | term_FillP (t:term) (*r Fill destination with product constructor *)
 | term_FillF (t:term) (x:var) (m:mode) (u:term) (*r Fill destination with function *)
 | term_FillC (t:term) (u:term) (*r Fill destination with root of ampar $(u:term)$ *)
with val : Type :=  (*r Term value *)
 | val_H (h:hdn) (*r Hole *)
 | val_D (h:hdn) (*r Destination *)
 | val_U : val (*r Unit *)
 | val_F (x:var) (m:mode) (t:term) (*r Lambda abstraction *)
 | val_L (v:val) (*r Left variant for sum *)
 | val_R (v:val) (*r Right variant for sum *)
 | val_E (m:mode) (v:val) (*r Exponential *)
 | val_P (v1:val) (v2:val) (*r Product *)
 | val_A (H:hdns) (v1:val) (v2:val) (*r Ampar *).

Inductive tyb_var : Type := 
 | tyb_Var (m:mode) (T:type).

Inductive tyb_dest : Type := 
 | tyb_Dest (m:mode) (T:type) (n:mode).

Inductive tyb_hole : Type := 
 | tyb_Hole (T:type) (n:mode).

Inductive ectx : Type :=  (*r Evaluation context component *)
 | ectx_AppFoc1 (u:term) (*r Application *)
 | ectx_AppFoc2 (v:val) (*r Application *)
 | ectx_PatUFoc (u:term) (*r Pattern-match on unit *)
 | ectx_PatSFoc (m:mode) (x1:var) (u1:term) (x2:var) (u2:term) (*r Pattern-match on sum *)
 | ectx_PatPFoc (m:mode) (x1:var) (x2:var) (u:term) (*r Pattern-match on product *)
 | ectx_PatEFoc (m:mode) (n:mode) (x:var) (u:term) (*r Pattern-match on exponential *)
 | ectx_MapFoc (x:var) (u:term) (*r Map over the right side of ampar *)
 | ectx_ToAFoc : ectx (*r Wrap into a trivial ampar *)
 | ectx_FromAFoc : ectx (*r Extract value from trivial ampar *)
 | ectx_FillUFoc : ectx (*r Fill destination with unit *)
 | ectx_FillLFoc : ectx (*r Fill destination with left variant *)
 | ectx_FillRFoc : ectx (*r Fill destination with right variant *)
 | ectx_FillEFoc (m:mode) (*r Fill destination with exponential constructor *)
 | ectx_FillPFoc : ectx (*r Fill destination with product constructor *)
 | ectx_FillFFoc (x:var) (m:mode) (u:term) (*r Fill destination with function *)
 | ectx_FillCFoc1 (u:term) (*r Fill destination with root of ampar *)
 | ectx_FillCFoc2 (v:val) (*r Fill destination with root of ampar *)
 | ectx_AOpenFoc (H:hdns) (v1:val) (*r Open ampar. \textcolor{red}{Only new addition to term shapes} *).

Definition map_var : Type := (NmapM.t tyb_var).

Definition map_dest : Type := (NmapM.t tyb_dest).

Definition map_hole : Type := (NmapM.t tyb_hole).

Definition bndr_hole : Type := (hdn * tyb_hole).

Definition bndr_dest : Type := (hdn * tyb_dest).

Definition bndr_var : Type := (var * tyb_var).

Definition ectxs : Type := (list ectx).

Inductive ctx : Type :=  (*r Typing context *)
 | ctx_Maps (mvar:map_var) (mdest:map_dest) (mhole:map_hole) (*r Actual representation of contexts for Coq proofs (cannot hide) *).

Inductive bndr : Type := 
 | bndr_Var (bndr_var5:bndr_var)
 | bndr_Dest (bndr_dest5:bndr_dest)
 | bndr_Hole (bndr_hole5:bndr_hole).
Lemma eq_type: forall (x y : type), {x = y} + {x <> y}.
Proof.
decide equality. apply mode_eq_dec. apply mode_eq_dec. apply mode_eq_dec.
Defined.
Hint Resolve eq_type : ott_coq_equality.
(******************************************************************************
 * NAMES
 *****************************************************************************)

Fixpoint hdns_from_list (l : list nat) : HdnsM.t :=
  match l with
  | nil => HdnsM.empty
  | h :: t => HdnsM.add h (hdns_from_list t)
  end.

Definition hdns_max_hnames (H : HdnsM.t) : nat :=
  HdnsM.fold (fun k acc => max k acc) H 0.

Definition hdns_incr_hnames (H : HdnsM.t) (h' : nat) : HdnsM.t :=
  HdnsM.fold (fun h acc => HdnsM.add (h + h') acc) H HdnsM.empty.

Definition hdns_from_ctx (G : ctx) : HdnsM.t. Admitted. (* TODO complete *)

Definition hdns_from_ectxs (C : ectxs) : HdnsM.t. Admitted. (* TODO complete *)

Definition hdns_Disjoint (H1 H2 : HdnsM.t) : Prop :=
  HdnsM.Empty (HdnsM.inter H1 H2).

(******************************************************************************
 * TERMS STATIC BEHAVIOUR
 *****************************************************************************)

(******************************************************************************
 * TERMS DYNAMIC BEHAVIOUR
 *****************************************************************************)

Definition term_sub (t: term) (x:var) (v:val) : term. Admitted. (* TODO complete *)
Definition ectxs_fill (C: ectxs) (h:hdn) (v:val) : ectxs. Admitted. (* TODO complete *)
Definition val_incr_hnames (v : val) (h : hdn) : val. Admitted. (* TODO complete *)

Definition term_NotVal (t: term) : Prop. Admitted. (* put it to Type instead for shape info? *) (* TODO complete *)

(******************************************************************************
 * TYPE
 *****************************************************************************)

(* Alias to the one defined by Ott *)
Definition type_eq_dec : forall (T1 T2: type), {T1 = T2} + {T1 <> T2} := eq_type.

(******************************************************************************
 * MULTIPLICITY
 *****************************************************************************)

Definition mul_plus (p1 p2: _mul) : _mul := Ur.
Definition mul_times (p1 p2: _mul) : _mul :=
  match p1, p2 with
  | Lin, Lin => Lin
  | _, _ => Ur
  end.
Definition mul_times' (pl: list _mul) : _mul :=
  List.fold_right mul_times Lin pl.
Inductive mul_IsSubtype : _mul -> _mul -> Prop :=
  | mul_IsSubtypeProofEq : forall (p : _mul), mul_IsSubtype p p
  | mul_IsSubtypeProofUr : forall (p2 : _mul), mul_IsSubtype Ur p2.
Theorem mul_IsSubtype_dec : forall (p1 p2: _mul), {mul_IsSubtype p1 p2} + {~mul_IsSubtype p1 p2}.
Proof.
  intros p1 p2. destruct p1, p2.
  - left. exact (mul_IsSubtypeProofEq Lin).
  - right. intros contra. inversion contra.
  - left. exact (mul_IsSubtypeProofUr Lin).
  - left. exact (mul_IsSubtypeProofEq Ur).
Defined.

(******************************************************************************
 * AGE
 *****************************************************************************)

Definition age_times (a1 a2 : age) : age := ext_plus a1 a2.
Definition age_times' (al: list age) : age := ext_plus' al.
Inductive age_IsSubtype : age -> age -> Prop :=
  | age_IsSubtypeProofEq : forall (a : age), age_IsSubtype a a
  | age_IsSubtypeProofInf : forall (a2 : age), age_IsSubtype Inf a2.
Theorem age_IsSubtype_dec : forall (a1 a2: age), {age_IsSubtype a1 a2} + {~(age_IsSubtype a1 a2)}.
Proof.
  intros a1 a2. destruct a1, a2.
  - assert ({n = n0} + {n <> n0}) by apply Nat.eq_dec. destruct H.
    * rewrite e. left. exact (age_IsSubtypeProofEq (Fin n0)).
    * right. intros contra. inversion contra. congruence.
  - right. intros contra. inversion contra.
  - left. exact (age_IsSubtypeProofInf (Fin n)).
  - left. exact (age_IsSubtypeProofEq Inf).
Defined.

(******************************************************************************
 * MODE
 *****************************************************************************)

Definition mode_plus (m1 m2: mode) : mode :=
  match m1, m2 with
  | None, _ => None
  | _, None => None
  | Some (p1, a1), Some (p2, a2) => match a1, a2 with
    | _, Inf => Some (mul_plus p1 p2, Inf)
    | Inf, _ => Some (mul_plus p1 p2, Inf)
    | _, _ => match a1, a2 with
      | Fin n1, Fin n2 => match Nat.eq_dec n1 n2 with
        | left _ => (* true *) Some (mul_plus p1 p2, Fin n1)
        | right _ => (* false *) None
        end
      | Inf, Inf => Some (mul_plus p1 p2, Inf)
      | _, _ => None
      end
    end
  end.
Definition mode_times (m1 m2: mode) : mode :=
  match m1, m2 with
  | None, _ => None
  | _, None => None
  | Some (p1, a1), Some (p2, a2) => Some (mul_times p1 p2, age_times a1 a2)
  end.
Definition mode_times' (ml: list mode) : mode :=
  List.fold_right mode_times (Some (Lin, Fin 0)) ml.
Inductive mode_IsSubtype : mode -> mode -> Prop :=
  | mode_IsSubtypeProofNone : forall (m2 : mode), mode_IsSubtype None m2 (* skull represents contradictory requirements, so we must never be able to provide a value with multiplicity skull *)
  | mode_IsSubtypeProofPair : forall (p1 p2 : _mul) (a1 a2 : age), mul_IsSubtype p1 p2 -> age_IsSubtype a1 a2 -> mode_IsSubtype (Some (p1, a1)) (Some (p2, a2)).
Theorem mode_IsSubtype_dec : forall (m1 m2: mode), {mode_IsSubtype m1 m2} + {~mode_IsSubtype m1 m2}.
Proof.
  intros m1 m2. destruct m1 as [(p1 & a1)|], m2 as [(p2 & a2)|].
  - destruct (mul_IsSubtype_dec p1 p2), (age_IsSubtype_dec a1 a2).
    + left. exact (mode_IsSubtypeProofPair p1 p2 a1 a2 m a).
    + right. intros contra. inversion contra. congruence.
    + right. intros contra. inversion contra. congruence.
    + right. intros contra. inversion contra. congruence.
  - right. intros contra. inversion contra.
  - left. exact (mode_IsSubtypeProofNone (Some (p2, a2))).
  - left. exact (mode_IsSubtypeProofNone None).
Defined.
Inductive mode_IsValid : mode -> Prop :=
  mode_IsValidProof : forall (pa : mul * age), mode_IsValid (Some pa).
Theorem mode_IsValid_dec : forall (m : mode), {mode_IsValid m} + {~mode_IsValid m}.
Proof.
  intros m. destruct m as [pa|].
  - left. exact (mode_IsValidProof pa).
  - right. intros contra. inversion contra.
Qed.
Inductive mode_IsLin : mode -> Prop :=
  mode_IsLinProof : forall (a : age), mode_IsLin (Some (Lin, a)).
Theorem mode_IsLin_dec : forall (m : mode), {mode_IsLin m} + {~mode_IsLin m}.
Proof.
  intros m. destruct m as [pa|].
  - destruct pa as [p a]. destruct p.
    + left. exact (mode_IsLinProof a).
    + right. intros contra. inversion contra.
  - right. intros contra. inversion contra.
Qed.
Inductive mode_IsUr : mode -> Prop :=
  mode_IsUrProof : forall (a : age), mode_IsUr (Some (Ur, a)).
Theorem mode_IsUr_dec : forall (m : mode), {mode_IsUr m} + {~mode_IsUr m}.
Proof.
  intros m. destruct m as [pa|].
  - destruct pa as [p a]. destruct p.
    + right. intros contra. inversion contra.
    + left. exact (mode_IsUrProof a).
  - right. intros contra. inversion contra.
Qed.

(******************************************************************************
 * BINDERS
 *****************************************************************************)

(******************************************************************************
 * NMAPS
 *****************************************************************************)

Definition nmap_from_pair {A: Type} (p: nat * A) : NmapM.t A :=
  NmapM.add (fst p) (snd p) (NmapM.empty A).

(******************************************************************************
 * CONTEXTS
 *****************************************************************************)

(******************************************************************************
 * CONTEXTS
 *****************************************************************************)

Definition ctx_DestOnly (G : ctx) : Prop. Admitted. (* TODO complete *)
Definition ctx_LinOnly (G : ctx) : Prop. Admitted. (* TODO complete *)
Definition ctx_IsValid (G: ctx) : Prop. Admitted. (* TODO complete *)
Definition ctx_Disjoint (G1 G2 : ctx) : Prop. Admitted. (* TODO complete *)
Definition ctx_Compatible (G: ctx) (b: bndr) : Prop. Admitted. (* TODO complete *)
Definition ctx_union (G1 G2 : ctx) : ctx. Admitted. (* TODO complete *)
Definition ctx_stimes (m1 : mode) (G : ctx) : ctx. Admitted. (* TODO complete *)
Definition ctx_minus (G : ctx) : ctx. Admitted. (* TODO complete *)

(*****************************************************************************)


Inductive pred : Type :=  (*r Serves for the .mng file. Isn't used in the actual rules *)
 | _ctx_DestOnly (G:ctx)
 | _ctx_LinOnly (G:ctx)
 | _ctx_IsValid (G:ctx)
 | _ctx_Compatible (G:ctx) (b:bndr)
 | _ctx_Disjoint (G1:ctx) (G2:ctx)
 | _mode_IsValid (m:mode)
 | _mode_IsLin (m:mode)
 | _mode_IsUr (m:mode)
 | _term_NotVal (t:term)
 | _TyR_val (G:ctx) (v:val) (T:type)
 | _Ty_term (P:ctx) (t:term) (T:type)
 | _Ty_ectxs (D:ctx) (C:ectxs) (T1:type) (T2:type) (*r Typing of evaluation contexts *)
 | _Ty_eterm (C:ectxs) (t:term) (T:type)
 | _Sem_eterm (C:ectxs) (t:term) (C':ectxs) (t':term).
(** definitions *)

(* defns Ty *)
Inductive TyR_val : ctx -> val -> type -> Prop :=    (* defn TyR_val *)
 | TyR_val_H : forall (h:hdn) (T:type),
     TyR_val  (ctx_Maps (NmapM.empty tyb_var) (NmapM.empty tyb_dest) (nmap_from_pair   (pair  h  (tyb_Hole  T    (Some (pair   Lin     (Fin 0)  ))  ))  ))  (val_H h) T
 | TyR_val_D : forall (G:ctx) (h:hdn) (T:type) (n:mode)
     (CompatGh: ctx_Compatible G (bndr_Dest  (pair  h  (tyb_Dest   (Some (pair   Lin     (Fin 0)  ))    T   n )) ) ),
     TyR_val G (val_D h) (type_D T n)
 | TyR_val_U : 
     TyR_val  (ctx_Maps (NmapM.empty tyb_var) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  val_U type_U
 | TyR_val_F : forall (D:ctx) (x:var) (m:mode) (t:term) (T1 T2:type)
     (Tyt: Ty_term  (ctx_union  D    (ctx_Maps (nmap_from_pair   (pair  x  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  t T2),
     ctx_DestOnly D  ->
     TyR_val D (val_F x m t) (type_F T1 m T2)
 | TyR_val_L : forall (G:ctx) (v:val) (T1 T2:type)
     (TyRv: TyR_val G v T1),
     TyR_val G (val_L v) (type_S T1 T2)
 | TyR_val_R : forall (G:ctx) (v:val) (T1 T2:type)
     (TyRv: TyR_val G v T2),
     TyR_val G (val_R v) (type_S T1 T2)
 | TyR_val_P : forall (G1 G2:ctx) (v1 v2:val) (T1 T2:type)
     (TyRv1: TyR_val G1 v1 T1)
     (TyRv2: TyR_val G2 v2 T2),
     TyR_val  (ctx_union  G1   G2 )  (val_P v1 v2) (type_P T1 T2)
 | TyR_val_E : forall (n:mode) (G:ctx) (v:val) (T:type)
     (TyRv: TyR_val G v T),
     TyR_val  (ctx_stimes  n   G )  (val_E n v) (type_E n T)
 | TyR_val_A : forall (D1 D2 D3:ctx) (v1 v2:val) (T1 T2:type)
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (DestOnlyD3: ctx_DestOnly D3 )
     (LinOnlyD3: ctx_LinOnly D3 )
     (ValidD3: ctx_IsValid D3 )
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DisjointD1D3: ctx_Disjoint D1 D3 )
     (DisjointD2D3: ctx_Disjoint D2 D3 )
     (TyRv1: TyR_val  (ctx_union  D1     (ctx_minus  D3 )   )  v1 T1)
     (TyRv2: TyR_val  (ctx_union  D2   D3 )  v2 T2),
     TyR_val  (ctx_union  D1   D2 )  (val_A  (hdns_from_ctx   (ctx_minus  D3 )  )  v1 v2) (type_A T1 T2)
with Ty_term : ctx -> term -> type -> Prop :=    (* defn Ty_term *)
 | Ty_term_Val : forall (D:ctx) (v:val) (T:type),
     ctx_DestOnly D  ->
     TyR_val D v T ->
     Ty_term D (term_Val v) T
 | Ty_term_Var : forall (P:ctx) (x:var) (T:type)
     (CompatPx: ctx_Compatible P (bndr_Var  (pair  x  (tyb_Var   (Some (pair   Lin     (Fin 0)  ))    T )) ) ),
     Ty_term P (term_Var x) T
 | Ty_term_App : forall (m:mode) (P1 P2:ctx) (t u:term) (T2 T1:type)
     (Tyt: Ty_term P1 t T1)
     (Tyu: Ty_term P2 u (type_F T1 m T2)),
     Ty_term  (ctx_union   (ctx_stimes  m   P1 )    P2 )  (term_App t u) T2
 | Ty_term_PatU : forall (P1 P2:ctx) (t u:term) (U:type)
     (Tyt: Ty_term P1 t type_U)
     (Tyu: Ty_term P2 u U),
     Ty_term  (ctx_union  P1   P2 )  (term_PatU t u) U
 | Ty_term_PatS : forall (m:mode) (P1 P2:ctx) (t:term) (x1:var) (u1:term) (x2:var) (u2:term) (U T1 T2:type)
     (DisjointP2x1: ctx_Disjoint P2  (ctx_Maps (nmap_from_pair   (pair  x1  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )
     (DisjointP2x2: ctx_Disjoint P2  (ctx_Maps (nmap_from_pair   (pair  x2  (tyb_Var  m   T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )
     (Tyt: Ty_term P1 t (type_S T1 T2))
     (Tyu1: Ty_term  (ctx_union  P2    (ctx_Maps (nmap_from_pair   (pair  x1  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u1 U)
     (Tyu2: Ty_term  (ctx_union  P2    (ctx_Maps (nmap_from_pair   (pair  x2  (tyb_Var  m   T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u2 U),
     Ty_term  (ctx_union   (ctx_stimes  m   P1 )    P2 )  (term_PatS t m x1 u1 x2 u2) U
 | Ty_term_PatP : forall (m:mode) (P1 P2:ctx) (t:term) (x1 x2:var) (u:term) (U T1 T2:type)
     (DisjointP2x1: ctx_Disjoint P2  (ctx_Maps (nmap_from_pair   (pair  x1  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )
     (DisjointP2x2: ctx_Disjoint P2  (ctx_Maps (nmap_from_pair   (pair  x2  (tyb_Var  m   T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )
     (Disjointx1x2: ctx_Disjoint  (ctx_Maps (nmap_from_pair   (pair  x1  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))   (ctx_Maps (nmap_from_pair   (pair  x2  (tyb_Var  m   T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )
     (Tyt: Ty_term P1 t (type_P T1 T2))
     (Tyu: Ty_term  (ctx_union   (ctx_union  P2    (ctx_Maps (nmap_from_pair   (pair  x1  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )     (ctx_Maps (nmap_from_pair   (pair  x2  (tyb_Var  m   T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u U),
     Ty_term  (ctx_union   (ctx_stimes  m   P1 )    P2 )  (term_PatP t m x1 x2 u) U
 | Ty_term_PatE : forall (m:mode) (P1 P2:ctx) (t:term) (n:mode) (x:var) (u:term) (U T:type)
     (DisjointP2x: ctx_Disjoint P2  (ctx_Maps (nmap_from_pair   (pair  x  (tyb_Var   (mode_times'  ((app (cons m nil) (app (cons n nil) nil))) )    T ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )
     (Tyt: Ty_term P1 t (type_E n T))
     (Tyu: Ty_term  (ctx_union  P2    (ctx_Maps (nmap_from_pair   (pair  x  (tyb_Var   (mode_times'  ((app (cons m nil) (app (cons n nil) nil))) )    T ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u U),
     Ty_term  (ctx_union   (ctx_stimes  m   P1 )    P2 )  (term_PatE t m n x u) U
 | Ty_term_Map : forall (P1 P2:ctx) (t:term) (x:var) (u:term) (T1 U T2:type)
     (DisjointP2x: ctx_Disjoint P2  (ctx_Maps (nmap_from_pair   (pair  x  (tyb_Var   (Some (pair   Lin     (Fin 0)  ))    T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )
     (Tyt: Ty_term P1 t (type_A T1 T2))
     (Tyu: Ty_term  (ctx_union   (ctx_stimes   (Some (pair   Lin     (Fin 1)  ))    P2 )     (ctx_Maps (nmap_from_pair   (pair  x  (tyb_Var   (Some (pair   Lin     (Fin 0)  ))    T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u U),
     Ty_term  (ctx_union  P1   P2 )  (term_Map t x u) (type_A T1 U)
 | Ty_term_ToA : forall (P:ctx) (t:term) (T:type)
     (Tyt: Ty_term P t T),
     Ty_term P (term_ToA t) (type_A T type_U)
 | Ty_term_FromA : forall (P:ctx) (t:term) (T:type)
     (Tyt: Ty_term P t (type_A T type_U)),
     Ty_term P (term_FromA t) T
 | Ty_term_Alloc : forall (T:type),
     Ty_term  (ctx_Maps (NmapM.empty tyb_var) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  term_Alloc (type_A T (type_D T  (Some (pair   Lin     (Fin 0)  )) ))
 | Ty_term_FillU : forall (P:ctx) (t:term) (n:mode)
     (Tyt: Ty_term P t (type_D type_U n)),
     Ty_term P (term_FillU t) type_U
 | Ty_term_FillL : forall (P:ctx) (t:term) (T1:type) (n:mode) (T2:type)
     (Tyt: Ty_term P t (type_D (type_S T1 T2) n)),
     Ty_term P (term_FillL t) (type_D T1 n)
 | Ty_term_FillR : forall (P:ctx) (t:term) (T2:type) (n:mode) (T1:type)
     (Tyt: Ty_term P t (type_D (type_S T1 T2) n)),
     Ty_term P (term_FillR t) (type_D T2 n)
 | Ty_term_FillP : forall (P:ctx) (t:term) (T1:type) (n:mode) (T2:type)
     (Tyt: Ty_term P t (type_D (type_P T1 T2) n)),
     Ty_term P (term_FillP t) (type_P (type_D T1 n) (type_D T2 n))
 | Ty_term_FillE : forall (P:ctx) (t:term) (n':mode) (T:type) (n:mode)
     (Tyt: Ty_term P t (type_D (type_E n' T) n)),
     Ty_term P (term_FillE t n') (type_D T  (mode_times'  ((app (cons n' nil) (app (cons n nil) nil))) ) )
 | Ty_term_FillF : forall (P1:ctx) (n:mode) (P2:ctx) (t:term) (x:var) (m:mode) (u:term) (T1 T2:type)
     (DisjointP2x: ctx_Disjoint P2  (ctx_Maps (nmap_from_pair   (pair  x  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )
     (Tyt: Ty_term P1 t (type_D (type_F T1 m T2) n))
     (Tyu: Ty_term  (ctx_union  P2    (ctx_Maps (nmap_from_pair   (pair  x  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u T2),
     Ty_term  (ctx_union  P1    (ctx_stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     P2 )  )  (term_FillF t x m u) type_U
 | Ty_term_FillC : forall (P1:ctx) (n:mode) (P2:ctx) (t u:term) (T2 T1:type)
     (Tyt: Ty_term P1 t (type_D T1 n))
     (Tyu: Ty_term P2 u (type_A T1 T2)),
     Ty_term  (ctx_union  P1    (ctx_stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     P2 )  )  (term_FillC t u) T2
with Ty_ectxs : ctx -> ectxs -> type -> type -> Prop :=    (* defn Ty_ectxs *)
 | Ty_ectxs_Id : forall (U0:type),
     Ty_ectxs  (ctx_Maps (NmapM.empty tyb_var) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))   nil  U0 U0
 | Ty_ectxs_AppFoc1 : forall (D1:ctx) (C:ectxs) (u:term) (T1 U0:type) (D2:ctx) (m:mode) (T2:type)
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (Validm: mode_IsValid m )
     (ValidD2: ctx_IsValid D2 )
     (TyC: Ty_ectxs  (ctx_union   (ctx_stimes  m   D1 )    D2 )  C T2 U0)
     (Tyu: Ty_term D2 u (type_F T1 m T2)),
     Ty_ectxs D1  (cons   (ectx_AppFoc1 u)    C )  T1 U0
 | Ty_ectxs_AppFoc2 : forall (D2:ctx) (C:ectxs) (v:val) (T1:type) (m:mode) (T2 U0:type) (D1:ctx)
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (ValidmD1: ctx_IsValid  (ctx_stimes  m   D1 )  )
     (TyC: Ty_ectxs  (ctx_union   (ctx_stimes  m   D1 )    D2 )  C T2 U0)
     (Tyv: Ty_term D1 (term_Val v) T1),
     Ty_ectxs D2  (cons   (ectx_AppFoc2 v)    C )   (type_F T1 m T2)  U0
 | Ty_ectxs_PatUFoc : forall (D1:ctx) (C:ectxs) (u:term) (U0:type) (D2:ctx) (U:type)
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (ValidD2: ctx_IsValid D2 )
     (TyC: Ty_ectxs  (ctx_union  D1   D2 )  C U U0)
     (Tyu: Ty_term D2 u U),
     Ty_ectxs D1  (cons   (ectx_PatUFoc u)    C )  type_U U0
 | Ty_ectxs_PatSFoc : forall (D1:ctx) (C:ectxs) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term) (T1 T2 U0:type) (D2:ctx) (U:type)
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (Validm: mode_IsValid m )
     (ValidD2: ctx_IsValid D2 )
     (TyC: Ty_ectxs  (ctx_union   (ctx_stimes  m   D1 )    D2 )  C U U0)
     (Tyu1: Ty_term  (ctx_union  D2    (ctx_Maps (nmap_from_pair   (pair  x1  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u1 U)
     (Tyu2: Ty_term  (ctx_union  D2    (ctx_Maps (nmap_from_pair   (pair  x2  (tyb_Var  m   T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u2 U),
     Ty_ectxs D1  (cons   (ectx_PatSFoc m x1 u1 x2 u2)    C )   (type_S T1 T2)  U0
 | Ty_ectxs_PatPFoc : forall (D1:ctx) (C:ectxs) (m:mode) (x1 x2:var) (u:term) (T1 T2 U0:type) (D2:ctx) (U:type)
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (Disjointx1x2: ctx_Disjoint  (ctx_Maps (nmap_from_pair   (pair  x1  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))   (ctx_Maps (nmap_from_pair   (pair  x2  (tyb_Var  m   T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )
     (Validm: mode_IsValid m )
     (ValidD2: ctx_IsValid D2 )
     (TyC: Ty_ectxs  (ctx_union   (ctx_stimes  m   D1 )    D2 )  C U U0)
     (Tyu: Ty_term  (ctx_union   (ctx_union  D2    (ctx_Maps (nmap_from_pair   (pair  x1  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )     (ctx_Maps (nmap_from_pair   (pair  x2  (tyb_Var  m   T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u U),
     Ty_ectxs D1  (cons   (ectx_PatPFoc m x1 x2 u)    C )   (type_P T1 T2)  U0
 | Ty_ectxs_PatEFoc : forall (D1:ctx) (C:ectxs) (m m':mode) (x:var) (u:term) (T U0:type) (D2:ctx) (U:type)
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (Validm: mode_IsValid m )
     (ValidD2: ctx_IsValid D2 )
     (TyC: Ty_ectxs  (ctx_union   (ctx_stimes  m   D1 )    D2 )  C U U0)
     (Tyu: Ty_term  (ctx_union  D2    (ctx_Maps (nmap_from_pair   (pair  x  (tyb_Var   (mode_times'  ((app (cons m nil) (app (cons m' nil) nil))) )    T ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u U),
     Ty_ectxs D1  (cons   (ectx_PatEFoc m m' x u)    C )  (type_E m' T) U0
 | Ty_ectxs_MapFoc : forall (D1:ctx) (C:ectxs) (x:var) (u:term) (T1 T2 U0:type) (D2:ctx) (U:type)
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (ValidD2: ctx_IsValid D2 )
     (TyC: Ty_ectxs  (ctx_union  D1   D2 )  C U U0)
     (Tyu: Ty_term  (ctx_union   (ctx_stimes   (Some (pair   Lin     (Fin 1)  ))    D2 )     (ctx_Maps (nmap_from_pair   (pair  x  (tyb_Var   (Some (pair   Lin     (Fin 0)  ))    T2 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u U),
     Ty_ectxs D1  (cons   (ectx_MapFoc x u)    C )   (type_A T1 T2)  U0
 | Ty_ectxs_ToAFoc : forall (D:ctx) (C:ectxs) (T U0:type)
     (TyC: Ty_ectxs D C  (type_A T type_U)  U0),
     Ty_ectxs D  (cons   ectx_ToAFoc    C )  T U0
 | Ty_ectxs_FromAFoc : forall (D:ctx) (C:ectxs) (T U0:type)
     (TyC: Ty_ectxs D C T U0),
     Ty_ectxs D  (cons   ectx_FromAFoc    C )   (type_A T type_U)  U0
 | Ty_ectxs_FillUFoc : forall (D:ctx) (C:ectxs) (n:mode) (U0:type)
     (TyC: Ty_ectxs D C type_U U0),
     Ty_ectxs D  (cons   ectx_FillUFoc    C )  (type_D type_U n) U0
 | Ty_ectxs_FillLFoc : forall (D:ctx) (C:ectxs) (T1 T2:type) (n:mode) (U0:type)
     (TyC: Ty_ectxs D C (type_D T1 n) U0),
     Ty_ectxs D  (cons   ectx_FillLFoc    C )  (type_D (type_S T1 T2) n) U0
 | Ty_ectxs_FillRFoc : forall (D:ctx) (C:ectxs) (T1 T2:type) (n:mode) (U0:type)
     (TyC: Ty_ectxs D C (type_D T2 n) U0),
     Ty_ectxs D  (cons   ectx_FillRFoc    C )  (type_D (type_S T1 T2) n) U0
 | Ty_ectxs_FillPFoc : forall (D:ctx) (C:ectxs) (T1 T2:type) (n:mode) (U0:type)
     (TyC: Ty_ectxs D C  (type_P (type_D T1 n) (type_D T2 n))  U0),
     Ty_ectxs D  (cons   ectx_FillPFoc    C )  (type_D (type_P T1 T2) n) U0
 | Ty_ectxs_FillEFoc : forall (D:ctx) (C:ectxs) (m:mode) (T:type) (n:mode) (U0:type)
     (TyC: Ty_ectxs D C (type_D T  (mode_times'  ((app (cons m nil) (app (cons n nil) nil))) ) ) U0),
     Ty_ectxs D  (cons   (ectx_FillEFoc m)    C )  (type_D (type_E m T) n) U0
 | Ty_ectxs_FillFFoc : forall (D1:ctx) (C:ectxs) (x:var) (m:mode) (u:term) (T1 T2:type) (n:mode) (U0:type) (D2:ctx)
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (ValidsnD2: ctx_IsValid  (ctx_stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     D2 )  )
     (TyC: Ty_ectxs  (ctx_union  D1    (ctx_stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     D2 )  )  C type_U U0)
     (Tyu: Ty_term  (ctx_union  D2    (ctx_Maps (nmap_from_pair   (pair  x  (tyb_Var  m   T1 ))  ) (NmapM.empty tyb_dest) (NmapM.empty tyb_hole))  )  u T2),
     Ty_ectxs D1  (cons   (ectx_FillFFoc x m u)    C )  (type_D (type_F T1 m T2) n) U0
 | Ty_ectxs_FillCFoc1 : forall (D1:ctx) (C:ectxs) (u:term) (T1:type) (n:mode) (U0:type) (D2:ctx) (T2:type)
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (ValidsnD2: ctx_IsValid  (ctx_stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     D2 )  )
     (TyC: Ty_ectxs  (ctx_union  D1    (ctx_stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     D2 )  )  C T2 U0)
     (Tyu: Ty_term D2 u (type_A T1 T2)),
     Ty_ectxs D1  (cons   (ectx_FillCFoc1 u)    C )  (type_D T1 n) U0
 | Ty_ectxs_FillCFoc2 : forall (D2:ctx) (C:ectxs) (v:val) (T1 T2 U0:type) (D1:ctx) (n:mode)
     (DisjointD1D2: ctx_Disjoint D1 D2 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (ValidsnD1: ctx_IsValid D1 )
     (Validsn: mode_IsValid   (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )   )
     (TyC: Ty_ectxs  (ctx_union  D1    (ctx_stimes    (mode_times'  ((app (cons  (Some (pair   Lin     (Fin 1)  ))  nil) (app (cons n nil) nil))) )     D2 )  )  C T2 U0)
     (Tyu: Ty_term D1 (term_Val v) (type_D T1 n)),
     Ty_ectxs D2  (cons   (ectx_FillCFoc2 v)    C )  (type_A T1 T2) U0
 | Ty_ectxs_AOpenFoc : forall (D2 D3:ctx) (C:ectxs) (v1:val) (U U0:type) (D1:ctx) (T1:type)
     (DisjoinD1D2: ctx_Disjoint D1 D2 )
     (DisjoinD1D3: ctx_Disjoint D1 D3 )
     (DestOnlyD1: ctx_DestOnly D1 )
     (DestOnlyD2: ctx_DestOnly D2 )
     (DestOnlyD3: ctx_DestOnly D3 )
     (LinOnlyD3: ctx_LinOnly D3 )
     (ValidD1: ctx_IsValid D1 )
     (TyC: Ty_ectxs  (ctx_union  D1   D2 )  C  (type_A T1 U)  U0)
     (TyRv1: TyR_val  (ctx_union  D1    (ctx_minus  D3 )  )  v1 T1),
     hdns_Disjoint  (hdns_from_ectxs  C )   (hdns_from_ctx   (ctx_minus  D3 )  )   ->
     Ty_ectxs  (ctx_union   (ctx_stimes   (Some (pair   Lin     (Fin 1)  ))    D2 )    D3 )   (cons   (ectx_AOpenFoc  (hdns_from_ctx   (ctx_minus  D3 )  )  v1)    C )  U U0
with Ty_eterm : ectxs -> term -> type -> Prop :=    (* defn Ty_eterm *)
 | Ty_eterm_ClosedEterm : forall (C:ectxs) (t:term) (U0:type) (D:ctx) (T:type)
     (ValidD: ctx_IsValid D )
     (DestOnlyD: ctx_DestOnly D )
     (TyC: Ty_ectxs D C T U0)
     (Tyt: Ty_term D t T),
     Ty_eterm C t U0.
(** definitions *)

(* defns Sem *)
Inductive Sem_eterm : ectxs -> term -> ectxs -> term -> Prop :=    (* defn Sem_eterm *)
 | Sem_eterm_AppFoc1 : forall (C:ectxs) (t u:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_App t u)   (cons   (ectx_AppFoc1 u)    C )   t
 | Sem_eterm_AppUnfoc1 : forall (C:ectxs) (u:term) (v:val),
     Sem_eterm   (cons   (ectx_AppFoc1 u)    C )   (term_Val v) C (term_App (term_Val v) u)
 | Sem_eterm_AppFoc2 : forall (C:ectxs) (v:val) (u:term)
     (NotValt: term_NotVal u ),
     Sem_eterm C (term_App (term_Val v) u)   (cons   (ectx_AppFoc2 v)    C )   u
 | Sem_eterm_AppUnfoc2 : forall (C:ectxs) (v v':val),
     Sem_eterm   (cons   (ectx_AppFoc2 v)    C )   (term_Val v') C (term_App (term_Val v) (term_Val v'))
 | Sem_eterm_AppRed : forall (C:ectxs) (v:val) (x:var) (m:mode) (t:term),
     Sem_eterm C (term_App (term_Val v) (term_Val  (val_F x m t) )) C  (term_sub  t   x   v ) 
 | Sem_eterm_PatUFoc : forall (C:ectxs) (t u:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_PatU t u)   (cons   (ectx_PatUFoc u)    C )   t
 | Sem_eterm_PatUUnfoc : forall (C:ectxs) (u:term) (v:val),
     Sem_eterm   (cons   (ectx_PatUFoc u)    C )   (term_Val v) C (term_PatU (term_Val v) u)
 | Sem_eterm_PatURed : forall (C:ectxs) (u:term),
     Sem_eterm C (term_PatU (term_Val val_U) u) C u
 | Sem_eterm_PatLFoc : forall (C:ectxs) (t:term) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_PatS t m x1 u1 x2 u2)   (cons   (ectx_PatSFoc m x1 u1 x2 u2)    C )   t
 | Sem_eterm_PatLUnfoc : forall (C:ectxs) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term) (v:val),
     Sem_eterm   (cons   (ectx_PatSFoc m x1 u1 x2 u2)    C )   (term_Val v) C (term_PatS (term_Val v) m x1 u1 x2 u2)
 | Sem_eterm_PatLRed : forall (C:ectxs) (v:val) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term) (x:var),
     Sem_eterm C (term_PatS (term_Val  (val_L v) ) m x1 u1 x2 u2) C  (term_sub  u1   x   v ) 
 | Sem_eterm_PatRFoc : forall (C:ectxs) (t:term) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_PatS t m x1 u1 x2 u2)   (cons   (ectx_PatSFoc m x1 u1 x2 u2)    C )   t
 | Sem_eterm_PatRUnfoc : forall (C:ectxs) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term) (v:val),
     Sem_eterm   (cons   (ectx_PatSFoc m x1 u1 x2 u2)    C )   (term_Val v) C (term_PatS (term_Val v) m x1 u1 x2 u2)
 | Sem_eterm_PatRRed : forall (C:ectxs) (v:val) (m:mode) (x1:var) (u1:term) (x2:var) (u2:term) (x:var),
     Sem_eterm C (term_PatS (term_Val  (val_R v) ) m x1 u1 x2 u2) C  (term_sub  u2   x   v ) 
 | Sem_eterm_PatPFoc : forall (C:ectxs) (t:term) (m:mode) (x1 x2:var) (u:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_PatP t m x1 x2 u)   (cons   (ectx_PatPFoc m x1 x2 u)    C )   t
 | Sem_eterm_PatPUnfoc : forall (C:ectxs) (m:mode) (x1 x2:var) (u:term) (v:val),
     Sem_eterm   (cons   (ectx_PatPFoc m x1 x2 u)    C )   (term_Val v) C (term_PatP (term_Val v) m x1 x2 u)
 | Sem_eterm_PatPRed : forall (C:ectxs) (v1 v2:val) (m:mode) (x1 x2:var) (u:term),
     Sem_eterm C (term_PatP (term_Val (val_P v1 v2)) m x1 x2 u) C  (term_sub   (term_sub  u   x1   v1 )    x2   v2 ) 
 | Sem_eterm_PatEFoc : forall (C:ectxs) (t:term) (m n:mode) (x:var) (u:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_PatE t m n x u)   (cons   (ectx_PatEFoc m n x u)    C )   t
 | Sem_eterm_PatEUnfoc : forall (C:ectxs) (m n:mode) (x:var) (u:term) (v:val),
     Sem_eterm   (cons   (ectx_PatEFoc m n x u)    C )   (term_Val v) C (term_PatE (term_Val v) m n x u)
 | Sem_eterm_PatERed : forall (C:ectxs) (n:mode) (v:val) (m:mode) (x:var) (u:term),
     Sem_eterm C (term_PatE (term_Val (val_E n v)) m n x u) C  (term_sub  u   x   v ) 
 | Sem_eterm_MapFoc : forall (C:ectxs) (t:term) (x:var) (u:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_Map t x u)   (cons   (ectx_MapFoc x u)    C )   t
 | Sem_eterm_MapUnfoc : forall (C:ectxs) (x:var) (u:term) (v:val),
     Sem_eterm   (cons   (ectx_MapFoc x u)    C )   (term_Val v) C (term_Map (term_Val v) x u)
 | Sem_eterm_MapRedAOpenFoc : forall (C:ectxs) (H:hdns) (v1 v2:val) (x:var) (u:term) (h':hdn)
     (hpMaxC: h' =  (hdns_max_hnames   (hdns_from_ectxs  C )  )  ),
     Sem_eterm C (term_Map (term_Val (val_A H v1 v2)) x u)   (cons   (ectx_AOpenFoc  (hdns_incr_hnames  H   h' )   (val_incr_hnames  v1   h' ) )    C )    (term_sub  u   x    (val_incr_hnames  v2   h' )  ) 
 | Sem_eterm_AOpenUnfoc : forall (C:ectxs) (H:hdns) (v1 v2:val),
     Sem_eterm   (cons  (ectx_AOpenFoc H v1)   C )   (term_Val v2) C (term_Val (val_A H v1 v2))
 | Sem_eterm_AllocRed : forall (C:ectxs),
     Sem_eterm C term_Alloc C (term_Val (val_A  (hdns_from_list  (cons  1  nil) )  (val_D  1 ) (val_H  1 )))
 | Sem_eterm_ToAFoc : forall (C:ectxs) (t:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_ToA t)   (cons   ectx_ToAFoc    C )   t
 | Sem_eterm_ToAUnfoc : forall (C:ectxs) (v:val),
     Sem_eterm   (cons   ectx_ToAFoc    C )   (term_Val v) C (term_ToA (term_Val v))
 | Sem_eterm_ToARed : forall (C:ectxs) (v:val),
     Sem_eterm C (term_ToA (term_Val v)) C (term_Val (val_A  (hdns_from_list  nil )  v val_U))
 | Sem_eterm_FromAFoc : forall (C:ectxs) (t:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_FromA t)   (cons   ectx_FromAFoc    C )   t
 | Sem_eterm_FromAUnfoc : forall (C:ectxs) (v:val),
     Sem_eterm   (cons   ectx_FromAFoc    C )   (term_Val v) C (term_FromA (term_Val v))
 | Sem_eterm_FromARed : forall (C:ectxs) (v:val),
     Sem_eterm C (term_FromA (term_Val (val_A  (hdns_from_list  nil )  v val_U))) C (term_Val v)
 | Sem_eterm_FillUFoc : forall (C:ectxs) (t:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_FillU t)   (cons   ectx_FillUFoc    C )   t
 | Sem_eterm_FillUUnfoc : forall (C:ectxs) (v:val),
     Sem_eterm   (cons   ectx_FillUFoc    C )   (term_Val v) C (term_FillU (term_Val v))
 | Sem_eterm_FillURed : forall (C:ectxs) (h:hdn),
     Sem_eterm C (term_FillU (term_Val (val_D h)))  (ectxs_fill  C   h   val_U )  (term_Val val_U)
 | Sem_eterm_FillLFoc : forall (C:ectxs) (t:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_FillL t)   (cons   ectx_FillLFoc    C )   t
 | Sem_eterm_FillLUnfoc : forall (C:ectxs) (v:val),
     Sem_eterm   (cons   ectx_FillLFoc    C )   (term_Val v) C (term_FillL (term_Val v))
 | Sem_eterm_FillLRed : forall (C:ectxs) (h h':hdn)
     (hpMaxCh: h' =  (hdns_max_hnames   (HdnsM.union   (hdns_from_ectxs  C )     (hdns_from_list  (cons h nil) )  )  )  ),
     Sem_eterm C (term_FillL (term_Val (val_D h)))  (ectxs_fill  C   h   (val_L (val_H   ( h'  +   1  )  )) )  (term_Val (val_D   ( h'  +   1  )  ))
 | Sem_eterm_FillRFoc : forall (C:ectxs) (t:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_FillR t)   (cons   ectx_FillRFoc    C )   t
 | Sem_eterm_FillRUnfoc : forall (C:ectxs) (v:val),
     Sem_eterm   (cons   ectx_FillRFoc    C )   (term_Val v) C (term_FillR (term_Val v))
 | Sem_eterm_FillRRed : forall (C:ectxs) (h h':hdn)
     (hpMaxCh: h' =  (hdns_max_hnames   (HdnsM.union   (hdns_from_ectxs  C )     (hdns_from_list  (cons h nil) )  )  )  ),
     Sem_eterm C (term_FillR (term_Val (val_D h)))  (ectxs_fill  C   h   (val_R (val_H   ( h'  +   1  )  )) )  (term_Val (val_D   ( h'  +   1  )  ))
 | Sem_eterm_FillEFoc : forall (C:ectxs) (t:term) (m:mode)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_FillE t m)   (cons   (ectx_FillEFoc m)    C )   t
 | Sem_eterm_FillEUnfoc : forall (C:ectxs) (m:mode) (v:val),
     Sem_eterm   (cons   (ectx_FillEFoc m)    C )   (term_Val v) C (term_FillE (term_Val v) m)
 | Sem_eterm_FillERed : forall (C:ectxs) (h:hdn) (m:mode) (h':hdn)
     (hpMaxCh: h' =  (hdns_max_hnames   (HdnsM.union   (hdns_from_ectxs  C )     (hdns_from_list  (cons h nil) )  )  )  ),
     Sem_eterm C (term_FillE (term_Val (val_D h)) m)  (ectxs_fill  C   h   (val_E m (val_H   ( h'  +   1  )  )) )  (term_Val (val_D   ( h'  +   1  )  ))
 | Sem_eterm_FillPFoc : forall (C:ectxs) (t:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_FillP t)   (cons   ectx_FillPFoc    C )   t
 | Sem_eterm_FillPUnfoc : forall (C:ectxs) (v:val),
     Sem_eterm   (cons   ectx_FillPFoc    C )   (term_Val v) C (term_FillP (term_Val v))
 | Sem_eterm_FillPRed : forall (C:ectxs) (h h':hdn)
     (hpMaxCh: h' =  (hdns_max_hnames   (HdnsM.union   (hdns_from_ectxs  C )     (hdns_from_list  (cons h nil) )  )  )  ),
     Sem_eterm C (term_FillP (term_Val (val_D h)))  (ectxs_fill  C   h   (val_P (val_H   ( h'  +   1  )  ) (val_H   ( h'  +   2  )  )) )  (term_Val (val_P (val_D   ( h'  +   1  )  ) (val_D   ( h'  +   2  )  )))
 | Sem_eterm_FillFFoc : forall (C:ectxs) (t:term) (x:var) (m:mode) (u:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_FillF t x m u)   (cons   (ectx_FillFFoc x m u)    C )   t
 | Sem_eterm_FillFUnfoc : forall (C:ectxs) (x:var) (m:mode) (u:term) (v:val),
     Sem_eterm   (cons   (ectx_FillFFoc x m u)    C )   (term_Val v) C (term_FillF (term_Val v) x m u)
 | Sem_eterm_FillFRed : forall (C:ectxs) (h:hdn) (x:var) (m:mode) (u:term),
     Sem_eterm C (term_FillF (term_Val (val_D h)) x m u)  (ectxs_fill  C   h   (val_F x m u) )  (term_Val val_U)
 | Sem_eterm_FillCFoc1 : forall (C:ectxs) (t u:term)
     (NotValt: term_NotVal t ),
     Sem_eterm C (term_FillC t u)   (cons   (ectx_FillCFoc1 u)    C )   t
 | Sem_eterm_FillCUnfoc1 : forall (C:ectxs) (u:term) (v:val),
     Sem_eterm   (cons   (ectx_FillCFoc1 u)    C )   (term_Val v) C (term_FillC (term_Val v) u)
 | Sem_eterm_FillCFoc2 : forall (C:ectxs) (v:val) (u:term),
     Sem_eterm C (term_FillC (term_Val v) u)   (cons   (ectx_FillCFoc2 v)    C )   u
 | Sem_eterm_FillCUnfoc2 : forall (C:ectxs) (v v':val),
     Sem_eterm   (cons   (ectx_FillCFoc2 v)    C )   (term_Val v') C (term_FillC (term_Val v) (term_Val v'))
 | Sem_eterm_FillCRed : forall (C:ectxs) (h:hdn) (H:hdns) (v1 v2:val) (h':hdn)
     (hpMaxCh: h' =  (hdns_max_hnames   (HdnsM.union   (hdns_from_ectxs  C )     (hdns_from_list  (cons h nil) )  )  )  ),
     Sem_eterm C (term_FillC (term_Val (val_D h)) (term_Val (val_A H v1 v2)))  (ectxs_fill  C   h    (val_incr_hnames  v1   h' )  )  (term_Val  (val_incr_hnames  v2   h' ) ).


