THM Type Safety (TS):
if G |- S | t : A and onlyNegativeLabel(G) then S | t !! S' | v and G |- S' | v : A

LEMMA (PLT) Positive labels only in term typing contexts

LEMMA (NV) No variables in contexts

LEMMA (SUB)

CASE MapAmpar
HypTS.1 Let G |- S0 | t <&> \x -> u : A
     .2 onlyNegativeLabel(G)

HypTS.1 => TyCmd_Cmd.1                  G = Gs0 µ+ Gt
                    .2                  Gs0 |- S0
                    .3                  Gt |- t <&> \x -> u : A

TyCmd_Cmd.3 => TyTerm_MapAmpar.1        Gt = G1 µ G2
                              .2        G1 µ G2 |- t <&> \x -> u : B ><| A2
                              .3        G1 |- t : A1 ><| A2
                              .4        G2[L -> F] µ { x : m A1 } |- u : B
                              .5        exists m' in upper_modes(G1 µ G2)
                              .6        m = if F in upper_modes(G1) then F else L

TyCmd_Cmd.3 + TyTerm_MapAmpar.3 => (1)  Gs0 µ+ G1 |- S0 | t : A1 ><| A2

HypTS.2 + TyCmd_Cmd.1 => (A)            onlyNegativeLabel(Gs0 µ+ (G1 µ G2))
(A) + PLTLemma @ G2 => (B)              onlyNegativeLabel(Gs0 µ+ G1)


(1) + HypRecTS => (2).1                 S0 | t !! S1' | v
                     .2                 Gs0 µ+ G1 |- S1' | v : A1 ><| A2

(2).2 + TyCmd_Cmd + (B) => (3).1        Gs1' |- S1'
                              .2        G1' |- v : A1 ><| A2
                              .3        Gs0 µ+ G1 = Gs1' µ+ G1'

CanonicalFLemma + (3).2 => (4)          v = l

(4) + TyTerm_MapAmpar => (5)            G1' = {+l : A1 ><| A2}
(3).3 + (3).2 (B) => (6)                      {-l : A1 ><| A2} in Gs1'
(3).1 + (6) + TyHeap_Union + TyHeap_ClosedAmpar => 
                              (7).1     S1' = [l -> v1, w2] µ S1
                                 .2     Gs1' = ({-l : A1 ><| A2} µ (Gs11' µ+ Gs12')) µ+ Gs1
                                 .3     Gs11' |- v1 : A1
                                 .4     Gs12' |- w2 : A2
                                 .5     Gs1 |- S1
                                 .6     onlyPositiveHole(Gs11' µ+ Gs12')

(7).4 + (7).5 + TyHeap_Union + TyHeap_OpenAmpar =>
                              (8)       Gs12' µ+ Gs1 |- S1 µ [l -> <[], w2>]

Must prove G2 no interact with Gs11'
But:
     No -l in term contexts
     No -h in non-extended term contexts
So they cannot interact

Must prove G2 disjoint Gs11' ??

TyTerm_MapAmpar.4 + NVLemma + SUBLemma + (7.3) =>
                              (9)       G2 µ Gs11' |- u[x := v1] : B
(8) + (9) =>                  (10)      (Gs12' µ+ Gs1) µ+ (G2 µ Gs11') |- S1 µ [l -> <[], w2>] | u[x := v1] : B

G = Gs0 µ+ (G1 µ G2)
(11) G = Gs0 µ+ G1 µ+ G2 and G1 disjoint G2

(12) G = Gs1' µ+ G1' µ+ G2
(13) G = {-l : A1 ><| A2} µ+ Gs11' µ+ Gs12' µ+ Gs1 µ+ {+l : A1 ><| A2} µ+ G2
(14) G = Gs11' µ+ Gs12' µ+ Gs1 µ+ G2
And G2 disjoint Gs11'
(15) So G = (Gs12' µ+ Gs1) µ+ (G2 µ Gs11')

onlyNegativeLabel(G) => (16) onlyNegativeLabel((Gs12' µ+ Gs1) µ+ (G2 µ Gs11'))

HypRecTS => (17).1 S1 µ [l -> <[], w2>] | u[x := v1] !! S2' | v3
                .2 Gs2' |- S2'
                .3 Gv3 |- v3 : B
                .4 (Gs12' µ+ Gs1) µ+ (G2 µ Gs11') = G = Gs2' µ+ Gv3

LEMMA Open Ampar stays (OAS)

LEMMA Preservation of Ampar Right type (PAR)

(17).1 + OASLemma => (18) S2' = S2 µ [l -> <[], w4>]

(17).2 + (18) + TyHeap_Union + TyHeap_OpenAmpar => (19).1   Gs2' = Gs2 µ+ Gw4
                                                       .2   Gw4 |- w4 : ?
                                                       .3   Gs2 |- S2

(19).2 + PARLemma => (20) Gw4 |- w4 : A2

(20) + (17).3 + TyHeap_ClosedAmpar => (21) {-l : B ><| A2} µ (Gv3 µ+ Gw4) |- [l -> <v3, w4>]
     HERE: must prove onlyPositiveHole(Gv3 µ+ Gw4)



(21) + TyHeap_Union + (19).3 => (22) Gs2 µ+ ({-l : B ><| A2} µ (Gv3 µ+ Gw4)) |- S2 µ [l -> <v3, w4>]
TyTerm_Ampar => (23) {+ l : B ><| A2} |- l : B ><| A2
TyCmd_Cmd + (22) + (23) => (24) Gs2 µ+ Gv3 µ+ Gw4 |- S2 µ [l -> <v3, w4>] | l : B ><| A2

(17).4 + (19).1 => (25) G = Gs2' µ+ Gv3 = Gs2 µ+ Gw4

CQFD!
