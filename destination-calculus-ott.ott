% minimal + latex + comments

% truc zarbi avec unit : il n'est pas facile/possible d'avoir fillUnit
% 1 (unit) est utilisé comme monoid dans le type des commandes
% le remplacer par bottom créé une assymétrie entre fillUnit et fillPair

% TODO
% trouver comment empêcher de remplir une dest avec bullet ou dest

embed
{{ tex-preamble
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{lbcolor}{RGB}{186, 58, 7}
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\mathsf{#1} }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\ottlb}[1]{\textcolor{lbcolor}{\mathit{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle indent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\heaparrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyHeap}[1]{\textsc{TyHeap\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\itshape #1} }
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar metavariable, x, xs, y, uf, f, d ::=
  {{ tex \ottmv{[[metavariable]]} }}

% indexvar index, i ::=
%   {{ tex \textcolor{red}{[[index]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | x                                       ::   :: Var      {{ com variable }}
  | v :: :: Val {{ com value }}
  | t u                                    ::   :: App      {{ com application }}
  | t ; u :: :: WithEff {{ com effect execution }}
  | case t of { () -> u }                   ::   :: PatU     {{ com pattern-matching on unit }}
  | case t of { 1. x1 -> u1 , 2. x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
% | case t of { Nil -> u1 , x1 Cons x2 -> u2 } :: :: PatL {{ com pattern-matching on list }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on exponentiated value }}
  | case t of { roll R x -> u } :: :: PatR {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{ \underset{[[R]] }{\ottkw{roll} }~[[x]] \mapsto [[u]] \} }} {{ com unroll for recursive types }}
  | alloc d A { t }                                   ::   :: Alloc    {{ com allocate data }} {{ tex \underset{\ottty{[[A]]} }{\ottkw{alloc}~[[d]]}\,\textbf{.}\,[[t]] }}
  | fillUnit t :: :: FillU {{ com fill destination with unit }} {{ tex [[t]]\,\triangleleft\,\ottcons{()} }}
  | fillLeaf t u                            ::   :: FillL    {{ com fill terminal-type destination }} {{ tex [[t]]\,\triangleleft\,[[u]] }}
  | fillLeft t d { u }                          ::   :: FillV1   {{ com fill sum-type destination with variant 1 }} {{ tex [[t]]\,\triangleleft\,\ottcons{1.} [[d]]\,\textbf{.}\,[[u]] }}
  | fillRight t d { u }                          ::   :: FillV2   {{ com fill sum-type destination with variant 2 }} {{ tex [[t]]\,\triangleleft\,\ottcons{2.} [[d]]\,\textbf{.}\,[[u]] }}
  | fillPair t d1 d2 { u }                              ::   :: FillP    {{ com fill product-type destination }} {{ tex [[t]]\,\triangleleft\,\langle [[d1]] , [[d2]] \rangle\,\textbf{.}\,[[u]] }}
  | fillUr t d { u } :: :: FillE {{ com fill destination with exponential }} {{ tex [[t]]\,\triangleleft\,\ottcons{Ur}~[[d]]\,\textbf{.}\,[[u]] }}
  | fillRoll R t d { u } :: :: FillR {{ com fill destination with recursive type }} {{ tex [[t]]\,\triangleleft\,\underset{[[R]]}{\ottcons{roll} }~[[d]]\,\textbf{.}\,[[u]] }}
  | * l :: :: Deref {{ com \TODO{remove (only there for SemMut)} }}
  | ( t )                                   :: S :: Paren
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ var_subs ]                             :: M :: Sub

var_sub, vs :: 'vs_' ::= {{ com variable substitution }}
  | x := t :: :: VarSub

var_subs :: 'vss_' ::= {{ com variable substitutions }}
  | vs :: :: Single
  | vs , var_subs :: :: Multiple

heap_val, h :: 'hv_' ::=
  | ()                                      ::   :: U
  | 1. l :: :: V1
  | 2. l :: :: V2
  | < l1 , l2 > :: :: P
  | Ur l :: :: E
  | roll R l :: :: R {{ tex \underset{[[R]] }{\ottkw{roll} }~[[l]] }}
  | C lbar :: M :: Generic {{ tex [[C]] \ottlb{\bar{l} } }} {{ com generic for all the cases above }}

val, v :: 'v_' ::= {{ com unreducible value }}
  | o :: :: NoEff {{ com no-effect effect. \textcolor{red}{Not part of the user syntax} }}
  | l @ | A |                                       :: :: LDest {{ com allocated destination. \textcolor{red}{Not part of the user syntax} }} {{ tex {\scriptsize\vcenter{\offinterlineskip      \ialign{##\cr$\,\,\,[[l]]$\cr\noalign{\kern0.5pt}$\ottty{\lfloor[[A]]\rfloor}$\cr} } } }}
  | \ x : A . t                                ::   :: Lam      {{ com lambda abstraction }} {{ tex \lambda\aunderbrace[l1r]{\,[[x]]{:}[[A]]\,}\textbf{.}\,[[t]] }}
  | h :: :: HeapVal {{ com heap value }}

label, l :: 'l_' ::= {{ com label }} {{ tex \ottlb{[[label]]} }}

label_stmt, s :: 's_' ::= {{ com label statement }}
  | l .> v :: :: Val
  | l .> null :: :: Null
  | l bar .> vbar :: M :: Generic {{ tex \ottlb{\bar{[[l]]} } \heaparrow \ottnt{\bar{v} } }} {{ com generic for multiple occurences }}

label_stmts :: 'ss_' ::= {{ com label statements }}
  | s :: :: Single
  | s , label_stmts :: :: Multiple

heap_context, H {{ tex \mathbb{H} }} :: 'hc_' ::= {{ com label statements }}
  | empty :: :: Empty
  | { label_stmts } :: :: Stmts
  | H1 µ H2 :: :: Union

type, A, B :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
  | _!_ :: :: Bottom {{ com bottom type }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
%  | P :: :: Prim {{ com primitive type }}
  | A * B :: :: Prod {{ com product type }} {{ tex \ottty{[[A]] \otimes [[B]]} }}
  | A + B :: :: Sum {{ com sum type }}
  | A --o B :: :: LinArr {{ com linear function type }}
  | | A | :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[A]] \rfloor} }}
  | ! A :: :: Exp {{ com exponential }} {{ tex \ottty{![[A]]} }}
  | ( A )  :: S :: Paren {{ tex \ottty{([[A]])} }}
  | W [ r := A ] :: M :: Sub {{ tex [[W]][ \ottmv{r} [[:=]] \ottty{[[A]]} ] }}

type_with_hole, W :: 'twh_' ::= {{ tex \ottty{[[type_with_hole]]} }}
  | _!_ :: :: Bottom {{ com bottom type }}
  | r :: :: Hole {{ com type hole in recursive definition }} {{ tex \ottmv{[[r]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
%  | P :: :: Prim {{ com primitive type }}
  | W1 * W2 :: :: Prod {{ com product type }} {{ tex \ottty{[[W1]] \otimes [[W2]]} }}
  | W1 + W2 :: :: Sum {{ com sum type }}
  | W1 --o W2 :: :: LinArr {{ com linear function type }}
  | | W | :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[W]] \rfloor} }}
  | ! W :: :: Exp {{ com exponential }} {{ tex \ottty{![[W]]} }}
  | ( W )  :: S :: Paren {{ tex \ottty{([[W]])} }}

rec_type_bound, R :: 'rtb_' ::= {{ com recursive type bound to a name }} {{ tex \ottty{[[rec_type_bound]]} }}

rec_type_def :: 'rtd_' ::=
  | µ r . W :: :: Abs {{ tex \mu\,\ottmv{[[r]]}\,\textbf{.}\,[[W]] }}

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : A ::  :: Var {{ com var }}
  | l : A :: :: Label {{ com label }}
  | l bar : A bar :: :: GenericLabel {{ tex \ottlb{\bar{[[l]]} } : \ottty{\bar{[[A]]} } }} {{ com generic for multiple occurences }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, G {{ tex \Gamma }}, D {{ tex \Delta }}, U {{ tex \mho }}, P {{ tex \Phi }} :: 'tc_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var
  | G µ D    ::    :: Union

types, Abar {{ tex \ottty{\bar{A} } }} :: 'tys_' ::= {{ tex \ottty{[[types]]} }}
  | none :: :: None {{ tex \ottty{\cdot} }} {{ com empty type list }}
  | A :: :: Single
  | A types :: :: Multiple {{ tex [[A]]~~[[types]] }}

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

heap_constructor, C :: 'hcons_' ::= {{ tex \ottcons{[[heap_constructor]]} }}
  | { () } :: :: U
  | { 1. } :: :: V1
  | { 2. } :: :: V2
  | { < , > } :: :: P
  | { Ur } :: :: E
  | { roll R } :: :: R
  % | ( Nil ) :: :: Nil
  % | ( Cons ) :: :: Cons

judg :: 'judg_' ::=
  | P |- H :: :: TyHeap
  | P ; U ; G |- H | t : A :: :: TyCommand
  | P ; U ; G |- t : A ::  :: TyTerm
  | C : Abar >> A :: :: TyCtor
  | A is B :: :: EqType
  | t is u :: :: EqTerm
  | G is D :: :: EqContext
  | H | t --> H' | t' ::  :: SemMut
  | type_affect in G :: :: CtxIn
  | label_stmt in H :: :: HeapIn
  | names ( G ) /\ names ( D ) = empty :: :: CtxClash

terminals :: 'terminals_' ::=
  | () :: :: unit {{ tex \ottcons{()} }}
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | * :: :: deref {{ tex \ottlb{\star} }}
  | ° :: :: valderef {{ tex \ottlb{\ostar} }}
  | + :: :: sum {{ tex \ottty{\oplus} }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: with {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | ; :: :: lseq {{ tex ~;~ }}
  | /\ :: :: intersection {{ tex \cap }}
  | empty :: :: empty {{ tex \emptyset }}
  | --> :: :: reducesto {{ tex \longrightarrow }}
  | '|>' :: :: renamedto {{ tex \,\triangleright\, }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | 1. :: :: v1 {{ tex \ottcons{1.} }}
  | 2. :: :: v2 {{ tex \ottcons{2.} }}
  | Ur :: :: ur {{ tex \ottcons{Ur}\, }}
  | .> :: :: pointsto {{ tex \heaparrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | null :: :: null {{ tex \oslash }}
  | >> :: :: consarrow {{ tex ~\ottty{\consarrow}~ }}
  | is :: :: is {{ tex = }}
  | !! :: :: downto {{ tex ~~\Downarrow~~ }}
  | __ :: :: heapany {{ tex ... }}
  | =fix :: :: fix {{ tex \overset{\mathsf{fix} }{=} }}
  | _!_ :: :: bottom {{ tex \bot }}
  | o :: :: bullet {{ tex \bullet }}

defns
Ctx :: '' ::=

defn
names ( G ) /\ names ( D ) = empty :: :: CtxClash :: CtxClash_ {{ com $[[G]]$~~and~~$[[D]]$ are disjoint typing contexts with no clashing variable names or labels }} by

defn
type_affect in G :: :: CtxIn :: JcxtIn_ by

defns
Heap :: '' ::=

defn
label_stmt in H :: :: HeapIn :: HeapIn_ by

defns
Eq :: '' ::=

defn
A is B :: :: EqType :: EqType_ by
defn
t is u :: :: EqTerm :: EqTerm_ by
defn
G is D :: :: EqContext :: EqContext_ by

defns
Ty :: '' ::=

defn
R =fix rec_type_def :: :: TyRec :: TyRec_ by

defn
P |- H :: :: TyHeap :: TyHeap_ {{ com $[[H]]$ is a well-typed heap given heap typing context $[[P]]$ }} by

P1 |- H1
P2 |- H2
names(P1) /\ names(P2) = empty
------------------ :: Union
P1 µ P2 |- H1 µ H2

P ; U ; G |- \ x : A . t : A --o B
------------------- :: Lam
P µ { l : A --o B } |- H µ { l .> \x:A.t }

C : Abar >> A
P µ { l bar : A bar } |- H µ { l bar .> vbar }
------------------ :: HeapVal
P µ { l bar : A bar, l : A } |- H µ { l .> C lbar, l bar .> vbar }

----------- :: Enlarge {{ com \TODO{remove, needed for empty labels in SemMut} }}
empty |- H

defn
P ; U ; G |- H | t : A :: :: TyCommand :: TyCommand_ by

P |- H
P ; U ; G |- t : A
-------------------------------- :: Def
P ; U ; G |- H | t : A

defn
P ; U ; G |- t : A :: :: TyTerm :: TyTerm_ {{ com $[[t]]$ is a well-typed term of type $[[A]]$ given heap typing context $[[P]]$, unrestricted typing context $[[U]]$ and linear typing context $[[G]]$ }} by

------------------------ :: NoEff
P ; U ; empty |- o : _!_

------------------------------------- :: LDest {{ com \TODO{we should have either l : A in P or l not in names(P)} }}
P ; U ; empty |- l@|A| : |A|

P ; U ; G µ { x : A } |- t : B
----------------------- :: Lam
P ; U ; G |- \x:A.t : A --o B

C : Abar >> A
------------------------------------ :: HeapVal
P µ { l bar : A bar } ; U ; empty |- C lbar : A

--------------- :: Id
P ; U ; { x : A } |- x : A

--------------- :: Id'
P ; U µ { x : A} ; empty |- x : A

------------------------------------ :: Deref
P µ { l : A } ; U ; empty |- *l : A

P ; U ; G |- t : A --o B
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
--------------------------------- :: App
P ; U ; G µ D |- t u : B

P ; U ; G |- t : _!_
P ; U ; D |- u : B
names( G ) /\ names( D ) = empty
--------------------------------- :: WithEff
P ; U ; G µ D |- t ; u : B

P ; U ; G |- t : 1
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatU
P ; U ; G µ D |- case t of { () -> u } : A

P ; U ; G |- t : A1 + A2
P ; U ; D µ { x1 : A1 } |- u1 : B
P ; U ; D µ { x2 : A2 } |- u2 : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatS
P ; U ; G µ D |- case t of { 1. x1 -> u1 , 2. x2 -> u2 } : B

P ; U ; G |- t : A1 * A2
P ; U ; D µ { x1 : A1 , x2 : A2 } |- u : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatP
P ; U ; G µ D |- case t of {<x1, x2> -> u} : B

P ; U ; G |- t : !A
P ; U µ { x : A } ; D |- u: B
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatE
P ; U ; G µ D |- case t of { Ur x -> u } : B

R =fix µ r. W
P ; U ; G |- t : R
P ; U ; D µ { x : W[r := R] } |- u : B
names( G ) /\ names( D ) = empty
----------------------------- :: PatR
P ; U ; G µ D |- case t of { roll R x -> u } : B

P ; U ; G µ { d : |A| } |- t : _!_
------------------------------ :: Alloc {{ com  \TODO{add guard for LDest and NoEff} }}
P ; U ; G |- alloc d A { t } : A

P ; U ; G |- t : |1|
----------------------- :: FillU
P ; U ; G |- fillUnit t : _!_

P ; U ; G |- t : |A|
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------- :: FillL
P ; U ; G µ D |- fillLeaf t u : _!_

P ; U ; G |- t : |A1 + A2|
P ; U ; D µ { d' : |A1| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------- :: FillV1
P ; U ; G µ D |- fillLeft t d' { u } : B

P ; U ; G |- t : |A1 + A2|
P ; U ; D µ { d' : |A2| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------- :: FillV2
P ; U ; G |- fillRight t d' { u } : B

P ; U ; G |- t : |A1 * A2|
P ; U ; D µ { d1 : |A1| , d2 : |A2| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------------:: FillP
P ; U ; G µ D |- fillPair t d1 d2 { u } : B

P ; U ; G |- t : |!A|
P ; U ; empty µ { d : |A| } |- u : B
----------------------------------- :: FillE
P ; U ; G |- fillUr t d { u } : B

R =fix µ r. W
P ; U ; G |- t : |R|
P ; U ; D µ { d : |W[r := R]| } |- u : B
names( G ) /\ names( D ) = empty
---------------------------------------------------------------- :: FillR
P ; U ; G µ D |- fillRoll R t d { u } : B

defn
C : Abar >> A :: :: TyCtor :: TyCtor_ {{ com Heap constructor $[[C]]$ builds a value of type $[[A]]$ given arguments of type $[[Abar]]$ }} by

---------------- :: U
{ () } : none >> 1

-------------------  :: V1
{ 1. } : A >> A + B

----------------------- :: V2
{ 2. } : B >> A + B

--------------------------- :: P
{ <,> } : A B >> A * B

--------------- :: E
{ Ur } : A >> !A

R =fix µ r. W
---------------------- :: R
{ roll R } : W[r := R] >> R

defns
Sem :: '' ::=

defn
H | t --> H' | t' :: :: ReduceMut :: SemMut_ {{ com $[[t]]$ reduces to $[[t']]$, with heap changing from $[[H]]$ to $[[H']]$ }} by

H | t --> H' | t'
------------------- :: uApp
H | t u --> H' | t' u

---------------------------- :: App
H | (\x:A.t) u --> H | t[x := u]

---------------------------------- :: dLam
H µ { l .> \x:A.t } | *l --> H µ { l .> \x:A.t } | \x:A.t

---------------------------------- :: dHeapVal
H µ { l .> C lbar } | *l --> H µ { l .> C lbar } | C lbar

H | t --> H' | t'
--------------------------------------------- :: uPatU
H | case t of { () -> u } --> H' | case t' of { () -> u }

--------------------- :: PatU
H | case () of { () -> u } --> H | u

H | t --> H' | t'
------------------------------------------------------------------------------- :: uPatV12
H | case t of {1. x1 -> u1, 2. x2 -> u2} --> H' | case t' of {1. x1 -> u1, 2. x2 -> u2}

----------------------------------------- :: PatV1
H µ { l .> v } | case 1. l of {1. x1 -> u1, 2. x2 -> u2} --> H | u1[x1 := v]

----------------------------------------- :: PatV2
H µ { l .> v } | case 2. l of {1. x1 -> u1, 2. x2 -> u2} --> H | u2[x2 := v]

H | t --> H' | t'
----------------------------------------------------------------------------- :: uPatP
H | case t of {<x1,x2> -> u} --> H' | case t' of {<x1,x2> -> u}

-------------------------------------------------------------------------------- :: PatP
H µ { l1 .> v1, l2 .> v2 } | case <l1, l2> of {<x1,x2> -> u} --> H | u[x1 := v1, x2 := v2]

H | t --> H' | t'
------------------------------------------------------------------------------------- :: uPatE
H | case t of {Ur x -> u} --> H' | case t' of {Ur x -> u}

----------------------------------------------------- :: PatE
H µ { l .> v } | case Ur l of { Ur x -> u } --> H | u[x := v]

H | t --> H' | t'
------------------------------------------------------ :: uPatR
H | case t of { roll R x -> u} --> H' | case t' of { roll R x -> u}

------------------------------------------------------ :: PatR
H µ { l .> v } | case roll R l of { roll R x -> u } --> H | u[x := v]

H | t --> H' | t'
------------------------------------------------------ :: uWithEff
H | t ; u --> H' | t' ; u

------------------------------------------------------ :: WithEff
H | o ; u --> H | u

--------------------------------------------------- :: Alloc
H | alloc d A { t } --> H µ { l .> null } | t[d := l@|A|] ; *l

H | t --> H' | t'
------------------------------------- :: uFillU
H | fillUnit t --> H' | fillUnit t'

------------------------------------------------------------ :: FillU
H µ { l .> null } | fillUnit l@|1| --> H µ { l .> () } | o

H | t --> H' | t'
------------------------------------- :: uFillL
H | fillLeaf t u --> H' | fillLeaf t' u

H | t --> H' | t'
------------------------------------- :: uFillL'
H | fillLeaf l@|A| t --> H' | fillLeaf l@|A| t'

------------------------------------------------------------ :: FillLLam
H µ { l .> null } | fillLeaf l@|A| \x:A.t --> H µ { l .> \x:A.t } | o

------------------------------------------------------------ :: FillLHeapVal
H µ { l .> null } | fillLeaf l@|A| C lbar --> H µ { l .> C lbar } | o

H | t --> H' | t'
------------------------------------- :: uFillV1
H | fillLeft t d {u} --> H' | fillLeft t' d {u}

------------------------------------------------------------ :: FillV1
H µ { l .> null } | fillLeft l@|A1+A2| d { t } --> H µ { l .> 1. l', l' .> null } | t[d := l'@|A1|]

H | t --> H' | t'
------------------------------------- :: uFillV2
H | fillRight t d {u} --> H' | fillRight t' d {u}

------------------------------------------------------------ :: FillV2
H µ { l .> null } | fillRight l@|A1+A2| d { t } --> H µ { l .> 2. l', l' .> null } | t[d := l'@|A2|]

H | t --> H' | t'
------------------------------------- :: uFillP
H | fillPair t d1 d2 {u} --> H' | fillPair t' d1 d2 {u}

----------------------------------------------- :: FillP
H µ { l .> null } | fillPair l@|A1*A2| d1 d2 { t } --> H µ { l .> <l1, l2> , l1 .> null, l2 .> null } | t[d1 := l1@|A1|, d2 := l2@|A2|]

H | t --> H' | t'
---------------------------------------- :: uFillE
H | fillUr t d {u} --> H' | fillUr t' d {u}

---------------------------------------- :: FillE
H µ { l .> null } | fillUr l@|!A| d { t } --> H µ { l .> Ur l', l' .> null } | t[d := l'@|A|]

H | t --> H' | t'
---------------------------------------- :: uFillR
H | fillRoll R t d {u} --> H' | fillRoll R t' d {u}

R =fix µ r. W
---------------------------------------- :: FillR
H µ { l .> null } | fillRoll R l@|R| d { t } --> H µ { l .> roll R l', l' .> null } | t[d := l'@|W[r := R]|]

defn
H | t !! H' | t' :: :: ReduceImm :: SemImm_ {{ com $[[t]]$ reduces to $[[t']]$, with heap growing from $[[H]]$ to $[[H']]$ }} by

------------------- :: NoEff {{ com \remark{(value)} }}
H | o !! H | o

------------------- :: LDest {{ com \remark{(value)} }}
H | l@|A| !! H | l@|A|

------------------- :: Lam {{ com \remark{(value)} }}
H | \x:A.t !! H | \x:A.t

-------------------- :: HeapVal {{ com \remark{(value)} }}
H | C lbar !! H | C lbar

H0 | t !! H1 | \x:A.t'
H1 | u !! H2 | v2
H2 | t'[x := v2] !! H3 | v3
---------------------------- :: App
H0 | t u !! H3 | v3

H0 | t !! H1 | ()
H1 | u !! H2 | v2
--------------------------------------------- :: PatU
H0 | case t of { () -> u } !! H2 | v2

H0 | t !! H1 µ { l .> v1 } | 1. l
H1 µ { l .> v1 } | u1[x1 := v] !! H2 | v2
----------------------------------------- :: PatV1
H0 | case t of {1. x1 -> u1, 2. x2 -> u2} !! H2 | v2

H0 | t !! H1 µ { l .> v1 } | 2. l
H1 µ { l .> v1 } | u2[x2 := v] !! H2 | v2
----------------------------------------- :: PatV2
H0 | case t of {1. x1 -> u1, 2. x2 -> u2} !! H2 | v2

H0 | t !! H1 µ { l1 .> v11, l2 .> v12 } | <l1, l2>
H1 µ { l1 .> v11, l2 .> v12 } | u[x1 := v1, x2 := v2] !! H2 | v2
-------------------------------------------------------------------------------- :: PatP
H0 | case t of {<x1,x2> -> u} !! H2 | v2

H0 | t !! H1 µ { l .> v1 } | Ur l
H1 µ { l .> v1 } | u[x := v1] !! H2 | v2
----------------------------------------------------- :: PatE
H0 | case t of { Ur x -> u } !! H2 | v2

H0 | t !! H1 µ { l .> v1 } | roll R l
H1 µ { l .> v1 } | u[x := v1] !! H2 | v2
------------------------------------------------------ :: PatR
H0 | case t of { roll R x -> u } !! H2 | v2

H0 | t !! H1 | o
H1 | u !! H2 | v2
------------------------------------------------------ :: WithEff
H0 | t ; u !! H2 | v2

H0 | t[d := l@|A|] !! H1 µ { l .> v1 } | o
--------------------------------------------------- :: Alloc
H0 | alloc d A { t } !! H1 µ { l .> v1 } | v1

H0 | t !! H1 | l@|1|
---------------------------- :: FillU
H0 | fillUnit t !! H1 µ { l .> () } | o

H0 | t !! H1 | l@|A --o B|
H1 | u !! H2 | \x:A.t
------------------------------------------------------------ :: FillLLam {{ com \remark{block on NoEff/LDest} }}
H0 | fillLeaf t u !! H2 µ { l .> \x:A.t } | o

H0 | t !! H1 | l@|A|
H1 | u !! H2 | C lbar
------------------------------------------------------------ :: FillLHeapVal {{ com \remark{block on NoEff/LDest} }}
H0 | fillLeaf t u !! H2 µ { l .> C lbar } | o

H0 | t !! H1 | l@|A + B|
H1 | u[d := l'@|A|] !! H2 µ { l' .> v1 } | v2
------------------------------------------------------------ :: FillV1
H0 | fillLeft t d { u } !! H2 µ { l .> 1. l', l' .> v1 } | v2

H0 | t !! H1 | l@|A + B|
H1 | u[d := l'@|B|] !! H2 µ { l' .> v1 } | v2
------------------------------------------------------------ :: FillV2
H0 | fillRight t d { u } !! H2 µ { l .> 2. l', l' .> v1 } | v2

H0 | t !! H1 | l@|A * B|
H1 | u[d1 := l1@|A|, d2 := l2@|B|] !! H2 µ { l1 .> v11, l2 .> v12 } | v2
--------------------------------------------------------------- :: FillP
H0 | fillPair t d1 d2 { u } !! H2 µ { l .> <l1, l2>, l1 .> v11, l2 .> v12 } | v2

H0 | t !! H1 | l@|!A|
H1 | u[d := l'@|A|] !! H2 µ { l' .> v1 } | v2
--------------------------------------------------- :: FillE
H0 | fillUr t d { u } !! H2 µ { l .> Ur l', l' .> v1 } | v2

R =fix µr.W
H0 | t !! H1 | l@|R|
H1 | u[d := l'@|W[r := R]|] !! H2 µ { l' .> v1 } | v2
--------------------------------------------------- :: FillR
H0 | fillRoll R t d { u } !! H2 µ { l .> roll R l', l' .> v1 } | v2

% embed
% {{ tex

% \begin{defi}[Pointer-less term]
% A term $[[t]]$ is said "pointer-less" if neither itself nor one of its subterms are one of $[[l]]$, $[[*l]]$ or $[[°l]]$.
% \end{defi}

% \begin{lem}[Canonical forms]

% Let $[[v]]$ be a value such that $[[H0]] | [[t0]] \overset{n}{\longrightarrow} [[H]] | [[v]]$ and $[[P ; U ; G |- H | v : A]]$ for some \emph{pointer-less} term $[[t0]]$.

% \begin{tabular}{ll}
% Ty & Value \\
% $[[A is 1]]$ & $[[v is ()]]$ \\
% $[[A is B1 * B2]]$ & $[[v is °l]] ~~\land~~ [[l .> <l1, l2> in H]]$ \\
% $[[A is B1 + B2]]$ & $[[v is °l]] ~~\land~~ \left([[l .> 1. l' in H]]~~\lor~~[[l .> 2. l' in H]]\right)$ \\
% $[[A is B1 --o B2]]$ & $[[v is \x:B1.t]]$ \\
% $[[A is |B|]]$ & $[[v is l]]$ \\
% $[[A is [B] ]]$ & $[[v is °l]] ~~\land~~ \left([[l .> Nil in H]] ~~\lor~~[[l .> l1 Cons l2 in H]]\right)$ \\
% $[[A is !B ]]$ & $[[v is Ur t]]$\\
% \end{tabular}

% \bigskip

% \noindent\textit{Proof:}

% \begin{itemize}
% \item If $[[A is 1]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[\x:A'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
% \item $[[v]]$ can be $[[()]]$ (\TyTerm{Unit})
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : 1 in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> 1]]$ (by application of \TyHeap{Ctor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
% \end{itemize}
% So $[[P ; U ; G |- H | v : 1]] \implies [[v is ()]]$

% \item If $[[A is B1 * B2]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[\x:A'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : B1 * B2 in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> B1 * B2]]$ (by application of \TyHeap{Ctor}). There is only one such $[[C]]$: $[[(<,>)]]$. In addition, we should have $[[l .> <l1, l2> in H]]$ (still from \TyHeap{Ctor}).
% \end{itemize}
% So $[[P ; U ; G |- H | v : B1 * B2]] \implies [[v is °l]] ~~\land~~ [[l .> <l1, l2> in H]]$

% \item If $[[A is B1 + B2]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[\x:A'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : B1 + B2 in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> B1 + B2]]$ (by application of \TyHeap{Ctor}). There are two constructors matching this criterion: $[[(1.)]]$~~and~~$[[(2.)]]$. With the former, we should have $[[l .> 1. l' in H]]$, and with the latter, we should have $[[l .> 2. l' in H]]$ (still from \TyHeap{Ctor}).
% \end{itemize}
% So $[[P ; U ; G |- H | v : B1 + B2]] \implies [[v is °l]] ~~\land~~ \left([[l .> 1. l' in H]]~~\lor~~[[l .> 2. l' in H]]\right)$

% \item If $[[A is B1 --o B2]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
% \item $[[v]]$ can be $[[\x:B1.t]]$ (\TyTerm{Lam})
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : B1 --o B2 in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> B1 --o B2]]$ (by application of \TyHeap{Ctor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
% \end{itemize}
% So $[[P ; U ; G |- H | v : B1 --o B2]] \implies [[v is \x:B1.t]]$

% \item If $[[A is |B|]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[\x:B'.t]]$ or $[[Ur t]]$ (Inversion lemma).
% \item $[[v]]$ can be $[[l]]$ (\TyTerm{LabelAsDest}), in which case $[[l : A in P]]$.
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : |B| in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> |B|]]$ (by application of \TyHeap{Ctor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
% \end{itemize}
% So $[[P ; U ; G |- H | v : |B|]] \implies [[v is l]]$

% \item If $[[A is [B] ]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[\x:B'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : [B] in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> [B] ]]$ (by application of \TyHeap{Ctor}). There are two constructors matching this criterion: $[[(Nil)]]$~~and~~$[[(Cons)]]$. With the former, we should have $[[l .> Nil in H]]$, and with the latter, we should have $[[l .> l1 Cons l2 in H]]$ (still from \TyHeap{Ctor}).
% \end{itemize}
% So $[[P ; U ; G |- H | v : [B] ]] \implies [[v is °l]] ~~\land~~ \left([[l .> Nil in H]] ~~\lor~~[[l .> l1 Cons l2 in H]]\right)$

% \item If $[[A is !B ]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[\x:B'.t]]$ or $[[l]]$ (Inversion lemma).
% \item $[[v]]$ can be $[[Ur t]]$ (\TyTerm{Exp}).
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : [B] in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> !B]]$ (by application of \TyHeap{Ctor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
% \end{itemize}
% So $[[P ; U ; G |- H | v : !B ]] \implies [[v is Ur t]]$

% \end{itemize}
% \end{lem}

% \begin{lem}[Inversion of the typing relation]\phantom{nl}

% \begin{itemize}
% \item If $[[P ; U ; G |- x : A]]$, then either $[[G is {x : A}]]$ or $[[x : A in U]]~\land~[[G is empty]]$ (\TyTerm{Id} and \TyTerm{Id'})
% \item If $[[P ; U ; G |- () : A]]$, then $[[G is empty]]$~~and~~$[[A is 1]]$ (\TyTerm{Unit})
% \item If $[[P ; U ; G |- Ur t : A]]$ then $[[G is empty]]$ and there is some type $[[B]]$ such that $[[A is !B]]$~~and~~$[[P ; U ; empty |- t : B]]$ (\TyTerm{Exp})
% \item If $[[P ; U ; G |- l : A]]$ then $[[G is empty]]$ and there is some type $[[B]]$ such that $[[A is |B|]]$~~and~~$[[l : B in P]]$ (\TyTerm{LabelAsDest})
% \item If $[[P ; U ; G |- °l : A]]$ then $[[G is empty]]$~~and~~$[[l : A in P]]$ (\TyTerm{DerefVal})
% \item If $[[P ; U ; G |- *l : A]]$ then $[[G is empty]]$~~and~~$[[l : A in P]]$ (\TyTerm{Deref})
% \item If $[[P ; U ; G |- \x:B1.t:A]]$, then there is some type $[[B2]]$ such that $[[A is B1 --o B2]]$~~and~~$[[P ; U ; G µ {x:B1} |- t : B2]]$ (\TyTerm{Lam})
% \item If $[[P ; U ; G |- t u : A]]$, then there are some type $[[B]]$ and contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : B --o A]]$,~~~$[[P ; U ; D2 |- u : B]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{App})
% \item If $[[P ; U ; G |- t ; u : A]]$ then there are some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : 1]]$,~~~$[[P ; U ; D2 |- u : A]]$, and $[[G is D1 µ D2]]$ (\TyTerm{PatU})
% \item If $[[P ; U ; G |- case t of { <x1, x2> -> u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : B1 * B2]]$,~~~$[[P ; U ; D2 µ { x1 : B1, x2 : B2 } |- u : A]]$ and , and $[[G is D1 µ D2]]$ (\TyTerm{PatP})
% \item If $[[P ; U ; G |- case t of { 1.x1 -> u1, 2.x2 -> u2 } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : B1 + B2]]$,~~~$[[P ; U ; D2 µ { x1 : B1 } |- u1 : A]]$,~~~$[[P ; U ; D2 µ { x2 : B2 } |- u2 : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{PatS})
% \item If $[[P ; U ; G |- case t of { Nil -> u1, x1 Cons x2 -> u2 } : A]]$ then there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : [B] ]]$,~~~$[[P ; U ; D2 |- u1 : A]]$,~~~$[[P ; U ; D2 µ { x1 : B, x2 : [B] } |- u2 : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{PatL})
% \item If $[[P ; U ; G |- case t of { Ur x -> u } : A]]$ then there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : !B]]$,~~~$[[P ; U µ {x : B} ; D2 |- u : A]]$ and and $[[G is D1 µ D2]]$ (\TyTerm{PatE})
% \item If $[[P ; U ; G |- fillLeaf t u : A]]$ then $[[A is 1]]$ and there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B|]]$,~~~$[[P ; U ; D2 |- u : B]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{FillL})
% \item If $[[P ; U ; G |- fillLeft t d' { u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B1 + B2|]]$,~~~$[[P ; U ; D2 µ { d' : |B1| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{FillV1})
% \item If $[[P ; U ; G |- fillRight t d' { u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B1 + B2|]]$,~~~$[[P ; U ; D2 µ { d' : |B2| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{FillV2})
% \item If $[[P ; U ; G |- fillPair t d1 d2 { u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B1 * B2|]]$,~~~$[[P ; U ; D2 µ { d1 : |B1|, d2 : |B2| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{FillP})
% \item If $[[P ; U ; G |- fillNil t : A]]$ then $[[A is 1]]$ and there is some type $[[B]]$ such that $[[P ; U ; G |- t : |[B]| ]]$ (\TyTerm{FillNil})
% \item If $[[P ; U ; G |- fillCons t d1 d2 { u } : A]]$ then there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |[B]|]]$,~~~$[[P ; U ; D2 µ { d1 : |B|, d2 : |[B]| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{FillP})

% \end{itemize}

% \bigskip

% \noindent\textit{Proof:}

% \smallskip

% Immediate from the definition of the typing relation.

% \end{lem}

% \bigskip
% \togglespaces

% \noindent\textbf{Example 1 :} implementation of $\ottkw{map}$ with $\ottkw{rolll}$

% \[\begin{array}{l}
% \ottkw{map} \defeq [[
% \uf: !(A --o B). \xs: [A]. \d0: |[B]|. (
% b s (rolll
% b ss case uf of { Ur f -> Ur (
% b sss \d: |[B]|. \x: A. (fillCons d d1 d2 { fillLeaf d1 (f x) ; d2 })
% b sse )}
% b ss d0
% b ss xs
% ) b fillNil se)
% ]]
% \end{array}\]
% }}


parsing
v_Lam <= t_Sub
t_PatU <= t_App
t_PatU <= t_FillL
judg_HeapIn <= s_Val
hcons_V1 <= terminals_v1
