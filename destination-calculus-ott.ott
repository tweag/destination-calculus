% minimal + latex + comments

embed
{{ tex-preamble
%\usepackage{stmaryrd}
\geometry{a4paper,left=0.75cm,right=0.75cm,top=1.25cm,bottom=2cm}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{bbold}
\DeclareSymbolFont{bbsymbol}{U}{bbold}{m}{n}
\DeclareMathSymbol{\bbcomma}{\mathbin}{bbsymbol}{"2C}
\DeclareMathAlphabet{\mathsfbf}{T1}{\sfdefault}{sbc}{n}
\definecolor{ntcolor}{RGB}{75, 75, 75}
\definecolor{kwcolor}{RGB}{0, 0, 0}
\definecolor{lbcolor}{HTML}{F8980F} % yellow-orange, underlined
\definecolor{tycolor}{HTML}{176FC1} % blue, bold
\definecolor{spcolor}{HTML}{1C5737} % dark green, not official one
\definecolor{modecolor}{HTML}{00AAA0} % green-blue, tt
\definecolor{mvcolor}{HTML}{F35EB7} % pink, sf
\definecolor{holecolor}{HTML}{F14B2D} % red, itshape
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsfbf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\newcommand{\ottextval}[1]{\textcolor{ntcolor}{\mathsf{\replacewv{\overline{#1} } } } }
\newcommand{\ottextterm}[1]{\textcolor{ntcolor}{\mathsf{\replacejt{\overline{#1} } } } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\textcolor{kwcolor}{\mathsfbf{#1} } }
\newcommand{\ottdefault}[1]{\textcolor{black}{#1} }
\newcommand{\ottcons}[1]{\textcolor{black}{\mathsf{#1} } }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathit{#1} } }
\newcommand{\ottlb}[1]{\textcolor{lbcolor}{\mathit{\underline{\replacelell{#1} } } } }
\newcommand{\otthol}[1]{\textcolor{holecolor}{\mathit{#1} } }
\newcommand{\ottmod}[1]{\textcolor{modecolor}{\mathtt{#1} } }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\replacejt}[1]{%
  \begingroup%
  \mathcode`j=\mathcode`t
  #1%
  \endgroup%
}
\newcommand{\replacewv}[1]{%
  \begingroup%
  \mathcode`w=\mathcode`v
  #1%
  \endgroup%
}
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle destent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\storearrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyStore}[1]{\textsc{TyStore\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\small\itshape #1} }
\newcommand{\holearrowgen}[1]{\ottho{\text{#1}\!\!\!\rightharpoonup} } % 
\def\restriction#1#2{\mathchoice
              {\setbox1\hbox{${\displaystyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\textstyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptscriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} } }
\def\restrictionaux#1#2{ {#1\,\smash{\vrule height .8\ht1 depth .85\dp1} }_{\,#2} }
\usepackage[safe]{tipa}
\newcommand{\mpar}{\ottty{\text{\large\textramshorns} } }
\newcommand{\mparcomma}{ {\scriptstyle\odot} }
\newcommand{\expc}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{-.1ex}{\hspace{-0.4ex}\scriptsize c} } }\hspace{-0.7ex} }
\newcommand{\expw}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{0.05ex}{\hspace{-0.6ex}${\scriptscriptstyle\omega}$} } }\hspace{-0.7ex} }
\newcommand{\putarrow}[1]{\!\overset{#1}{\triangleleft}\!}
\newcommand{\lam}[3]{\ottcons{\lambda}\,#1\!:\!#2\,\textbf{.}\,#3}
\newcommand{\lamnt}[2]{\ottcons{\lambda}#1\,\textbf{.}\,#2}
\newcommand{\Lam}[2]{\ottcons{\Lambda}\,#1\,\textbf{.}\,#2}
\newcommand{\nuabs}[1]{\nu#1\textbf{.}\,}
\newlength{\mylen}
\setbox1=\hbox{$\bullet$}\setbox2=\hbox{$\scriptscriptstyle\bullet$}
\setlength{\mylen}{\dimexpr0.5\ht1-0.5\ht2}
\def\mybullet{\raisebox{\mylen}{$\scriptscriptstyle\bullet$} }
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar termvar, x, y, d ::= {{ com Term-level variable }}
  {{ tex \ottmv{[[termvar]]} }}

% metavar idxvar, i ::=
%   {{ tex \ottmv{[[idxvar]]} }}

grammar

label, l :: 'Lbl_' ::= {{ tex \ottlb{[[label]]} }} {{ com Label }}

hole, h :: 'Hole_' ::= {{ tex \otthol{[[hole]]} }} {{ com Hole }}

term_value, v :: 'TermVal_' ::= {{ com Term value }}
  | l :: :: LblAmpar {{ com Label representing an Ampar }}
  | @ h :: :: Dest {{ tex \otthol{@}[[h]] }} {{ com Destination }}
  | () :: :: Unit {{ com Unit }}
  | Inl v :: :: Inl {{ com Left variant for sum }}
  | Inr v :: :: Inr {{ com Right variant for sum }}
  | ( v1 , v2 ) :: :: Prod {{ tex \ottcons{(}[[v1]]\,\ottcons{,}~[[v2]]\ottcons{)} }} {{ com Product }}
  | \ x -> t :: :: Lambda {{ tex \lamnt{[[x]]}{[[t]]} }} {{ com Linear function }}
  | ( v ) :: S :: Paren

extended_value, w :: 'ExtVal_' ::= {{ com Store value }} {{ tex \ottextval{[[extended_value]]} }}
  | v :: :: TermVal {{ com Term value }}
  | h :: :: Hole {{ com Hole }}
  | Inl w :: :: Inl {{ com Left variant with val or hole }}
  | Inr w :: :: Inr {{ com Right variant with val or hole }}
  | ( w1 , w2 ) :: :: Prod {{ tex \ottcons{(}[[w1]]\,\ottcons{,}~[[w2]]\ottcons{)} }} {{ com Product with val or hole }}
  | ( w ) :: S :: Paren

term, t, u :: 'Term_' ::=                                               {{ com Term }}
  | v :: :: TermVal {{ com Term value }}
  | x :: :: Var {{ com Variable }}
  | t u                                    ::   :: App      {{ com Application }}
  | t ; u                   ::   :: PatUnit {{ com Pattern-match on unit }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,[[()]]\![[->]]\,[[u]] }}
  | t & \case { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatSum     {{ com Pattern-match on sum }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\{\,\ottcons{Inl}\,[[x1]][[->]][[u1]]\,,~\ottcons{Inr}\,[[x2]][[->]][[u2]]\,\} }}
  | t & \case ( x1 , x2 ) -> u            ::   :: PatProd     {{ com Pattern-match on product }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\ottcons{(}[[x1]]\,\ottcons{,}~[[x2]]\ottcons{)}\![[->]]\,[[u]] }}
  | t <&> \ x -> u :: :: MapAmpar {{ com Map over the left side of the ampar }} {{ tex [[t]]~\succ\!\!\ottkw{mapL}\,[[x]]\![[->]]\,[[u]] }}

  % | toGlobal t :: :: ToGlobal {{ tex \ottkw{to}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion to ${\ottmod{\scriptstyle G} }$ }}
  % | fromGlobal t :: :: FromGlobal {{ tex \ottkw{from}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion from ${\ottmod{\scriptstyle G} }$ }}
  | toAmpar t :: :: ToAmpar {{ tex \ottkw{to}_{[[><|]]}\,[[t]] }} {{ com Wrap $[[t]]$ into a trivial ampar }}
  | fromAmpar t :: :: FromAmpar {{ tex \ottkw{from}_{[[><|]]}\,[[t]] }} {{ com Extract value from trivial ampar }}

  | alloc :: :: Alloc {{ com Return a fresh "identity" ampar object }}
  | t <| () :: :: FillUnit {{ com Fill destination with unit }}
  | t <| Inl                          ::   :: FillInl   {{ com Fill destination with left variant }}
  | t <| Inr                          ::   :: FillInr   {{ com Fill destination with right variant }}
  | t <| (,)                              ::   :: FillProd    {{ com Fill destination with product constructor }}
  | t <|. u :: :: FillComp {{ com Fill destination with root of ampar $[[u]]$ }}

  | ( t )                                   :: S :: Paren
  | t [ subs ]                             :: M :: Subs
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
  % | t b spe :: S :: BreakSpacing3

extended_term, j :: 'ExtTerm_' ::= {{ com Extended term }} {{ tex \ottextterm{[[extended_term]]} }}
  | t :: :: Term
  | w :: :: ExtVal

sub :: 'Sub_' ::= {{ com Variable or label substitution }}
  | x := v :: :: VarSub
  | h := w :: :: HoleSub

subs :: 'Subs_' ::= {{ com Substitutions }}
  | sub :: :: Single
  | sub , subs :: :: Multiple

store, S :: 'Store_' ::=
  | {} :: :: Empty {{ tex [] }}
  | { store_assigns } :: :: Assigns {{ tex [\, [[store_assigns]] \,] }}
  | S [ subs ] :: :: Subs
  | S1 µ S2 :: :: Disjoint

store_assign, ha :: 'StoreAssign_' ::=
  | l -> < v1 ¤ w2 > :: :: ClosedAmpar {{ tex [[l]][[->]]\ottcons{\langle}[[v1]]\,\ottcons{\bbcomma}~[[w2]]\ottcons{\rangle} }} {{ com Closed ampar ($[[w2]]$ = root of the incomplete struct) }}
  | l -> < [] ¤ w2 > :: :: OpenAmpar {{ tex [[l]][[->]]\ottcons{\langle}\blacksquare\,\ottcons{\bbcomma}~[[w2]]\ottcons{\rangle} }} {{ com Open ampar ($[[w2]]$ = root of the incomplete struct) }}

store_assigns :: 'StoreAssigns_' ::=
  | ha :: :: Single
  | ha , store_assigns :: :: Multiple

type, A, B :: 'Ty_' ::= {{ com Type }} {{ tex \ottty{[[type]]} }}
  | 1 :: :: Unit {{ tex \ottty{1} }} {{ com Unit }}
  | A1 + A2 :: :: Sum {{ tex [[A1]]\ottty{\oplus}[[A2]] }} {{ com Sum }}
  | A1 * A2 :: :: Prod {{ tex [[A1]]\ottty{\otimes}[[A2]] }} {{ com Product }}
  | A1 ><| A2 :: :: Ampar {{ tex [[A1]]\,[[><|]]\,[[A2]] }} {{ com Ampar type (consuming $[[A1]]$ yields $[[A2]]$) }}
  | m1 A1 --o A2 :: :: Lambda {{ tex [[A1]]\,_{[[m1]]}\![[--o]]\,[[A2]] }} {{ com Linear function }}
  | Dest A :: :: Dest {{ tex [[A]]\ottty{^D} }} {{ com Destination }}
  | ( A ) :: S :: Paren {{ tex \ottty{(}[[A]]\ottty{)} }}

mode, m :: 'Mode_' ::= {{ tex \ottmod{[[mode]]} }} {{ com Mode }}
  % | _ :: :: Placeholder {{ tex \ottmod{\_} }} {{ com Placeholder for any mode }}
  | _L :: :: Local {{ tex \ottmod{\scriptstyle L} }} {{ com Local }}
  | _F :: :: Foreign {{ tex \ottmod{\scriptstyle F} }} {{ com Foreign }}
  | _G :: :: Global {{ tex \ottmod{\scriptstyle G} }} {{ com Global }}
  | max_mode ( G ) :: :: MaxCtx {{ tex \ottmod{max\_mode(}[[G]]\ottmod{)} }}
  | if mode_cond then m3 else m4 :: :: If

mode_cond :: 'ModeCond' ::= {{ com Mode statement }} {{ tex \ottmod{[[mode_cond]]} }}
  | m1 = m2 :: :: Eq
  % | m1 <= m2 :: :: Leq
  | m in upper_modes ( G ) :: :: Supr
  | exists m in upper_modes ( G ) :: :: ExistsSupr

typing_context, U {{ tex \mho }}, G {{ tex \Gamma }} :: 'TyCtx_' ::= {{ com Typing context }}
  | {}    ::   :: Empty
  | { type_assigns } ::    :: Assigns
  | G1 µ G2    ::    :: Disjoint
  | G1 µ+ G2 :: :: DisjointInteract
  | G [ m1 -> m2 ] :: :: OverwriteMode
  | ( G ) :: S :: Paren

type_assign, ta :: 'TyAssign_' ::= {{ com Type assignment }}
%  | x : A :: :: LocalVar
  | x : m A :: :: Var {{ tex [[x]]:_{[[m]]}[[A]] }}
  | + l : A :: :: AmparPos {{ tex \textcolor{lbcolor}{+}[[l]]:[[A]] }}
  | - l : A :: :: AmparNeg {{ tex \textcolor{lbcolor}{-}[[l]]:[[A]] }}
  | + h : A :: :: Dest {{ com Destination }} {{ tex \otthol{+}[[h]]:[[A]] }}
  | - h : A :: :: Hole {{ com Hole }} {{ tex \otthol{-}[[h]]:[[A]] }}

type_assigns :: 'TyAssigns_' ::= {{ com Type assignments }}
  | ta :: :: Single
  | ta , type_assigns :: :: Multiple

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=
% === Type syntax ===
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | ><| :: :: rtimes {{ tex \ottty{\rtimes} }}

% === Term syntax ===
  | ->                                     ::   :: mapsto       {{ tex \mapsto }}
  | () :: :: unit {{ tex \ottcons{()} }}
  | Inl :: :: inl {{ tex \ottcons{Inl} }}
  | Inr :: :: inr {{ tex \ottcons{Inr} }}
  | (,) :: :: prod {{ tex \ottcons{({,})} }}
  | <| :: :: fill {{ tex \triangleleft }}
  | <|. :: :: fillcomp {{ tex \triangleleft\!\mybullet\, }}

% === Contexts ===
  | µ :: :: dunion {{ tex \sqcup }}
  | µ+ :: :: sdunion {{ tex \,\text{\makebox[0pt][l]{$\sqcup$}\raisebox{.40ex}{\hspace{.15ex}$\scriptscriptstyle\pm$} } }}
  | '{}' :: :: empty {{ tex \{\} }}

% === Judgements ===
  | exists :: :: exists {{ tex \exists }}
  | != :: :: neq {{ tex \neq }}
  | <= :: :: leq {{ tex \leq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | includedin :: :: includedin {{ tex \subset }}
  | names :: :: names {{ tex \mathcal{N} }}

% === Typing ===
  | |- :: :: turnstile {{ tex \vdash }}

% === Semantics ===
  | '|' :: :: cmd {{ tex ~|~ }}
  | !! :: :: downto {{ tex \,\Downarrow\, }}

defns
Ctx :: '' ::=

defn
x in names ( G ) :: :: CtxVarIn :: CtxVarIn_ by

defn
l in names ( G ) :: :: CtxLblIn :: CtxLblIn_ by

defn
x notin names ( G ) :: :: CtxVarNotIn :: CtxVarNotIn_ by

defn
l notin names ( G ) :: :: CtxLblNotIn :: CtxLblNotIn_ by

defn
fresh x :: :: FreshVar :: FreshVar_ by

defn
fresh l :: :: FreshLbl :: FreshLbl_ by

defn
fresh h :: :: FreshHole :: FreshHole_ by

defn
type_assign in G :: :: CtxTyAssignIn :: CtxTyAssignIn_ by

defn
positive ( G ) :: :: CtxPos :: CtxPos_ by

defn
mode_cond :: :: ModeCond :: ModeCond_ by

defns
Eq :: '' ::=

defn
A1 = A2 :: :: EqType :: EqType_ by
defn
A1 != A2 :: :: NeqType :: NeqType_ by
defn
t = u :: :: EqTerm :: EqTerm_ by
defn
t != u :: :: NeqTerm :: NeqTerm_ by
defn
G1 = G2 :: :: EqCtx :: EqCtx_ {{ tex [[G1]] = [[G2]] }} by
defn
G1 disjoint G2 :: :: DisjointCtx :: DisjointCtx_ {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }} by

defns
Ty :: '' ::=

% Une dest qui parait plus vieille qu'elle ne l'est réellement (donc qui aurait une date de naissance plus petite que la vraie) peut fuiter dans le scope parent en étant utilisée comme valeur stockée. C'est un problème immédiat, qui doit être étendu à tout conteneur qui contiendrait une telle dest => Date de naissance d'un truc = max de la date de naissance de ses composants

% Une dest qui parait plus jeune qu'elle ne l'est pourrait servir à faire fuiter une dest dans le scope parent, mais impossible tant que son type ne change pas -> aucun problème à prendre le max des dates de naissance.
defn
G |- S | t : A :: :: TyCmd :: TyCmd_ by

G1 |- S
G2 |- t : A
------------------ :: Cmd
G1 µ+ G2 |- S | t : A


defn
G |- S :: :: TyHeap :: TyHeap_ by

------------------ :: Empty
{} |- {}

G1 |- S1
G2 |- S2
------------------- :: Union
G1 µ+ G2 |- S1 µ S2

% left side isn't allowed to contain holes
% right side can contain both holes and destinations
G1 |- v1 : A1
G2 |- w2 : A2
G3 = G1 µ+ G2
positive(G3)
------------------ :: ClosedAmpar
G3 µ { - l : A1 ><| A2 } |- { l -> < v1 ¤ w2 > }

G2 |- w2 : A2
------------------ :: OpenAmpar
G2 |- { l -> < [] ¤ w2 > }

defn
G |- j : A :: :: TyTerm :: TyTerm_ by

---------------- :: Ampar
{ + l : A } |- l : A

---------------- :: Dest
{ + h : A } |- @h : Dest A

--------------------- :: Hole
{ - h : A } |- h : A

---------------- :: Unit
{} |- () : 1

G |- w : A1
---------------- :: Inl
G |- Inl w : A1 + A2

G |- w : A2
---------------- :: Inr
G |- Inr w : A1 + A2

G1 |- w1 : A1
G2 |- w2 : A2
----------------- :: Prod
G1 µ G2 |- ( w1, w2 ) : A1 * A2

G µ { x : m1 A1 } |- t : A2
----------------- :: Lambda
G |- \x -> t : m1 A1 --o A2

G1 |- t : m1 A1 --o A2
G2 |- u : A1
m1 in upper_modes(G2)
----------------- :: App
G1 µ G2 |- t u : A2

G1 |- t : 1
G2 |- u : B
----------------- :: PatUnit
G1 µ G2 |- t ; u : B

G1 |- t : A1 + A2
exists m in upper_modes (G1)
G2 µ { x1 : m A1 } |- u1 : B
G2 µ { x2 : m A2 } |- u2 : B
----------------- :: PatSum
G1 µ G2 |- t & \case { Inl x1 -> u1 , Inr x2 -> u2 } : B

G1 |- t : A1 * A2
exists m in upper_modes (G1)
G2 µ { x1 : m A1, x2 : m A2 } |- u : B
----------------- :: PatProd
G1 µ G2 |- t & \case ( x1 , x2 ) -> u : B

G1 |- t : A1 ><| A2
% ensures that we cannot capture dests of different scopes (G2)
exists m' in upper_modes(G1 µ G2)
m = if _F in upper_modes(G1) then _F else _L
G2[ _L -> _F ] µ { x : m A1 } |- u : B
-------------------------------- :: MapAmpar
G1 µ G2 |- t <&> \ x -> u : B ><| A2

-------------------------------- :: Alloc
{} |- alloc : Dest A ><| A

G |- t : A
------------------------------- :: ToAmpar
G |- toAmpar t : 1 ><| A

G |- t : 1 ><| A
------------------------------- :: FromAmpar
G |- fromAmpar t : A

G |- t : Dest 1
------------------------------ :: FillUnit
G |- t <| () : 1

G |- t : Dest (A1 + A2)
------------------------------ :: FillInl
G |- t <| Inl : Dest A1

G |- t : Dest (A1 + A2)
------------------------------ :: FillInr
G |- t <| Inr : Dest A2

G |- t : Dest (A1 * A2)
------------------------------ :: FillProd
G |- t <| (,) : Dest A1 * Dest A2

G1 |- t : Dest A2
G2 |- u : A1 ><| A2
_L in upper_modes(G1)
_F in upper_modes(G2)
----------------------------- :: FillCompL
G1 µ G2 |- t <|. u : A1

G1 |- t : Dest A2
G2 |- u : A1 ><| A2
_F in upper_modes(G1)
_G in upper_modes(G2)
----------------------------- :: FillCompF
G1 µ G2 |- t <|. u : A1

defns
Sem :: '' ::=

defn
S | t !! S' | t' :: :: BigStep :: BigStep_ by

------------------ :: Val
S0 | v !! S0 | v

S0 | t1 !! S1 | \x -> u
S1 | t2 !! S2 | v2
S2 | u[x := v2] !! S3 | v3
------------------ :: App
S0 | t1 t2 !! S3 | v3

S0 | t1 !! S1 | ()
S1 | t2 !! S2 | v2
----------------------- :: PatUnit
S0 | t1 ; t2 !! S2 | v2

S0 | t !! S1 | Inl v1
S1 | u1[x1 := v1] !! S2 | v2
----------------------- :: PatInl
S0 | t & \case { Inl x1 -> u1, Inr x2 -> u2 } !! S2 | v2

S0 | t !! S1 | Inr v1
S1 | u2[x2 := v1] !! S2 | v2
----------------------- :: PatInr
S0 | t & \case { Inl x1 -> u1, Inr x2 -> u2 } !! S2 | v2

S0 | t !! S1 | (v1,v2)
S1 | u[x1 := v1, x2 := v2] !! S2 | v2
----------------------- :: PatProd
S0 | t & \case (x1,x2) -> u !! S2 | v2

S0 | t !! S1 µ { l -> < v1 ¤ w2 > } | l
S1 µ { l -> < [] ¤ w2 > } | u[x := v1] !! S2 µ { l -> < [] ¤ w4 > } | v3
---------------------------------- :: MapAmpar
S0 | t <&> \ x -> u !! S2 µ { l -> < v3 ¤ w4 > } | l

fresh h
fresh l
-------------------------- :: Alloc
S0 | alloc !! S0 µ { l -> < @h ¤ h > } | l

S0 | t !! S1 | v
fresh l
----------------------------------------- :: ToAmpar
S0 | toAmpar t !! S1 µ { l -> < () ¤ v > } | l

S0 | t !! S1 µ { l -> < () ¤ v > } | l
-------------------------------------- :: FromAmpar
S0 | fromAmpar t !! S1 | v

S0 | t !! S1 | @h
------------------------------------- :: FillUnit
S0 | t <| () !! S1[h := ()] | ()

S0 | t !! S1 | @h
fresh h'
--------------------------------------- :: FillInl
S0 | t <| Inl !! S1[h := Inl h'] | @h'

S0 | t !! S1 | @h
fresh h'
--------------------------------------- :: FillInr
S0 | t <| Inr !! S1[h := Inr h'] | @h'

S0 | t !! S1 | @h
fresh h1
fresh h2
--------------------------------------- :: FillProd
S0 | t <| (,) !! S1[h := (h1,h2)] | (@h1, @h2)

S0 | t !! S1 | @h
S1 | u !! S2 µ { l -> <v1 ¤ w2> } | l
---------------------------------------- :: FillComp
S0 | t <|. u !! S2[h := w2] | v1

parsing
Ty_Prod <= Ty_Dest
Ty_Sum <= Ty_Dest
Ty_Ampar <= Ty_Dest
