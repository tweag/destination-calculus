% minimal + latex + comments

embed
{{ tex-preamble
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{lbcolor}{RGB}{186, 58, 7}
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\mathsf{#1} }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\ottlb}[1]{\textcolor{lbcolor}{\mathit{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle indent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\heaparrow\hookrightarrow
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}

}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar metavariable, x, xs, y, z, uf, f, d ::=
  {{ tex \ottmv{[[metavariable]]} }}

% indexvar index, i ::=
%   {{ tex \textcolor{red}{[[index]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | x                                       ::   :: Var      {{ com variable }}
  | v :: :: Val {{ com value }}
  | t u                                    ::   :: App      {{ com application }}
  | t ; u                   ::   :: PatU     {{ com pattern-matching on unit }}
  | case t of { 1. x1 -> u1 , 2. x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
  | case t of { Nil -> u1 , x1 Cons x2 -> u2 } :: :: PatL {{ com pattern-matching on list }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on exponentiated value }}
  | alloc d A { t }                                   ::   :: Alloc    {{ com allocate data }} {{ tex \underset{\ottty{\lfloor[[A]]\rfloor \rightarrow [[A]]} }{\ottkw{alloc}~[[d]]}\,\textbf{.}\,[[t]] }}
  | t |> fillLeaf u                            ::   :: FillL    {{ com fill terminal-type destination }} {{ tex [[t]]\,\triangleleft\,[[u]] }}
  | t |> fillLeft d' { u }                          ::   :: FillV1   {{ com fill sum-type destination with variant 1 }} {{ tex [[t]]\,\triangleleft\,\ottcons{1.} [[d']]~;~[[u]] }}
  | t |> fillRight d' { u }                          ::   :: FillV2   {{ com fill sum-type destination with variant 2 }} {{ tex [[t]]\,\triangleleft\,\ottcons{2.} [[d']]~;~[[u]] }}
  | t |> fillPair d1 d2 { u }                              ::   :: FillP    {{ com fill product-type destination }} {{ tex [[t]]\,\triangleleft\,\langle [[d1]] , [[d2]] \rangle~;~[[u]] }}
  | t |> fillNil                               ::   :: FillNil {{ com fill list destination with nil }} {{ tex [[t]]\,\triangleleft\,[[Nil]] }}
  | t |> fillCons d1 d2 { u }                             ::  :: FillCons {{ com fill list destination with cons }} {{ tex [[t]]\,\triangleleft\,[[d1]] [[Cons]] [[d2]]~;~[[u]] }}
  | * l :: :: Deref {{ com note: $\ottlb{\star l}$ is not a part of the user syntax }}
  | ( t )                                   :: S :: Paren
  | b sp t b spe :: S :: BreakSpacing1
  | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ var_subs ]                             :: M :: Sub
%  | t [ x |> x' ]                            :: M :: Alpha
  | foldl t1 t2 t3 :: :: FoldL {{ com TODO: hide }}

var_sub, vs :: 'vs_' ::= {{ com variable substitution }}
  | x := t :: :: VarSub

var_subs :: 'vss_' ::= {{ com variable substitutions }}
  | vs :: :: Single
  | vs , var_subs :: :: Multiple

val, v :: 'v_' ::= {{ com unreducible value }}
  | ()                                      ::   :: Unit     {{ com unit }}
  | \ x : A . t                                ::   :: Lam      {{ com lambda abstraction }} {{ tex \lambda\aunderbrace[l1r]{\,[[x]]{:}[[A]]\,}\textbf{.}\,[[t]] }}
  | Ur t :: :: Exp {{ com exponential }}
  | ° l :: :: DerefVal {{ com note: $\ottlb{\ostar l}$ is not a part of the user syntax }}
  | l                                       :: :: Label {{ com note: $[[l]]$ is not a part of the user syntax }}

label, l :: 'l_' ::= {{ com label }} {{ tex \ottlb{[[label]]} }}

label_stmt, s :: 's_' ::= {{ com label statement }}
  | l .> 1. l' :: :: V1
  | l .> 2. l' :: :: V2
  | l .> < l1 , l2 > :: :: P
  | l .> Nil :: :: Nil
  | l .> l1 Cons l2 :: :: Cons
  | l .> null :: :: Null
  | l .> v :: :: Val
  | l .> C lbar :: M :: Generic {{ tex [[l]] \heaparrow [[C]] \ottlb{\bar{l} } }} {{ com TODO: hide. $[[l]] \heaparrow [[C]] \ottlb{\bar{l} }$ is an alias for any heap constructor }}

label_stmts :: 'ss_' ::= {{ com label statements }}
  | s :: :: Single
  | s , label_stmts :: :: Multiple

heap_context, H {{ tex \mathbb{H} }} :: 'h_' ::= {{ com label statements }}
  | empty :: :: Empty
  | { label_stmts } :: :: Stmts
  | H1 µ H2 :: :: Union

type, A, B :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{1} }}
%  | P :: :: Prim {{ com primitive type }}
  | A * B :: :: Prod {{ com product type }} {{ tex \ottty{[[A]] \otimes [[B]]} }}
  | A + B :: :: Sum {{ com sum type }}
  | A --o B :: :: LinArr {{ com linear function type }}
  | | A | :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[A]] \rfloor} }}
  | [ A ] :: :: List {{ com list type }} {{ tex \ottty{[[A]]^\star } }}
  | ! A :: :: Exp {{ com exponential }} {{ tex \ottty{![[A]]} }}
  | ( A )  :: S :: Paren {{ tex \ottty{([[A]])} }}

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : A ::  :: Var {{ com var }}
  | l : A :: :: Label {{ com label }}
  | l bar : A bar :: :: LabelBar {{ tex \ottlb{\bar{[[l]]} } : \ottty{\bar{[[A]]} } }} {{ com labels }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, G {{ tex \Gamma }}, D {{ tex \Delta }}, U {{ tex \mho }}, P {{ tex \Phi }} :: 'G_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var
  | G µ D    ::    :: Union

types, Abar {{ tex \ottty{\bar{A} } }} :: 'tys_' ::= {{ tex \ottty{[[types]]} }}
  | none :: :: None {{ tex \ottty{\bullet} }} {{ com empty type list }}
  | A :: :: Single
  | A types :: :: Multiple {{ tex [[A]]~~[[types]] }}

spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
  | s :: :: space1 {{ tex \myspace{1} }}
  | ss :: :: space2 {{ tex \myspace{2} }}
  | sss :: :: space3 {{ tex \myspace{3} }}
  | ssss :: :: space4 {{ tex \myspace{4} }}
  | sssss :: :: space5 {{ tex \myspace{5} }}
  | ssssss :: :: space6 {{ tex \myspace{6} }}

spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
  | se :: :: space1e {{ tex \myspace{1} }}
  | sse :: :: space2e {{ tex \myspace{2} }}
  | ssse :: :: space3e {{ tex \myspace{3} }}
  | sssse :: :: space4e {{ tex \myspace{4} }}
  | ssssse :: :: space5e {{ tex \myspace{5} }}
  | sssssse :: :: space6e {{ tex \myspace{6} }}

heap_constructor, C :: 'hcons_' ::= {{ tex \ottcons{[[heap_constructor]]} }}
  | 1. :: :: V1
  | 2. :: :: V2
  | ( < , > ) :: :: Pair
  | Nil :: :: Nil
  | ( '::' ) :: :: Cons

judg :: 'judg_' ::=
  | P ; U ; G |- H :: :: JtypeH
  | P ; U ; G |- H | t : A :: :: JtypeHT
  | P ; U ; G |- t : A ::  :: JtypeT
  | C : Abar >> A :: :: JtypeC
  | H | t --> H' | t' ::  :: Jop

terminals :: 'terminals_' ::=
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | * :: :: deref {{ tex \ottlb{\star} }}
  | ° :: :: valderef {{ tex \ottlb{\ostar} }}
  | + :: :: sum {{ tex \ottty{\oplus} }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: with {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | ; :: :: lseq {{ tex ~;~ }}
  | /\ :: :: intersection {{ tex \cap }}
  | empty :: :: empty {{ tex \emptyset }}
  | --> :: :: reducesto {{ tex \longrightarrow }}
  | '|>' :: :: renamedto {{ tex \,\triangleright\, }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
%   | subto :: :: subto {{ tex \underset{[:=]}{\rightarrow} }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | 1. :: :: v1 {{ tex \ottcons{1.} }}
  | 2. :: :: v2 {{ tex \ottcons{2.} }}
  | Nil :: :: nil {{ tex \ottcons{Nil} }}
  | Cons :: :: cons {{ tex {:}\!{:} }}
  | Ur :: :: ur {{ tex \ottcons{Ur}\, }}
%  | ++ :: :: concat {{ tex {\small{+}\mspace{-6mu}{+} } }}
%  | <- :: :: affect {{ tex \leftarrow }}
  | .> :: :: pointsto {{ tex \heaparrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | null :: :: null {{ tex \oslash }}
  | >> :: :: consarrow {{ tex \ottty{\consarrow} }}

defns
JMvar :: '' ::=

% defn
% x != y :: :: JMVarNeq :: JMVar_ {{ com $[[x]]$ and $[[y]]$ stands for different variables }} by

defn
x notin free ( t ) :: :: JMVarNFree :: JMVar_ {{ com $[[x]]$ is not a free variable in $[[t]]$ }} by

defn
x in free ( t ) :: :: JMVarFree :: JMVar_ {{ com $[[x]]$ is a free variable used in $[[t]]$ }} by

defns
Jctx :: '' ::=

defn
names ( G ) /\ names ( D ) = empty :: :: Jctxd :: Jctx_ {{ com $[[G]]$ and $[[D]]$ are disjoint typing contexts with no clashing variable names or labels }} by

defns
Jtype :: '' ::=

defn
P ; U ; G |- H :: :: JtypeH :: JtypeH_ {{ com $[[H]]$ is a well-typed heap given heap typing context $[[P]]$, unrestricted typing context $[[U]]$ and linear typing context $[[G]]$ }} by

P1 ; U ; G |- H1
P2 ; U ; D |- H2
names(P1) /\ names(P2) = empty
names(G) /\ names(D) = empty
------------------ :: Union
P1 µ P2 ; U ; G µ D |- H1 µ H2

C : Abar >> A
P µ { l bar : A bar } ; U ; G |- H
------------------ :: Constructor
P µ { l bar : A bar, l : A } ; U ; G |- H µ { l .> C lbar }

------------------- :: Null
{ l : A } ; U ; empty |- { l .> null }

P ; U ; G |- v : A
------------------- :: Val
P µ { l : A } ; U ; G |- H µ { l .> v }

defn
P ; U ; G |- H | t : A :: :: JtypeHT :: JTypeHT_ by

P ; U ; G |- H
P ; U ; D |- t : A
names(G) /\ names(D) = empty
-------------------------------- :: Def
P ; U ; G |- H | t : A

defn
P ; U ; G |- t : A :: :: JtypeT :: JtypeT_ {{ com $[[t]]$ is a well-typed term of type $[[A]]$ given heap typing context $[[P]]$, unrestricted typing context $[[U]]$ and linear typing context $[[G]]$ }} by

--------------- :: Id
P ; U ; { x : A } |- x : A

--------------- :: Id'
P ; U µ { x : A} ; empty |- x : A

---------------- :: Unit
P ; U ; empty |- () : 1


P ; U ; G µ { x : A } |- t : B
----------------------- :: Lam
P ; U ; G |- \x:A.t : A --o B

P ; U ; G |- t : A --o B
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
--------------------------------- :: App
P ; U ; G µ D |- t u : B

P ; U ; G |- t : 1
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatU
P ; U ; G µ D |- t ; u : A
%U ; G µ D |- case t of { () -> u } : A

P ; U ; G |- t : A1 * A2
P ; U ; D µ { x1 : A1 , x2 : A2 } |- u : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatP
P ; U ; G µ D |- case t of {<x1, x2> -> u} : B

P ; U ; G |- t : A1 + A2
P ; U ; D µ { x1 : A1 } |- u1 : B
P ; U ; D µ { x2 : A2 } |- u2 : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatS
P ; U ; G µ D |- case t of { 1. x1 -> u1 , 2. x2 -> u2 } : B

P ; U ; G |- t : [A]
P ; U ; D |- u1 : B
P ; U ; D µ { x1 : A , x2 : [A] } |- u2 : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatL
P ; U ; G µ D |- case t of { Nil -> u1 , x1 Cons x2 -> u2 } : B

P ; U ; G |- t : !A
P ; U µ { x : A } ; D |- u: B
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatE
P ; U ; G µ D |- case t of { Ur x -> u } : B

P ; U ; G µ { d : |A| } |- t : 1
------------------------------ :: Alloc
P ; U ; G |- alloc d A { t } : A

P ; U ; G |- t : |A|
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------- :: FillL
P ; U ; G µ D |- t |> fillLeaf u : 1

P ; U ; G |- t : |A1 + A2|
P ; U ; D µ { d' : |A1| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------- :: FillV1
P ; U ; G µ D |- t |> fillLeft d' { u } : B

P ; U ; G |- t : |A1 + A2|
P ; U ; D µ { d' : |A2| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------- :: FillV2
P ; U ; G |- t |> fillRight d' { u } : B

P ; U ; G |- t : |A1 * A2|
P ; U ; D µ { d1 : |A1| , d2 : |A2| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------------:: FillP
P ; U ; G µ D |- t |> fillPair d1 d2 { u } : B

P ; U ; G |- t : |[A]|
----------------------------------- :: FillNil
P ; U ; G |- t |> fillNil : 1

P ; U ; G |- t : |[A]|
P ; U ; D µ { d1 : |A| , d2 : |[A]| } |- u : B
names( G ) /\ names( D ) = empty
---------------------------------------------------------------- :: FillCons
P ; U ; G µ D |- t |> fillCons d1 d2 { u } : B

P ; U ; empty |- t : A
----------------------- :: Exp
P ; U ; empty |- Ur t : !A

------------------------------------- :: LabelAsDest
P µ { l : A } ; U ; empty |- l : |A|

------------------------------------ :: Deref
P µ { l : A } ; U ; empty |- *l : A

------------------------------------ :: DerefVal
P µ { l : A } ; U ; empty |- °l : A

defn
C : Abar >> A :: :: JtypeC :: JtypeC_ {{ com Heap constructor $[[C]]$ builds a value of type $[[A]]$ given arguments of type $[[Abar]]$ }} by

-------------------  :: V1
1. : A >> A + B

----------------------- :: V2
2. : B >> A + B

--------------------------- :: Pair
(<,>) : A B >> A * B

------------------------ :: Nil
Nil : none >> [A]

------------------------- :: Cons
(::) : A [A] >> [A]

defns
Jop :: '' ::=

defn
H | t --> H' | t' :: :: reduce :: Jop_ {{ com $[[t]]$ reduces to $[[t']]$, with heap changing from $[[H]]$ to $[[H']]$ }} by

H | t --> H' | t'
------------------- :: UnderApp
H | t u --> H' | t' u

---------------------------- :: App
H | (\x:A.t) u --> H | t[x := u]

H | t --> H' | t'
--------------------------------------------- :: UnderPatU
H | t ; u --> H' | t' ; u
%case t of {() -> u} --> case t' of {() -> u}

--------------------- :: PatU
H | () ; u --> H | u

---------------------------------- :: DerefVal
H µ { l .> v } | *l --> H µ { l .> v } | v

---------------------------------- :: DerefConstructor
H µ { l .> C lbar } | *l --> H µ { l .> C lbar } | °l

H | t --> H' | t'
------------------------------------------------------------------------------- :: UnderPatS
H | case t of {1. x1 -> u1, 2. x2 -> u2} --> H' | case t' of {1. x1 -> u1, 2. x2 -> u2}

----------------------------------------- :: PatSV1
H µ { l .> 1. l' } | case °l of {1. x1 -> u1, 2. x2 -> u2} --> H µ { l .> 1. l' } | u1[x1 := *l']

----------------------------------------- :: PatSV2
H µ { l .> 2. l' } | case °l of {1. x1 -> u1, 2. x2 -> u2} --> H µ { l .> 2. l' } | u2[x2 := *l']

H | t --> H' | t'
----------------------------------------------------------------------------- :: UnderPatP
H | case t of {<x1,x2> -> u} --> H' | case t' of {<x1,x2> -> u}

-------------------------------------------------------------------------------- :: PatP
H µ { l .> <l1, l2> } | case °l of {<x1,x2> -> u} --> H µ { l .> <l1, l2> } | u[x1 := *l1, x2 := *l2]

H | t --> H' | t'
------------------------------------------------------------------------------------- :: UnderPatL
H | case t of {Nil -> u1, x1 Cons x2 -> u2} --> H' | case t' of {Nil -> u1, x1 Cons x2 -> u2}

----------------------------------------------------------------------- :: PatLNil
H µ { l .> Nil } | case °l of {Nil -> u1, x1 Cons x2 -> u2} --> H µ { l .> Nil } | u1

----------------------------------------------------------------------- :: PatLCons
H µ { l .> l1 Cons l2 } | case °l of {Nil -> u1, x1 Cons x2 -> u2} --> H µ { l .> l1 Cons l2 } | u2[x1 := *l1, x2 := *l2]

H | t --> H' | t'
------------------------------------------------------------------------------------- :: UnderPatE
H | case t of {Ur x -> u} --> H' | case t' of {Ur x -> u}

----------------------------------------------------- :: PatE
H | case Ur t of { Ur x -> u } --> H | u[x := t]

--------------------------------------------------- :: Alloc
H | alloc d A { t } --> H µ { l .> null } | t[d := l] ; *l

H | t --> H' | t'
------------------------------------- :: UnderFillL
H | t |> fillLeaf u --> H' | t' |> fillLeaf u

H | t --> H' | t'
------------------------------------- :: UnderFillL'
H | l |> fillLeaf t --> H' | l |> fillLeaf t'

H | t --> H' | t'
------------------------------------- :: UnderFillV1
H | t |> fillLeft d' {u} --> H' | t' |> fillLeft d' {u}

H | t --> H' | t'
------------------------------------- :: UnderFillV2
H | t |> fillRight d' {u} --> H' | t' |> fillRight d' {u}

H | t --> H' | t'
------------------------------------- :: UnderFillP
H | t |> fillPair d1 d2 {u} --> H' | t' |> fillPair d1 d2 {u}

H | t --> H' | t'
------------------------------------- :: UnderFillNil
H | t |> fillNil --> H' | t' |> fillNil

H | t --> H' | t'
------------------------------------- :: UnderFillCons
H | t |> fillCons d1 d2 {u} --> H' | t' |> fillCons d1 d2 {u}

------------------------------------------------------------ :: FillL
H µ { l .> null } | l |> fillLeaf v --> H µ { l .> v } | ()

------------------------------------------------------------ :: FillV1
H µ { l .> null } | l |> fillLeft d' { t } --> H µ { l .> 1. l', l' .> null } | t[d' := l']

------------------------------------------------------------ :: FillV2
H µ { l .> null } | l |> fillRight d' { t } --> H µ { l .> 2. l', l' .> null } | t[d' := l']

----------------------------------------------- :: FillP
H µ { l .> null } | l |> fillPair d1 d2 { t } --> H µ { l .> <l1, l2> , l1 .> null, l2 .> null } | t[d1 := l1, d2 := l2]

----------------------------------------------- :: FillNil
H µ { l .> null } | l |> fillNil --> H µ { l .> Nil } | ()

----------------------------------------------------- :: FillCons
H µ { l .> null } | l |> fillCons d1 d2 { t } --> H µ { l .> l1 Cons l2 , l1 .> null, l2 .> null } | t[d1 := l1, d2 := l2]

embed
{{ tex

% \textbf{Definition: Heap typing}

% We say that $[[H]]$ is a well-typed heap given typing contexts $[[P]], [[U]], [[G]]$ and we write $[[P ; U ; G |- H]]$ if:
% \begin{itemize}
%   \item $\mathsf{labels}([[H]]) = \mathsf{labels}([[P]])$
%   \item $\forall ([[l]] \heaparrow \ottcons{C\,} \bar{[[l]]}) \in [[H]],\quad \bar{[[l]]}:\bar{[[A]]} \in [[P]] ~\land~ [[C : Abar >> A]] ~\land~ [[l : A]] \in [[P]]$
%   \item $\forall ([[l]] \heaparrow [[null]]) \in [[H]],\quad \exists [[A]].~~[[l : A]] \in [[P]]$
%   \item $\forall ([[l]] \heaparrow [[v]]) \in [[H]],\quad [[P ; U ; G |- v : A]] ~\land~ [[l : A]] \in [[P]]$
% \end{itemize}

% \textbf{Theorem: Progress}

% \newcommand{\JtypeT}[1]{\textsc{JtypeT\_#1} }
% \newcommand{\Jop}[1]{\textsc{Jop\_#1} }
% \newcommand{\TODO}[1]{\textcolor{red}{$\langle$TODO: #1$\rangle$} }
% \newcommand{\is}{\overset{\mathit{is} }{=} }

% Suppose $[[t]]$ is a closed, well-typed term (that is, $[[ P ; empty ; empty |- t : A ]]$). Then $[[t]]$ is a value or there are $[[t']]$ and $[[H']]$ such as $[[ H | t --> H' | t' ]]$.

% Let's focus on the last derivation of the typing tree of $[[t]]$:

% \begin{itemize}


% \item It can be neither \JtypeT{Id} nor \JtypeT{Id'}, because no variable can type with both typing contexts being empty.

% \item If it's \JtypeT{Unit}, then $[[t]]$ is a value.
% \item If it's \JtypeT{Lam}, then $[[t]]$ is a value.
% \item If it's \JtypeT{Exp}, then $[[t]]$ is a value.

% \item If it's \JtypeT{App}, then there are $[[t']]$, $[[u]]$ such as $[[t]] \is [[t' u]]$. In addition, there is a type $[[B]]$ such as $[[P ; empty ; empty |- t' : B --o A]].

% Either $[[t']]$ is a value, in which case:

% \begin{itemize}
%     \item $[[t']]$ can be neither $[[()]]$ nor $[[Ur t'']]$ ;
%     \item if $[[t']] \is [[\ x:B. t'']]$, then $[[t' u]]$ can be reduced via \Jop{App} ;
%     \item otherwise, $[[t']]$ is of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
% \end{itemize}

% or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderApp}.

% \item If it's \JtypeT{PatU}, then there are $[[t']]$, $[[u]]$ such as $[[t]] \is [[t' ; u]]$ and $[[P ; empty ; empty |- t' : 1]]$.

% Either $[[t']]$ is a value, in which case:

% \begin{itemize}
%     \item $[[t']]$ can be neither $[[\ x:B. t'']]$ nor $[[Ur t'']]$.
%     \item if $[[t']] \is [[()]]$, then $[[t' ; u]]$ can be reduced via \Jop{PatU} ;
%     \item otherwise, $[[t']]$ is of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
% \end{itemize}

% or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderPatU}.

% \item If it's \JtypeT{PatP}, then there are $[[t']]$, $[[u]]$, $[[x1]]$, $[[x2]]$, $[[B1]]$, $[[B2]]$ such as $[[t]] \is [[case t' of { <x1, x2> -> u }]]$ and $[[P ; empty ; empty |- t' : B1 * B2]]$.

% Either $[[t']]$ is a value, in which case:

% \begin{itemize}
%     \item $[[t']]$ can be none of $[[()]]$, $[[\ x:B'. t'']]$ or $[[Ur t'']]$.
%     \item so $[[t']]$ must be of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
% \end{itemize}

% or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderPatP}.

% \item If it's \JtypeT{PatS}, then there are $[[t']]$, $[[u1]]$, $[[u2]]$, $[[x1]]$, $[[x2]]$, $[[B1]]$, $[[B2]]$ such as $[[t]] \is [[case t' of { 1. x1 -> u1, 2. x2 -> u2 }]]$ and $[[P ; empty ; empty |- t' : B1 + B2]]$.

% Either $[[t']]$ is a value, in which case:

% \begin{itemize}
%     \item $[[t']]$ can be none of $[[()]]$, $[[\ x:B'. t'']]$ or $[[Ur t'']]$.
%     \item so $[[t']]$ must be of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
% \end{itemize}

% or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderPatS}.

% \item If it's \JtypeT{PatL}, then there are $[[t']]$, $[[u1]]$, $[[u2]]$, $[[x1]]$, $[[x2]]$, $[[B]]$ such as $[[t]] \is [[case t' of { Nil -> u1, x1 Cons x2 -> u2 }]]$ and $[[P ; empty ; empty |- t' : [B] ]]$.

% Either $[[t']]$ is a value, in which case:

% \begin{itemize}
%     \item $[[t']]$ can be none of $[[()]]$, $[[\ x:B'. t'']]$ or $[[Ur t'']]$.
%     \item so $[[t']]$ must be of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
% \end{itemize}

% or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderPatL}.

% \item If it's \JtypeT{PatE}, then there are $[[t']]$, $[[u]]$, $[[x]]$, $[[B]]$ such as $[[t]] \is [[case t' of { Ur x -> u }]]$ and $[[P ; empty ; empty |- t' : !B ]]$.

% Either $[[t']]$ is a value, in which case:

% \begin{itemize}
%     \item $[[t']]$ can be neither $[[()]]$ nor $[[\ x:B'. t'']]$ ;
%     \item if $[[t']] \is [[Ur t'']]$, then we can apply \Jop{PatE} ;
%     \item otherwise $[[t']]$ must be of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
% \end{itemize}

% or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderPatE}.

% \end{itemize}

% \bigskip
% \bigskip
\togglespaces

Let's implement $\ottkw{map}$ using $\ottkw{foldl}$ !



\[\begin{array}{l}
\ottkw{map} \defeq [[
\uf: !(A --o B). \xs: [A]. \d0: |[B]|. (
b s (foldl
b ss case uf of { Ur f -> Ur (
b sss \d: |[B]|. \x: A. (d |> fillCons d1 d2 { d1 |> fillLeaf (f x) ; d2 })
b sse )}
b ss d0
b ss xs
) b se |> fillNil)
]]
\end{array}\]
}}


parsing
v_Lam <= t_Sub
t_PatU <= t_App
t_PatU <= t_FillL
