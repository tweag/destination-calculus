% minimal + latex + comments

embed
{{ tex-preamble
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\mathsf{#1} }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle indent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
}}

metavar metavariable, x, y, z, uf, f, l, d, dl, dr, dh, dt ::=
  {{ tex \ottmv{[[metavariable]]} }}

% indexvar index, i ::=
%   {{ tex \textcolor{red}{[[index]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | x                                       ::   :: Var      {{ com variable }}
  | ()                                      ::   :: Unit     {{ com unit }}
  | \ x : A . t                                ::   :: Lam      {{ com lambda abstraction }} {{ tex \lambda\aunderbrace[l1r]{\,[[x]]{:}[[A]]\,}.\,[[t]] }}
  | t u                                    ::   :: App      {{ com application }}
  | u |> t                                    ::   :: RApp      {{ com reverse application }}
  | t ; u                   ::   :: PatU     {{ com pattern-matching on unit }}
  | case t of { 1. x1 -> u1 , 2. x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
  | case t of { Nil -> u1 , x1 Cons x2 -> u2 } :: :: PatL {{ com pattern-matching on list }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on exponentiated value }}
  | alloc A t                                   ::   :: Alloc    {{ com allocate data }} {{ tex \ottkw{alloc}_{[[A]]}\,[[t]] }}
  | fillLeaf u                            ::   :: FillL    {{ com fill terminal-type destination }} {{ tex \ottkw{fill}_{\ottkw{\bullet} }\,[[u]] }}
  | fillLeft                          ::   :: FillV1   {{ com fill sum-type destination with variant 1 }} {{ tex \ottkw{fill}_{\ottcons{1.} } }}
  | fillRight                          ::   :: FillV2   {{ com fill sum-type destination with variant 2 }} {{ tex \ottkw{fill}_{\ottcons{2.} } }}
  | fillPair dl dr { t }                              ::   :: FillP    {{ com fill product-type destination }} {{ tex \ottkw{fill}_{\langle [[dl]] , [[dr]] \rangle}\,\{[[t]]\} }}
  | fillNil                               ::   :: FillNil {{ com fill list destination with nil }} {{ tex \ottkw{fill}_{[[Nil]]} }}
  | fillCons dh dt { t }                             ::  :: FillCons {{ com fill list destination with cons }} {{ tex \ottkw{fill}_{[[dh]] [[Cons]] [[dt]]}\,\{[[t]]\} }}
  | Ur t :: :: Exp {{ com exponential }}
  | ( t )                                   :: S :: Paren
  | b sp t b spe :: S :: BreakSpacing1
  | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ x := u ]                             :: M :: Sub
%  | t [ x |> x' ]                            :: M :: Alpha
  | foldl t1 t2 t3 :: :: FoldL {{ com Built-in foldl function }}

pointer, p :: 'p_' ::= {{ com mutable references }}

spacing, sp :: 'S_' ::= {{ tex \ottsp{[[spacing]]} }}
  | s :: :: space1 {{ tex \myspace{1} }}
  | ss :: :: space2 {{ tex \myspace{2} }}
  | sss :: :: space3 {{ tex \myspace{3} }}
  | ssss :: :: space4 {{ tex \myspace{4} }}
  | sssss :: :: space5 {{ tex \myspace{5} }}
  | ssssss :: :: space6 {{ tex \myspace{6} }}

spacing_end, spe :: 'Se_' ::= {{ tex \ottsp{[[spacing_end]]} }}
  | se :: :: space1e {{ tex \myspace{1} }}
  | sse :: :: space2e {{ tex \myspace{2} }}
  | ssse :: :: space3e {{ tex \myspace{3} }}
  | sssse :: :: space4e {{ tex \myspace{4} }}
  | ssssse :: :: space5e {{ tex \myspace{5} }}
  | sssssse :: :: space6e {{ tex \myspace{6} }}

type, A, B :: 'T_' ::= {{ tex \ottty{[[type]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{1} }}
%  | P :: :: Prim {{ com primitive type }}
  | A * B :: :: Prod {{ com product type }}
  | A + B :: :: Sum {{ com sum type }}
  | A --o B :: :: LinArr {{ com linear function type }}
  | | A | :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[A]] \rfloor} }}
  | [ A ] :: :: List {{ com list type }} {{ tex \ottty{[[A]]^\star } }}
  | ! A :: :: Exp {{ com exponential }} {{ tex \ottty{![[A]]} }}
  | ( A )  :: S :: Paren {{ tex \ottty{([[A]])} }}

context, G {{ tex \Gamma }}, D {{ tex \Delta }}, U {{ tex \mho }} :: 'G_' ::= {{ com typing context }}
  | empty    ::   :: empty
  | { x : A } ::    :: var {{ com variable $[[x]]$ has type $[[A]]$ and must be consumed once }}
  | G µ D    ::    :: pair

terminals :: 'terminals_' ::=
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | * :: :: prod {{ tex \ottty{\otimes} }}
  | + :: :: sum {{ tex \ottty{\oplus} }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: with {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | ; :: :: lseq {{ tex ~;~ }}
  | /\ :: :: intersection {{ tex \cap }}
  | empty :: :: empty {{ tex \emptyset }}
  | --> :: :: reducesto {{ tex \longrightarrow }}
  | '|>' :: :: renamedto {{ tex \,\triangleright\, }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
%   | subto :: :: subto {{ tex \underset{[:=]}{\rightarrow} }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | '1.' :: :: v1 {{ tex \ottcons{1.} }}
  | '2.' :: :: v2 {{ tex \ottcons{2.} }}
  | Nil :: :: nil {{ tex \ottcons{Nil} }}
  | Cons :: :: cons {{ tex {:}\!{:} }}
  | Ur :: :: ur {{ tex \ottcons{Ur}\, }}
  % | dl :: :: dl
  % | dr :: :: dr
  % | dh :: :: dh
  % | dt :: :: dt

defns
JMvar :: '' ::=

% defn
% x != y :: :: JMVarNeq :: JMVar_ {{ com $[[x]]$ and $[[y]]$ stands for different variables }} by

defn
x notin free ( t ) :: :: JMVarNFree :: JMVar_ {{ com $[[x]]$ is not a free variable in $[[t]]$ }} by

defn
x in free ( t ) :: :: JMVarFree :: JMVar_ {{ com $[[x]]$ is a free variable used in $[[t]]$ }} by

defns
Jctx :: '' ::=

defn
names ( G ) /\ names ( D ) = empty :: :: Jctxd :: Jctx_ {{ com $[[G]]$ and $[[D]]$ are disjoint typing contexts with no clashing variable names }} by

defns
Jtype :: '' ::=

defn
U ; G |- t : A :: :: Jtypec :: Jtype_ {{ com $[[t]]$ is a well-typed term of type $[[A]]$ given unrestricted typing context $[[U]]$ and linear typing context $[[G]]$ }} by

--------------- :: Id
U ; { x : A } |- x : A

--------------- :: Id'
U µ { x : A} ; empty |- x : A

---------------- :: Unit
U ; empty |- () : 1


U ; G µ { x : A } |- t : B
----------------------- :: Lam
U ; G |- \x:A.t : A --o B

U ; G |- t : A --o B
U ; D |- u : A
names( G ) /\ names( D ) = empty
--------------------------------- :: App
U ; G µ D |- t u : B

U ; G |- t : A --o B
U ; D |- u : A
names( G ) /\ names( D ) = empty
--------------------------------- :: RApp
U ; G µ D |- u |> t : B

U ; G |- t : 1
U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatU
U ; G µ D |- t ; u : A
%U ; G µ D |- case t of { () -> u } : A

U ; G |- t : A1 * A2
U ; D µ { x1 : A1 } µ { x2 : A2 } |- u : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatP
U ; G µ D |- case t of {<x1, x2> -> u} : B

U ; G |- t : A1 + A2
U ; D µ { x1 : A1 } |- u1 : B
U ; D µ { x2 : A2 } |- u2 : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatS
U ; G µ D |- case t of { 1. x1 -> u1 , 2. x2 -> u2 } : B

U ; G |- t : [A]
U ; D |- u1 : B
U ; D µ { x1 : A } µ { x2 : [A] } |- u2 : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatL
U ; G µ D |- case t of { Nil -> u1 , x1 Cons x2 -> u2 } : B

U ; G |- t : !A
U µ { x : A } ; D |- u: B
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatE
U ; G µ D |- case t of { Ur x -> u } : B

U ; G |- t : |A| --o 1
------------------- :: Alloc
U ; G |- alloc A t : A

U ; G |- t : A
----------------------------------- :: FillL
U ; G |- fillLeaf t : |A| --o 1

----------------------------------------- :: FillV1
U ; empty |- fillLeft : |A1 + A2| --o |A1|

----------------------------------------- :: FillV2
U ; empty |- fillRight : |A1 + A2| --o |A2|

U ; G µ { dl : |A1| } µ { dr : |A2| } |- t : B
----------------------------------------------:: FillP
U ; G |- fillPair dl dr { t } : |A1 * A2| --o B

----------------------------------- :: FillNil
U ; empty |- fillNil : |[A]| --o 1

U ; G µ { dh : |A| } µ { dt : |[A]| } |- t : B
---------------------------------------------------------------- :: FillCons
U ; G µ D |- fillCons dh dt { t } : |[A]| --o B

U ; empty |- t : A
----------------------- :: Exp
U ; empty |- Ur t : !A

U ; G µ { x : A } |- t : B
U ; D |- u : A
names( G ) /\ names( D ) = empty
--------------------------------- :: Sub
U ; G µ D |- t[x := u] : B

defns
Jop :: '' ::=

defn
t --> t' :: :: reduce :: Jop_ {{ com $[[t]]$ reduces to $[[t']]$ }} by

t --> t'
------------------- :: UnderRApp
u |> t --> t' u

t --> t'
------------------- :: UnderApp
t u --> t' u

---------------------------- :: App
(\x:A.t) u --> t[x := u]

t --> t'
--------------------------------------------- :: UnderPatU
t ; u --> t' ; u
%case t of {() -> u} --> case t' of {() -> u}

t --> t'
------------------------------------------------------------------------------- :: UnderPatS
case t of {1. x1 -> u1, 2. x2 -> u2} --> case t' of {1. x1 -> u1, 2. x2 -> u2}

t --> t'
----------------------------------------------------------------------------- :: UnderPatP
case t of {<x1,x2> -> u} --> case t' of {<x1,x2> -> u}

t --> t'
------------------------------------------------------------------------------------- :: UnderPatL
case t of {Nil -> u1, x1 Cons x2 -> u2} --> case t' of {Nil -> u1, x1 Cons x2 -> u2}

t --> t'
------------------------------------------------------------------------------------- :: UnderPatL
case t of {Ur x -> u} --> case t' of {Ur x -> u}

t --> t'
---------------------------- :: UnderAlloc
alloc A t --> alloc A t'

---------------------------------------------- :: Alloc
alloc A (\d0:|A|. t) --> t <> # d0 : A § { d0:|A| } § [ d0 := alloc A ] #

t --> t'
--------------------------------------- :: UnderMemCtx
t <> # d0 : A § H § I # --> t' <> # d0 : A § H § I #

t --> t'
------------------------------- :: UnderFillL
fillLeaf t --> fillLeaf t'

--------------------------------------------------------------------------- :: FillL
fillLeaf v d <> # d0 : A § H µ { d : |B| } § I # --> 1 <> # d0 : A § H § I ++ [d <- v] #

----------------------------------------------------------------------------------------------------------------------- :: FillV1
fillLeft d <> # d0 : A § H µ { d : |B1 + B2| } § I # --> # d0 : A § H µ {d': |B1|} § I ++ [ d' := alloc B1 ; d <- 1. d' ] #

------------------------------------------------------------------------------------------------------------------------ :: FillV2
fillRight d <> # d0 : A § H µ { d : |B1 + B2| } § I # --> # d0 : A § H µ {d': |B2|} § I ++ [ d' := alloc B2 ; d <- 2. d' ] #

----------------------------------------------- :: FillP
fillPair dl dr { t } d <> # d0 : A § H µ { d : |B1 * B2| } § I # --> t <> # d0 : A § H µ { dl : |B1| } µ { dr : |B2| } § I ++ [ dl := alloc B1 ; dr := alloc B2 ; d <- <dl, dr> ] #

----------------------------------------------- :: FillNil
fillNil d <> # d0 : A § H µ { d : |[B]| } § I # --> 1 <> # d0 : A § H § I ++ [ d <- Nil ] #

----------------------------------------------------- :: FillCons
fillCons dh dt { t } d <> # d0 : A § H µ { d : |[B]| } § I # --> t <> # d0 : A § H µ { dh: |B| } µ { dt: |[B]| } § I ++ [ dh := alloc B ; dt := alloc [B] ; d <- dh :: dt ]

----------------------------------------------------------- :: FinishAlloc
1 <> # d0 : A § {} § I # --> execAndReturn I d0

embed
{{ tex
\togglespaces

Let's implement $\ottkw{map}$ using $\ottkw{foldl}$ !


%  (case uf of { Ur f -> Ur (\d': |[B]|. \x: A. d' |> fillCons dh dt { dh |> fillLeaf (f x) ; dt })})

\[\begin{array}{l}
\ottkw{map} \defeq [[
\uf: !(A --o B). \l: [A]. \d: |[B]|.
b s foldl
b ss case uf of { Ur f -> Ur (
b sss \d': |[B]|. \x: A. d' |> fillCons dh dt { dh |> fillLeaf (f x) ; dt }
b sse )}
b ss d
b ss l
b se |> fillNil
]]
\end{array}\]
}}


parsing
t_Lam <= t_Sub
t_Lam <= t_RApp
% t_Lam <= t_Alpha
t_PatU <= t_Lam
t_PatU <= t_RApp
t_PatU <= t_App
t_PatU <= t_FillL
t_PatU <= t_FillV1
t_PatU <= t_FillV2
t_PatU <= t_FillNil


% defns
% Jsub :: '' ::=

% defn
% t subto t' :: :: sub :: Jsub_ {{ com recursive definition of substitution function }} by

% -------------------- :: IdEq
% x[x := u] subto u

% x != y
% -------------------- :: IdNeq
% y[x := u] subto y

% -------------------- :: Unit
% ()[x := u] subto ()

% -------------------------------------------------- :: LamEq
% (\x:A.t)[x := u] subto \x:A.t

% x != y
% y notin free(u)
% ---------------------------------------------------- :: LamNeq1
% (\y : A. t)[x := u] subto \y : A. t[x := u]

% x != y
% y in free(u)
% x != z
% y != z
% z notin free(t)
% z notin free(u)
% -------------------------------------------------------- :: LamNeq2
% (\y : A . t)[x := u] subto (\z : A. t[y |> z])[x := u]

% -------------------------------------------- :: App
% (t1 t2)[x := u] subto t1[x := u] t2[x := u]

% ------------------------------------------------ :: PatU
% (t1 ; t2)[x := u] subto t1[x := u] ; t2[x := u]

% -------------------------------------------------------------------------------------- :: PatP
% (case t of {(y1, y2) -> t'})[x := u] subto case t[x := u] of {<y1, y2> -> t'[x := u]}

% -------------------------------------------------------------------------------------------------------------- :: PatS
% (case t of {1.y1 -> t1, 2.y2 -> t2})[x := u] subto case t[x := u] of {1.y1 -> t1[x := u], 2.y2 -> t2[x := u]}

% ------------------------------------------------------------------------------------------------------------------------ :: PatL
% (case t of {Nil -> t1, Cons y1 y2 -> t2})[x := u] subto case t[x := u] of {Nil -> t1[x := u], Cons y1 y2 -> t2[x := u]}

% ----------------------------------------- :: Alloc
% (alloc t)[x := u] subto alloc t[x := u]

% ------------------------------------------------------------- :: FillL
% (fillLeaf t2 t1)[x := u] subto fillLeaf t2[x := u] t1[x := u]

% -------------------------------------------------:: FillV1
% (fillLeft t)[x := u] subto fillLeft t[x := u]

% -----------------------------------------------:: FillV2
% (fillRight t)[x := u] subto fillRight t[x := u]

% --------------------------------------------- :: FillP
% (fillPair t)[x := u] subto fillPair t[x := u]

% ----------------------------------------------- :: FillNil
% (fillNil t)[x := u] subto fillNil t[x := u]

% ----------------------------------------------- :: FillCons
% (fillCons t)[x := u] subto fillCons t[x := u]
