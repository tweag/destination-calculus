% minimal + latex + comments

embed
{{ tex-preamble
\usepackage{stmaryrd}
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{multcolor}{RGB}{26, 87, 186}
\definecolor{holecolor}{RGB}{186, 58, 7}
\definecolor{effcolor}{RGB}{186, 58, 7}
\definecolor{kwcolor}{RGB}{0, 0, 0}
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\textcolor{kwcolor}{\mathsf{#1} } }
\newcommand{\ottdefault}[1]{\textcolor{black}{\mathsf{#1} } }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\ottho}[1]{\textcolor{holecolor}{#1 } }
\newcommand{\otteff}[1]{\textcolor{effcolor}{#1 } }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\ottmult}[1]{\textcolor{multcolor}{\mathit{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle destent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\storearrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyStore}[1]{\textsc{TyStore\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\small\itshape #1} }
\newcommand{\holearrowgen}[1]{\ottho{\text{#1}\!\!\!\rightharpoonup} } % 
\def\restriction#1#2{\mathchoice
              {\setbox1\hbox{${\displaystyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\textstyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptscriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} } }
\def\restrictionaux#1#2{ {#1\,\smash{\vrule height .8\ht1 depth .85\dp1} }_{\,#2} }
\usepackage[safe]{tipa}
\newcommand{\mpar}{\ottty{\text{\large\textramshorns} } }
\newcommand{\mparcomma}{ {\scriptstyle\odot} }
\newcommand{\expc}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{-.1ex}{\hspace{-0.4ex}\scriptsize c} } }\hspace{-0.7ex} }
\newcommand{\expw}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{0.05ex}{\hspace{-0.6ex}${\scriptscriptstyle\omega}$} } }\hspace{-0.7ex} }
\newcommand{\putarrow}[1]{\!\overset{#1}{\prec}\!}
\newcommand{\lam}[3]{\lambda\,#1\!:\!#2\,\textbf{.}\,#3}
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar metavariable, x, y ::=
  {{ tex \ottmv{[[metavariable]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | v :: :: Val {{ com value }}
  | t u                                    ::   :: App      {{ com application }}
%  | t ; u :: :: EffSeq {{ com effect sequencing }} {{ tex [[t]] \,\fatsemi\, [[u]] }}
%  | case t of { C x -> u } :: :: PatC {{ com pattern-matching on linear complete value }}
  | case t of { * -> u }                   ::   :: PatU {{ com pattern-matching on unit }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on unrestricted complete value }}
  | case t of { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { @ R x -> u } :: :: PatR {{ com pattern-matching on recursive data }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
  | extract t :: :: Ex
  | flip t :: :: FlipM
  | reassoc t :: :: ReassocM
  | redL t :: :: RedLM
  | mapL t with u :: :: MapLM
  | alloc D                                   ::   :: Alloc    {{ com get data from a dest-filling statement }} % {{ tex \underset{\ottty{[[D]]} }{\ottkw{alloc} } }}
  | fillUnit p t :: :: FillU {{ com fill destination with unit }} {{ tex [[t]]~\putarrow{[[p]]}~[[*]] }}
  | fillFn p { \ x : A . u } t :: :: FillFn {{ com fill destination with function }} {{ tex [[t]]~\putarrow{[[p]]}~\lam{[[x]]}{[[A]]}{[[u]]} }}
  | fillLeaf p u t :: :: FillL {{ com fill destination with value }} {{ tex [[t]]~\putarrow{[[p]]}~[[u]] }}
  | fillUr p t :: :: FillE {{ com fill destination with exponential }} {{ tex [[t]]~\putarrow{[[p]]}~[[Ur]] }}
  | fillLeft p t                          ::   :: FillInl   {{ com fill destination with sum variant 1 }} {{ tex [[t]]~\putarrow{[[p]]}~[[Inl]] }}
  | fillRight p t                          ::   :: FillInr   {{ com fill destination with sum variant 2 }} {{ tex [[t]]~\putarrow{[[p]]}~[[Inr]] }}
  | fillRoll p R t :: :: FillR {{ com fill destination with recursive data }} {{ tex [[t]]~\putarrow{[[p]]}~\ottty{[[@]][[R]]} }}
  | fillPair p t                              ::   :: FillP    {{ com fill destination with product }} {{ tex [[t]]~\putarrow{[[p]]}~\ottcons{\langle,\rangle} }}
  | fillMpar p t :: :: FillM {{ tex [[t]]~\putarrow{[[p]]}~\ottcons{\langle\mparcomma\rangle} }}
  | ( t )                                   :: S :: Paren
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ subs ]                             :: M :: Sub

% hole, h :: 'h_' ::= {{ com hole }} {{ tex \ottho{[[hole]]} }}

val, v :: 'v_' ::= {{ com value (unreducible term) }}
  | o :: :: NoEff {{ com empty effect }}
  | d                                       ::   :: Data      {{ com data structure }}

% effect, e :: 'e_' ::= {{ tex \otteff{[[effect]]} }}
%   | o :: :: NoEff
%   | [ subs ] :: :: Sub
%   | e1 . e2 :: :: Concat {{ tex [[e1]] \cdot [[e2]] }}

data, d :: 'd_' ::=
  | | x | :: :: D {{ com destination }} {{ tex \ottmv{\lfloor[[x]]\rfloor} }}
  | x :: :: Var {{ com var or hole }}
  | * ::   :: U {{ com unit }} {{ tex \star }}
  | \ x : A . t :: ::  Fn {{ com lambda abstraction }} {{ tex \lam{[[x]]}{[[A]]}{[[t]]} }}
  | Ur d :: :: E {{ com exponential }}
  | C d :: :: C
  | Inl d :: :: Inl {{ com sum variant 1 }}
  | Inr d :: :: Inr {{ com sum variant 2 }}
  | @ R d :: :: R {{ com recursive data }}
  | < d1 , d2 > :: :: P {{ com product }}
  | < v1 ¤ v2 > :: :: M {{ com mpar }}
  | ( d ) :: S :: Paren

multiplicity, p :: 'mult_' ::= {{ com multiplicity }} {{ tex \ottmult{[[multiplicity]]} }}
  | l :: :: One {{ com for holes/destinations not under a $\ottcons{Ur}$ }} {{ tex \ottmult{1} }}
  | w :: :: Many {{ com for holes/destinations under a $\ottcons{Ur}$ }} {{ tex \ottmult{\omega} }}

sub :: 'sub_' ::= {{ com substitution }}
  | var_sub :: :: VarSub
  % | hole_sub :: :: HoleSub

subs :: 'subs_' ::= {{ com substitutions }}
  | var_subs :: :: VarSubs
  % | hole_subs :: :: HoleSubs

var_sub :: 'vsub_' ::= {{ com variable substitution }}
  | x := v :: :: VarSub

var_subs :: 'vsubs_' ::= {{ com variable substitutions }}
  | var_sub :: :: Single
  | var_sub , var_subs :: :: Multiple

% hole_sub :: 'hsub_' ::= {{ com hole substitution }}
%   | h := v :: :: HoleSub

% hole_subs :: 'hsubs_' ::= {{ com hole substitutions }}
%   | hole_sub :: :: Single
%   | hole_sub , hole_subs :: :: Multiple

% store_affect, sa :: 'sa_' ::= {{ com store cell }}
%   | x : D = dh :: :: StoreVal

% store_affects :: 'sas_' ::= {{ com store cells }}
%   | sa :: :: Single
%   | sa , store_affects :: :: Multiple

% store, S {{ tex \mathbb{S} }} :: 's_' ::=
%   | empty :: :: Empty
%   | { store_affects } :: :: Stmts
%   | S1 µ S2 :: :: Union
%   | S [ subs ] :: M :: Sub

type, A :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
  | _!_ :: :: Bottom {{ com bottom (effect) type }}
  | D :: :: Data

data_type, D :: 'dty_' ::= {{ tex \ottty{[[data_type]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | N :: :: NoDestData
  | R :: :: Rec {{ com recursive type bound to a name }}
  | D1 * D2 :: :: Prod {{ com product type }} {{ tex \ottty{[[D1]]\!\otimes\![[D2]]} }}
  | A1 mpar A2 :: :: Mpar
  | D1 + D2 :: :: Sum {{ com sum type }} {{ tex \ottty{[[D1]]\!\oplus\![[D2]]} }}
  | A1 --o A2 :: :: LinArr {{ com linear function type }}
  | | D | ^ p :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[D]] \rfloor}^{[[p]]} }}
  | !w N :: :: Exp {{ com exponential }}
  | !c D :: :: Comp
  | ( D )  :: S :: Paren {{ tex \ottty{([[D]])} }}
  | DV [ X := D ] :: M :: Sub {{ com unroll a recursive data type }} {{ tex [[DV]]\ottdefault{[} \ottty{X}~\ottdefault{[[:=]]}~\ottty{[[D]]} \ottdefault{]} }}

nodest_data_type, N :: 'nddty_' ::= {{ tex \ottty{[[nodest_data_type]]} }} {{ com Data type with no dest in its tree }}

type_with_var, AV {{ tex \ottty{\underline{A} } }} :: 'tywv_' ::= {{ tex \ottty{[[type_with_var]]} }}
  | _!_ :: :: Bottom
  | DV :: :: Data

data_type_with_var, DV {{ tex \ottty{\underline{D} } }} :: 'dtywv_' ::= {{ tex \ottty{[[data_type_with_var]]} }}
  | X :: :: Var {{ tex \ottty{X} }}
  | 1 :: :: One {{ tex \ottty{[[1]]} }}
  | NV :: :: NoDestData
  | R :: :: Rec
  | DV1 * DV2 :: :: Prod {{ tex \ottty{[[DV1]] \otimes [[DV2]]} }}
  | DV1 + DV2 :: :: Sum {{ tex \ottty{[[DV1]] \oplus [[DV2]]} }}
  | AV1 --o AV2 :: :: LinArr {{ tex \ottty{[[AV1]] [[--o]] [[AV2]]} }}
  | AV1 mpar AV2 :: :: Mpar {{ tex \ottty{[[AV1]] \mpar [[AV2]]} }}
  | | DV | ^ p :: :: Dest {{ tex \ottty{\lfloor [[DV]] \rfloor}^{[[p]]} }}
  | !w NV :: :: Exp
  | !c DV :: :: Comp
  | ( DV )  :: S :: Paren {{ tex \ottty{([[DV]])} }}

nodest_data_type_with_var, NV {{ tex \ottty{\underline{N} } }} :: 'nddtwv_' ::= {{ tex \ottty{[[nodest_data_type_with_var]]} }}

rec_type_bound, R :: 'rtb_' ::= {{ com name for recursive type }} {{ tex \ottty{[[rec_type_bound]]} }}

rec_type_def :: 'rtd_' ::= {{ com recursive type definition }}
  | µ X . DV :: :: Abs {{ tex \mu\,\ottty{X}\,\textbf{.}\,[[DV]] }}

sign, s :: 'sgn_' ::= {{ com sign }}
  | + :: :: Plus
  | - :: :: Minus

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : A ::  :: Var {{ com variable }}
  | - x : ^ p D ::  :: Hole {{ com hole }} {{ tex \ottmv{-}[[x]]:^{[[p]]} [[D]] }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, U {{ tex \mho }}, G {{ tex \Gamma }}, Gn {{ tex \Gamma^- }} :: 'tc_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var
  | G1 µ G2    ::    :: Disjoint
  | G1 µ+ G2 :: :: SDisjoint
  | G1 µ~ G2 :: :: HDisjoint

% command :: 'com_' ::=
%   | S | t :: :: Command {{ tex [[S]]\,|\,[[t]] }}

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

% judg :: 'judg_' ::=
%   | type_affect in G :: :: CtxTypeAffIn
%   | % ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }}
%   | ctxdisjoint3 G1 G2 G3 :: :: CtxDisjoint3 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G1]]) \cap [[names]]([[G3]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G2]]) \cap [[names]]([[G3]]) = \emptyset }}
%   | l in L :: :: LabelSetIn
%   | l notin L :: :: LabelSetNotIn
%   | store_affect in S :: :: StoreAffIn
%   | D is D2 :: :: EqType
%   | t is u :: :: EqTerm
%   | G is D :: :: EqContext
%   | { l <| v' , lbar <| vbar } = deepCopy ( L , v ) :: :: DeepCopyTree {{ tex \{ [[l]] [[<|]] [[v']], [[lbar]] [[<|]] [[vbar]] \} = \mathsf{deepCopy}([[L]], \ottlb{\lfloor[[l]]\rfloor}, [[v]]) }}
%   | R =fix rec_type_def :: :: TyRec
%   | D is destFree :: :: TyDestFree {{ tex \text{$[[D]]$ is destination-free} }}
%   | C : Abar >> D :: :: TyCtor
%   | command !! command' :: :: SemOp

terminals :: 'terminals_' ::=
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: with {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | µ+ :: :: sdunion {{ tex \text{\makebox[0pt][l]{$\sqcup$}\raisebox{.3ex}{\hspace{.18ex}$\scriptscriptstyle+$} } }}
  | µ~ :: :: hdunion {{ tex \text{\makebox[0pt][l]{$\sqcup$}\raisebox{-.7ex}{\hspace{.18ex}\text{\textasciitilde}\!}~\,} }}
  | empty :: :: empty {{ tex \emptyset }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | Inl :: :: v1 {{ tex \ottcons{Inl} }}
  | Inr :: :: v2 {{ tex \ottcons{Inr} }}
  | Ur :: :: ur {{ tex \ottcons{Ur} }}
  | C :: :: c {{ tex \ottcons{C} }}
  | !c :: :: expc {{ tex \expc{} }}
  | !w :: :: expw {{ tex \expw{} }}
  | mpar :: :: mpar {{ tex \mpar{} }}
  | Dest :: :: dest {{ tex \ottcons{Dest}\, }}
  | <| :: :: pointsto {{ tex \storearrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | !! :: :: downto {{ tex \Downarrow }}
  | =fix :: :: fix {{ tex \overset{\mathsf{fix} }{=} }}
  | _!_ :: :: bottom {{ tex \ottty{\bot} }}
  | o :: :: bullet {{ tex \bullet }}
  | includedin :: :: includedin {{ tex \subset }}
  | names :: :: names {{ tex \mathcal{N} }}
  | => :: :: implies {{ tex \implies }}
  | '@' :: :: at {{ tex \ottty{\textsf{@} } }}
  | and :: :: land {{ tex \land }}
  | ';' :: :: sep {{ tex ~{;}~ }}
  | * :: :: unit {{ tex \star }}
  | ¤ :: :: mparcomma {{ tex \mparcomma }}

defns
Ctx :: '' ::=

defn
x in names ( G ) :: :: CtxVarIn :: CtxVarIn_ by

defn
x notin names ( G ) :: :: CtxVarNotIn :: CtxVarNotIn_ by

defn
type_affect in G :: :: CtxTypeAffIn :: CtxTypeAffIn_ by

defn
ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 :: CtxDisjoint2_ {{ com $[[G1]]$~~and~~$[[G2]]$ are disjoint typing contexts with no clashing variable names or labels }} {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }} by

defn
p1 = p2 => G1 = G2 :: :: CtxMultiplicity :: CtxMultiplicity_ by

defn
p1 = p2 => ( G1 = G2 and G3 = G4 ) :: :: CtxMultiplicity2 :: CtxMultiplicity2_ by

defn
fresh x :: :: FreshVar :: FreshVar_ by

% defns
% Store :: '' ::=

% defn
% store_affect in S :: :: StoreAffIn :: StoreAffIn_ by

% defn
% x notin names ( S ) :: :: StoreVarNotIn :: StoreVarNotIn_ by

defns
Eq :: '' ::=

defn
A1 is A2 :: :: EqType :: EqType_ {{ tex [[A1]] = [[A2]] }} by
defn
A1 isnt A2 :: :: NeqType :: NeqType_ {{ tex [[A1]] \neq [[A2]] }} by
defn
t is u :: :: EqTerm :: EqTerm_ {{ tex [[t]] = [[u]] }} by
defn
G is D :: :: EqContext :: EqContext_ {{ tex [[G]] = [[D]] }} by

defns
Ty :: '' ::=

defn
R =fix rec_type_def :: :: TyRec :: TyRec_ by

defn
U ; G |- t : A :: :: TyTerm :: TyTerm_ by

------------------------ :: NoEff
U ; empty |- o : _!_

--------------- :: U
U ; empty |- * : 1

empty ; Gn µ~ { x : A1 } |- t : A2
------------------------------- :: Fn
U ; Gn |- \ x : A1 . t : A1 --o A2

empty ; empty |- d : N
--------------------- :: E
U ; empty |- Ur d : !w N

empty ; Gn |- d : D
--------------------- :: C
U ; Gn |- C d : !c D

empty ; G |- d : D1
-------------------- :: Inl
U ; G |- Inl d : D1 + D2

empty ; G |- d :D2
-------------------- :: Inr
U ; G |- Inr d : D1 + D2

R =fix µX.DV
empty ; G |- d : DV[X := R]
--------------------------------- :: R
U ; G |- @R d : R

empty ; G1 |- d1 : D1
empty ; G2 |- d2 : D2
----------------------- :: P
U ; G1 µ~ G2 |- <d1, d2> : D1 * D2

empty ; G1 |- d1 : D1
empty ; G2 |- d2 : D2
----------------------- :: M
U ; G1 µ+ G1 |- <d1 ¤ d2> : D1 mpar D2

------------------------- :: D
U ; { - x :^p D } |- |x| : |D|^p

------------------------- :: Var
U ; { x : A } |- x : A

--------------- :: Var'
U µ { x : A } ; empty |- x : A

U ; G1 |- t : !c (A1 --o A2)
U ; G2 |- u : A1
--------------------------------- :: App
U ; G1 µ~ G2 |- t u : A2

U ; G1 |- t : !c 1
U ; G2 |- u : A
----------------------------------------- :: PatU
U ; G1 µ~ G2 |- case t of { * -> u } : A

U ; G1 |- t : !c (!w N)
U µ { x : !c N } ; G2 |- u : A
----------------------------------------- :: PatE
U ; G1 µ~ G2 |- case t of { Ur x -> u } : A

x1 notin names(G1)
x2 notin names(G2)
U ; G1 |- t : !c (D1 + D2)
U ; G2 µ~ { x1 : !c D1 } |- u1 : A
U ; G2 µ~ { x2 : !c D2 } |- u2 : A
------------------------------------------------------- :: PatS
U ; G1 µ~ G2 |- case t of { Inl x1 -> u1 , Inr x2 -> u2 } : A

R =fix µ X. DV
x notin names(G1)
U ; G1 |- t : !c R
U ; G2 µ~ { x : !c DV[X := R] } |- u : A
----------------------------- :: PatR
U ; G1 µ~ G2 |- case t of { @R x -> u } : A

x1 notin names(G1)
x2 notin names(G2)
U ; G1 |- t : !c (D1 * D2)
U ; G2 µ~ { x1 : !c D1 , x2 : !c D2 } |- u : A
------------------------------------------------------- :: PatP
U ; G1 µ~ G2 |- case t of {<x1, x2> -> u} : A

U ; G |- t : !c D
--------------------- :: Ex
U ; G |- extract t : D

U ; G |- t : !c (A1 mpar A2)
---------------------------------- :: FlipM
U ; G |- flip t : !c (A2 mpar A1)

U ; G |- t : !c (A1 mpar !c (A2 mpar A3))
---------------------------------- :: ReassocM
U ; G |- reassoc t : !c (!c (A1 mpar A2) mpar A3)

U ; G |- t : !c (_!_ mpar D)
------------------------------ :: RedRM
U ; G |- redL t : !c D

U ; G1 |- t : !c (A1 mpar A2)
U ; G2 |- u : !c (A1 --o A3)
--------------------------------- :: MapRM
U ; G1 µ~ G2 |- mapL t with u : A3 mpar A2

------------------------------- :: Alloc
U ; empty |- alloc D : !c (!c |D|^l mpar D)

% U ; G µ { x : emptyH #- |D|^l } |- t ; x bar : emptyH #- |D bar| ^ p bar
% ------------------------------ :: Alloc
% U ; G |- alloc { x bar -> h bar } D x { t } : {h bar ^ p bar : D bar} #- D

% U ; G1 |- t : G1 µ { h ^p : D' } #- D
% U ; G2 |- u : G2 #- D'
% % ctxdisjoint2 G1 G2
% % ctxdisjoint2 G1 G2
% p = w => G2 = empty
% ------------------------ :: HComp
% U ; G1 µ G2 |- t with h := u : G1 µ G2 #- D

U ; G |- t : !c |1|^p
----------------------- :: FillU
U ; G |- fillUnit p t : _!_

x notin names(G1)
U ; G1 |- t : !c |A1 --o A2|^p
U ; G2 µ~ { x : A1 } |- u : A2
p = w => G2 = empty
----------------------------- :: FillFn
U ; G1 µ~ G2 |- fillFn p { \ x : A1 . u } t : _!_

% TODO: linearity of D? should be ok because if Ur above, then u: N
% TODO: so dests are ruled out, and linear functions would capture something
U ; G1 |- t : !c |D|^p
U ; G2 |- u : D
p = w => G2 = empty
---------------------- :: FillL
U ; G1 µ~ G2 |- fillLeaf p u t : _!_

U ; G |- t : !c |!w N|^p
----------------------------------- :: FillE
U ; G |- fillUr p t : !c |N|^w

U ; G |- t : !c |D1 + D2|^p
----------------------------------------- :: FillInl
U ; G |- fillLeft p t : !c |D1|^p

U ; G |- t : !c |D1 + D2|^p
----------------------------------------- :: FillInr
U ; G |- fillRight p t : !c |D2|^p

R =fix µ X. DV
U ; G |- t : !c |R|^p
---------------------------------------------------------------- :: FillR
U ; G |- fillRoll p R t : !c |DV[X := R]|^p

U ; G |- t : !c |D1 * D2|^p
----------------------------------------------:: FillP
U ; G |- fillPair p t : !c (!c |D1|^p mpar !c |D2|^p)

U ; G |- t : !c |!c D1 mpar !c D2|^p
----------------------------------------------:: FillM
U ; G |- fillMpar p t : !c (|D1|^p * |D2|^p)

defns
Sem :: '' ::=

defn
t !! t' :: :: Reduce :: SemOp_ by

------------------- :: Val
v !! v

t !! C (\ x : A . t')
u !! v2
t'[x := v2] !! v3
---------------------------- :: App
t u !! v3

t !! C *
u !! v2
--------------------------------------------- :: PatU
case t of { * -> u } !! v2

t !! C (Ur d)
u[y := C d] !! v2
----------------------------------------------------- :: PatE
case t of { Ur y -> u } !! v2

t !! C (Inl d)
u1[y1 := C d] !! v2
----------------------------------------- :: PatInl
case t of {Inl y1 -> u1, Inr y2 -> u2} !! v2

t !! C (Inr d)
u2[y2 := C d] !! v2
----------------------------------------- :: PatInr
case t of {Inl y1 -> u1, Inr y2 -> u2} !! v2

t !! C (@R d)
u[y := C d] !! v2
------------------------------------------------------ :: PatR
case t of { @ R y -> u } !! v2


t !! C <d1, d2>
u[y1 := C d1, y2 := C d2] !! v2
-------------------------------------------- :: PatP
case t of {<y1,y2> -> u} !! v2

t !! C d
-------------------------------------------- :: Ex
extract t !! d

t !! C <v1 ¤ v2>
--------------------------------------------------- :: FlipM
flip t !! C <v2 ¤ v1>

t !! C <v1 ¤ C <v2 ¤ v3>>
---------------------------------------- :: ReassocM
reassoc t !! C <C <v1 ¤ v2> ¤ v3>

t !! C <o ¤ d>
------------------------------ :: RedLM
redL t !! C d

t !! C <v1 ¤ v2>
u v1 !! v3
---------------------------- :: MapLM
mapL t with u !! C <v3 ¤ v2>

fresh x
---------------------------- :: Alloc
alloc D !! C <C |x| ¤ x>

% % TODO: need a way to portal info through mpar
% t !! |x|
% ---------------------------- :: FillU
% fillUnit p t !! S1[h := *] | o

% S0 | t !! S1 | Dest h
% -------------------------- :: FillFn
% S0 | fillFn p t { \x:A. u } !! S1[h := \x:A. u] | o

% S0 | t !! S1 | Dest h
% S1 | u !! S2 | d2
% ---------------------------- :: FillL
% S0 | fillLeaf p t u !! S2[h := d2] | o

% fresh h'
% S0 | t !! S1 | Dest h
% S1[h := Ur h'] | u[y := Dest h'] !! S2 | v2
% --------------------------------------------------- :: FillE
% S0 | fillUr p t y { u } !! S2 | v2

% fresh h'
% S0 | t !! S1 | Dest h
% S1[h := Inl h'] | u[y := Dest h'] !! S2 | v2
% ------------------------------------------------------------ :: FillInl
% S0 | fillLeft p t y { u } !! S2 | v2

% fresh h'
% S0 | t !! S1 | Dest h
% S1[h := Inr h'] | u[y := Dest h'] !! S2 | v2
% ------------------------------------------------------------ :: FillInr
% S0 | fillRight p t y { u } !! S2 | v2

% fresh h1
% fresh h2
% S0 | t !! S1 | Dest h
% S1[h := <h1, h2>] | u[y1 := Dest h1, y2 := Dest h2] !! S2 | v2
% --------------------------------------------------------------- :: FillP
% S0 | fillPair p t y1 y2 { u } !! S2 | v2

% fresh h'
% S0 | t !! S1 | Dest h
% S1[h := @R h'] | u[y := Dest h'] !! S2 | v2
% --------------------------------------------------- :: FillR
% S0 | fillRoll p R t x { u } !! S2 | v2

parsing
t_PatU <= t_App
t_PatU <= t_FillL
dty_Sum <= dty_Comp
dty_Prod <= dty_Comp
dty_Mpar <= dty_Comp
dtywv_Comp <= dty_Sub
