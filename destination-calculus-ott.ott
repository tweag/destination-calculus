% minimal + latex + comments

embed
{{ tex-preamble
\usepackage{stmaryrd}
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{multcolor}{RGB}{186, 58, 7}
\definecolor{kwcolor}{RGB}{0, 0, 0}
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathrm{\mathit{#1} } } }
\renewcommand{\ottkw}[1]{\textcolor{kwcolor}{\mathsf{#1} } }
\newcommand{\ottdefault}[1]{\textcolor{black}{\mathsf{#1} } }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\ottmult}[1]{\textcolor{multcolor}{\mathit{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle indent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\heaparrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyHeap}[1]{\textsc{TyHeap\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\itshape #1} }
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar metavariable, x, xs, y, uf, f, d ::=
  {{ tex \ottmv{[[metavariable]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | v :: :: Val {{ com value }}
  | t u                                    ::   :: App      {{ com application }}
  | t ; u :: :: EffSeq {{ com effect sequencing }}
  | case t of { () -> u }                   ::   :: PatU     {{ com pattern-matching on unit }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on exponentiated value }}
  | case t of { inl x1 -> u1 , inr x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
  | case t of { roll R x -> u } :: :: PatR {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{ \underset{[[R]] }{\ottkw{roll} }~[[x]] \mapsto [[u]] \} }} {{ com unroll for recursive types }}
  | alloc d A { t } { u }                                   ::   :: Alloc    {{ com allocate data }} {{ tex \ottkw{alloc}~[[d]]:[[A]]~\ottkw{with}~[[t]]~\ottkw{in}~[[u]] }}
  % TODO: move, share (ex fillLeaf)
  | fillUnit p t :: :: FillU {{ com fill destination with unit }} {{ tex [[t]]\,\triangleleft[[m]]\,\ottcons{()} }}
  | fillFn p t { \ x : A . u } :: :: FillFn {{ com fill destination with reusable function }} {{ tex [[t]]\,\triangleleft[[p]]\,\lambda [[x]]:[[A]]\,\textbf{.}\,[[u]] }}
  | fillLeaf p t u :: :: FillL {{ tex [[t]]\,\triangleleft[[p]]\,[[u]] }}
  | fillUr p t d { u } :: :: FillE {{ com fill destination with exponential }} {{ tex [[t]]\,\triangleleft[[p]]\,\ottcons{Ur}~[[d]]\,\textbf{.}\,[[u]] }}
  | fillLeft p t d { u }                          ::   :: FillInl   {{ com fill sum-type destination with variant 1 }} {{ tex [[t]]\,\triangleleft[[p]]\,\ottcons{inl} [[d]]\,\textbf{.}\,[[u]] }}
  | fillRight p t d { u }                          ::   :: FillInr   {{ com fill sum-type destination with variant 2 }} {{ tex [[t]]\,\triangleleft[[p]]\,\ottcons{inr} [[d]]\,\textbf{.}\,[[u]] }}
  | fillPair p t d1 d2 { u }                              ::   :: FillP    {{ com fill product-type destination }} {{ tex [[t]]\,\triangleleft[[p]]\,\langle [[d1]] , [[d2]] \rangle\,\textbf{.}\,[[u]] }}
  | fillRoll p R t d { u } :: :: FillR {{ com fill destination with recursive type }} {{ tex [[t]]\,\triangleleft[[p]]\,\underset{[[R]]}{\ottcons{roll} }~[[d]]\,\textbf{.}\,[[u]] }}
  | ( t )                                   :: S :: Paren
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ var_subs ]                             :: M :: Sub {{ tex [[t]]\left[ [[var_subs]]\right] }}

multiplicity, p :: 'mult_' :: ::= {{ com multiplicity }} {{ tex \ottmult{[[multiplicity]]} }}
  | l :: :: One {{ tex ^\ottmult{1} }}
  | w :: :: Many {{ tex ^\ottmult{omega} }}
  | p -1 :: M :: Minus {{ tex ^\ottmult{[[p]]-1} }}

var_sub, vs :: 'vs_' ::= {{ com variable substitution }}
  | x := t :: :: VarSub

var_subs :: 'vss_' ::= {{ com variable substitutions }}
  | vs :: :: Single
  | vs , var_subs :: :: Multiple

heap_val, h :: 'hv_' ::=
  | ()                                      ::   :: U
  | Ur x :: :: E
  | inl x :: :: Inl
  | inr x :: :: Inr
  | ind x :: :: Dest
  | \ x : A . t :: :: Fn {{ tex \lambda [[x]]:[[A]]\,\textbf{.}\,[[t]] }}
  | < x1 , x2 > :: :: P
  | roll R x :: :: R {{ tex \underset{[[R]] }{\ottkw{roll} }~[[l]] }}
  | C xbar :: M :: Generic {{ com generic for all the cases above }}

val, v :: 'v_' ::= {{ com unreducible value }}
  | o :: :: NoEff {{ com no-effect effect }}
  | x                                       ::   :: Var      {{ com variable }}

heap_affect, ha :: 'ha_' ::= {{ com heap cell }}
  | x ^ m <| h :: :: HeapVal
  | xbar ^ mbar <| hbar :: M :: Generic {{ tex \ottmv{\bar{x} }^\ottmult{\bar{m} } \heaparrow \ottnt{\bar{h} } }} {{ com generic for multiple occurences }}

heap_affects :: 'has_' ::= {{ com heap cells }}
  | ha :: :: Single
  | ha , heap_affects :: :: Multiple

heap, H {{ tex \mathbb{H} }} :: 'h_' ::= {{ com heap contents }}
  | empty :: :: Empty
  | { heap_affects } :: :: Stmts
  | H1 µ H2 :: :: Union

type, A, B :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
  | _!_ :: :: Bottom {{ com bottom type }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
  | A * B :: :: Prod {{ com product type }} {{ tex \ottty{[[A]] \otimes [[B]]} }}
  | A + B :: :: Sum {{ com sum type }}
  | A --o B :: :: LinArr {{ com linear function type }}
  | | A | ^ m :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[A]] \rfloor}[[m]] }}
  | | A |s ^ m :: :: SDest {{ com stored destination type }} {{ tex \ottty{\lfloor [[A]] \rfloor}[[m]] }}
  | ! A :: :: Exp {{ com exponential }} {{ tex \ottty{![[A]]} }}
  | ( A )  :: S :: Paren {{ tex \ottty{([[A]])} }}
  | W [ r := A ] :: M :: Sub {{ tex [[W]]\ottdefault{[} \ottmv{r}~\ottdefault{[[:=]]}~\ottty{[[A]]} \ottdefault{]} }}

type_with_hole, W :: 'twh_' ::= {{ tex \ottty{[[type_with_hole]]} }}
  | r :: :: Hole {{ com type hole in recursive definition }} {{ tex \ottmv{r} }}
  | _!_ :: :: Bottom {{ com bottom type }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
  | W1 * W2 :: :: Prod {{ com product type }} {{ tex \ottty{[[W1]] \otimes [[W2]]} }}
  | W1 + W2 :: :: Sum {{ com sum type }}
  | W1 --o W2 :: :: LinArr {{ com linear function type }}
  | | W | ^ m :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[W]] \rfloor}[[m]] }}
  | ! W :: :: Exp {{ com exponential }} {{ tex \ottty{![[W]]} }}
  | ( W )  :: S :: Paren {{ tex \ottty{([[W]])} }}

rec_type_bound, R :: 'rtb_' ::= {{ com recursive type bound to a name }} {{ tex \ottty{[[rec_type_bound]]} }}

rec_type_def :: 'rtd_' ::=
  | µ r . W :: :: Abs {{ tex \mu\,\ottmv{r}\,\textbf{.}\,[[W]] }}

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : A ::  :: Var {{ com var }}
  | xbar : Abar :: :: GenericLabel {{ tex \ottmv{\bar{x} } : \ottty{\bar{A} } }} {{ com generic for multiple occurences }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, G {{ tex \Gamma }}, U {{ tex \mho }}, Gh {{ tex \Gamma^{\scriptscriptstyle \mathbb{H} } }}, Gt {{ tex \Gamma^{\ottnt{t} } }} :: 'tc_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var
  | G1 µ G2    ::    :: Union

types, Abar {{ tex \ottty{\bar{A} } }} :: 'tys_' ::= {{ tex \ottty{[[types]]} }}
  | none :: :: None {{ tex \ottty{\cdot} }} {{ com empty type list }}
  | A :: :: Single
  | A types :: :: Multiple {{ tex [[A]]~~[[types]] }}

command :: 'com_' ::=
  | H | t :: :: Command {{ tex [[H]]\,|\,[[t]] }}

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

heap_constructor, C :: 'hcons_' ::= {{ tex \ottcons{[[heap_constructor]]} }}
  | { () } :: :: U {{ tex [[()]] }}
  | { inl } :: :: Inl {{ tex [[inl]] }}
  | { inr } :: :: Inr {{ tex [[inr]] }}
  | { < , > } :: :: P {{ tex \langle{,}\rangle }}
  | { roll R } :: :: R {{ tex \ottcons{roll}~[[R]] }}

% judg :: 'judg_' ::=
%   | l in names ( P ) :: :: CtxLabelIn
%   | l notin names ( P ) :: :: CtxLabelNotIn
%   | type_affect in G :: :: CtxTypeAffIn
%   | ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }}
%   | ctxdisjoint3 G1 G2 G3 :: :: CtxDisjoint3 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G1]]) \cap [[names]]([[G3]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G2]]) \cap [[names]]([[G3]]) = \emptyset }}
%   | names ( P ) µ names ( Y ) includedin L :: :: LabelSetDef2
%   | names ( P ) µ names ( Yh ) µ names ( Yt ) includedin L :: :: LabelSetDef3
%   | l in L :: :: LabelSetIn
%   | l notin L :: :: LabelSetNotIn
%   | heap_affect in H :: :: HeapAffIn
%   | A is B :: :: EqType
%   | t is u :: :: EqTerm
%   | G is D :: :: EqContext
%   | { l <| v' , lbar <| vbar } = deepCopy ( L , v ) :: :: DeepCopyTree {{ tex \{ [[l]] [[<|]] [[v']], [[lbar]] [[<|]] [[vbar]] \} = \mathsf{deepCopy}([[L]], \ottlb{\lfloor[[l]]\rfloor}, [[v]]) }}
%   | R =fix rec_type_def :: :: TyRec
%   | A is destFree :: :: TyDestFree {{ tex \text{$[[A]]$ is destination-free} }}
%   | C : Abar >> A :: :: TyCtor
%   | P ; Yh u Yt ; U ; G |- command : A :: :: TyCommand
%   | P ; Y |- H :: :: TyHeap
%   | P ; Y ; U ; G |- t : A ::  :: TyTerm
%   | command !! command' :: :: SemOp

terminals :: 'terminals_' ::=
  | () :: :: unit {{ tex \ottcons{()} }}
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | + :: :: sum {{ tex \ottty{\oplus} }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: with {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | -| :: :: stileturn {{ tex \dashv }} 
  | -||- :: :: bistile {{ tex \dashv\!\vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | empty :: :: empty {{ tex \emptyset }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | inl :: :: v1 {{ tex \ottcons{inl} }}
  | inr :: :: v2 {{ tex \ottcons{inr} }}
  | Ur :: :: ur {{ tex \ottcons{Ur}\, }}
  | <| :: :: pointsto {{ tex \heaparrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | >> :: :: consarrow {{ tex ~\ottty{\consarrow}~ }}
  | is :: :: is {{ tex = }}
  | !! :: :: downto {{ tex ~~\Downarrow~~ }}
  | =fix :: :: fix {{ tex \overset{\mathsf{fix} }{=} }}
  | _!_ :: :: bottom {{ tex \ottty{\bot} }}
  | o :: :: bullet {{ tex \bullet }}
  | includedin :: :: includedin {{ tex \subset }}
  | ';' :: :: sep {{ tex ~\fatsemi\, }}
  | names :: :: names {{ tex \mathcal{N} }}
  | xbar :: :: xbar {{ tex \ottmv{\bar{x} } }}
  | hbar :: :: hbar {{ tex \ottnt{\bar{h} } }}

defns
Ctx :: '' ::=

defn
x in names ( G ) :: :: CtxLabelIn :: CtxLabelIn_ by

defn
x notin names ( G ) :: :: CtxLabelNotIn :: CtxLabelNotIn_ by

defn
type_affect in G :: :: CtxTypeAffIn :: CtxTypeAffIn_ by

defn
ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 :: CtxDisjoint2_ {{ com $[[G1]]$~~and~~$[[G2]]$ are disjoint typing contexts with no clashing variable names or labels }} {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }} by

defn
p = w => G = empty :: :: CtxEmptyWhenOmega :: CtxEmptyWhenOmega_ by

defns
LabelSet :: '' ::=

defns
Heap :: '' ::=

defn
heap_affect in H :: :: HeapAffIn :: HeapAffIn_ by

defns
Eq :: '' ::=

defn
A is B :: :: EqType :: EqType_ by
defn
A isnt B :: :: NeqType :: NeqType_ by
defn
t is u :: :: EqTerm :: EqTerm_ by
defn
G is D :: :: EqContext :: EqContext_ by

defns
Ty :: '' ::=

defn
R =fix rec_type_def :: :: TyRec :: TyRec_ by

defn
C : Abar >> A :: :: TyCtor :: TyCtor_ {{ com Heap constructor $[[C]]$ builds a value of type $[[A]]$ given arguments of type $[[Abar]]$ }} by

---------------- :: U
{ () } : none >> 1

-------------------  :: Inl
{ inl } : A >> A + B

----------------------- :: Inr
{ inr } : B >> A + B

--------------------------- :: P
{ <,> } : A B >> A * B

R =fix µ r. W
---------------------- :: R
{ roll R } : W[r := R] >> R

defn
U ; Gh u Gt -||- command : A :: :: TyCommand :: TyCommand_ {{ tex [[U]]~;\,[[Gh]]\!\mathrel{\raisebox{1pt}{$\scriptscriptstyle\sqcup$} }\![[Gt]] [[-||-]] [[command]] : [[A]] }} by

ctxdisjoint2 Gh Gt
U ; Gh µ Gt -| H
U ; Gt |- t : A
-------------------------------- :: Def
U ; Gh u Gt -||- H | t : A

%  | ()                                      ::   :: U
%  | Ur x :: :: E
%  | inl x :: :: Inl
%  | inr x :: :: Inr
%  | ind x :: :: Dest
%  | \ x : A . t :: :: Fn {{ tex \lambda [[x]]:[[A]]\,\textbf{.}\,[[t]] }}
%  | < x1 , x2 > :: :: P
%  | roll R x :: :: R {{ tex \underset{[[R]] }{\ottkw{roll} }~[[l]] }}

defn
U ; G -| H :: :: TyHeap :: TyHeap_ by

% issue : non determinism because
% case x of Ur x' -> case x' of <x1, x2>, we need x1, x2 in the linear context, but they have multiplicity w
------------------- :: Empty
empty ; empty -| empty

U ; G -| H
------------------
U ; G µ {} |- t


defn
U ; G |- t : A :: :: TyTerm :: TyTerm_ by

------------------------ :: NoEff
U ; empty |- o : _!_

--------------- :: Id
U ; { x : A } |- x : A

--------------- :: Id'
U µ { x : A } ; empty |- x : A

U ; G1 |- t : A --o B
U ; G2 |- u : A
ctxdisjoint2 G1 G2
--------------------------------- :: App
U ; G1 µ G2 |- t u : B

U ; G1 |- t : _!_
U ; G2 |- u : B
ctxdisjoint2 G1 G2
--------------------------------- :: EffSeq
U ; G1 µ G2 |- t ; u : B

U ; G1 |- t : 1
U ; G2 |- u : A
ctxdisjoint2 G1 G2
----------------------------------------- :: PatU
U ; G1 µ G2 |- case t of { () -> u } : A

U ; G1 |- t : !A
U µ { x : A } ; G2 |- u: B
ctxdisjoint2 G1 G2
----------------------------------------- :: PatE 
U ; G1 µ G2 |- case t of { Ur x -> u } : B

U ; G1 |- t : A1 + A2
U ; G2 µ { x1 : A1 } |- u1 : B
U ; G2 µ { x2 : A2 } |- u2 : B
ctxdisjoint2 G1 G2
------------------------------------------------------- :: PatS
U ; G1 µ G2 |- case t of { inl x1 -> u1 , inr x2 -> u2 } : B

U ; G1 |- t : A1 * A2
U ; G2 µ { x1 : A1 , x2 : A2 } |- u : B
ctxdisjoint2 G1 G2
------------------------------------------------------- :: PatP
U ; G1 µ G2 |- case t of {<x1, x2> -> u} : B

R =fix µ r. W
U ; G1 |- t : R
U ; G2 µ { x : W[r := R] } |- u : B
ctxdisjoint2 G1 G2
----------------------------- :: PatR
U ; G1 µ G2 |- case t of { roll R x -> u } : B

U ; G1 µ { d : |A|^1 } |- t : _!_
U ; G2 µ { d : A } |- u : B
ctxdisjoint2 G1 G2
------------------------------ :: Alloc
U ; G1 µ G2 |- alloc d A { t } { u } : B

U ; G |- t : |1|^p
----------------------- :: FillU
U ; G |- fillUnit p t : _!_

U ; G1 |- t : |A --o B|^p
U ; G2 µ { x : A } |- u : B
ctxdisjoint2 G1 G2
p = w => G2 = empty
----------------------------- :: FillFn
U ; G1 µ G2 |- fillFn p t { \ x : A . u } : _!_

U ; G1 |- t : |A|^p
U ; G2 |- u : A
ctxdisjoint2 G1 G2
p = w => G2 = empty
---------------------- :: FillL
U ; G1 µ G2 |- fillLeaf p t u : _!_

U ; G1 |- t : |!A|^p
U ; G2 µ { d' : |A|^w } |- u : B
ctxdisjoint2 G1 G2
----------------------------------- :: FillE
U ; G1 µ G2 |- fillUr p t d { u } : B

U ; G1 |- t : |A1 + A2|^p
U ; G2 µ { d' : |A1|^p } |- u : B
ctxdisjoint2 G1 G2
----------------------------------------- :: FillInl
U ; G1 µ G2 |- fillLeft p t d' { u } : B

U ; G1 |- t : |A1 + A2|^p
U ; G2 µ { d' : |A2|^p } |- u : B
ctxdisjoint2 G1 G2
----------------------------------------- :: FillInr
U ; G1 µ G2 |- fillRight p t d' { u } : B

U ; G1 |- t : |A1 * A2|^p
U ; G2 µ { d1 : |A1|^p , d2 : |A2|^p } |- u : B
ctxdisjoint2 G1 G2
----------------------------------------------:: FillP
U ; G1 µ G2 |- fillPair p t d1 d2 { u } : B

R =fix µ r. W
U ; G1 |- t : |R|^p
U ; G2 µ { d : |W[r := R]|^p } |- u : B
ctxdisjoint2 G1 G2
---------------------------------------------------------------- :: FillR
U ; G1 µ G2 |- fillRoll R t d { u } : B

defns
Sem :: '' ::=

defn
command !! command' :: :: Reduce :: SemOp_ by

------------------- :: NoEff {{ com \remark{(value)} }}
H | o !! H | o

------------------- :: Var {{ com \remark{(value)} }}
H µ  | x !! H | x

H0 | t !! H1 | x

H0 | t !! H1 µ {x^p <| \x:A.t'} | x
H1 µ {x^p-1 <| \x':A.t'} | u !! H2 | v2
H2 | | t'[x' := v] !! H3 | v3
---------------------------- :: App
H0 | t u !! H3 | v3

H0 | t !! H1 µ {x^p <| ()} | x
H1 µ {x^p-1 <| ()} | u !! H2 | v2
--------------------------------------------- :: PatU
H0 | case t of { () -> u } !! H2 | v2

H0 | t !! H1 µ { x^p <| Ur x' } | x
H1 µ { x^p-1 <| Ur x' } | u[y := x'] !! H2 | v2
----------------------------------------------------- :: PatE
H0 | case t of { Ur y -> u } !! H2 | v2

H0 | t !! H1 µ { x^p <| inl x' } | x
H1 µ { x^p-1 <| inl x' } | u1[y1 := x'] !! H2 | v2
----------------------------------------- :: PatInl
H0 | case t of {inl y1 -> u1, inr y2 -> u2} !! H2 | v2

H0 | t !! H1 µ { x^p <| inr x' } | x
H1 µ { x^p-1 <| inr x' } | u2[y2 := x'] !! H2 | v2
----------------------------------------- :: PatInr
H0 | case t of {inl y1 -> u1, inr y2 -> u2} !! H2 | v2

H0 | t !! H1 µ { x^p <| <x1, x2> } | x
H1 µ { x^p-1 <| <x1, x2> } | u[y1 := x1, y2 := x2] !! H2 | v2
-------------------------------------------------------------------------------- :: PatP
H0 | case t of {<y1,y2> -> u} !! H2 | v2

H0 | t !! H1 µ { x^p <| roll R x' } | x
H1 µ { x^p-1 <| roll R x' } | u[y := x'] !! H2 | v2
------------------------------------------------------ :: PatR
H0 | case t of { roll R y -> u } !! H2 | v2

H0 | t !! H1 | o
H1 | u !! H2 | v2
------------------------------------------------------ :: EffSeq
H0 | t ; u !! H2 | v2

fresh d'
H0 | t[d := d'] !! H1 | o
H1 | u[d := d'] !! H2 | v2
--------------------------------------------------- :: Alloc
H0 | alloc d A { t } { u } !! H2 | v2

H0 | t !! H1 | d1
H1 | d1 -ind-> H2 | d2
---------------------------- :: FillU
H0 | fillUnit p t !! H2 µ { d2^p <| () } | o

H0 | t !! H1 | d1
H1 | d1 -ind-> H2 | d2
-------------------------- :: FillFn
H0 | fillFn p t { \x:A. u } !! H2 µ { d2^p <| \x:A.u } | o

H0 | t !! H1 | d1
H1 | d1 -ind-> H2 | d2
H2 | u !! H3 µ { x^p <| h } | x
---------------------------- :: FillLVar
H0 | fillLeaf p t u !! H3 µ { x^p-1 <| h, d2^p <| h } | o

H0 | t !! H1 | d1
H1 | d -ind-> H2 | d2
H2 | u !! H3 | x
x notin names(H3)
---------------------------- :: FillLDest {{ com \remark{$p = 1$ all the time} }}
H0 | fillLeaf p t u !! H3 µ { d2^p <| ind x } | o

H0 | t !! H1 | d1
H1 | d1 -ind-> H2 | d2
fresh d'
H2 | u[d := d'] !! H3 | v3
--------------------------------------------------- :: FillE
H0 | fillUr p t d { u } !! H3 µ { d2^p <| Ur d' } | v3

H0 | t !! H1 | d1
H1 | d1 -ind-> H2 | d2
fresh d'
H2 | u[d := d'] !! H3 | v3
------------------------------------------------------------ :: FillInl
H0 | fillLeft p t d { u } !! H3 µ { d2^p <| inl d' } | v3

H0 | t !! H1 | d1
H1 | d1 -ind-> H2 | d2
fresh d'
H2 | u[d := d'] !! H3 | v3
------------------------------------------------------------ :: FillInR
H0 | fillRight p t d { u } !! H3 µ { d2^p <| inr d' } | v3

H0 | t !! H1 | d1
H1 | d1 -ind-> H2 | d2
fresh dl'
fresh dr'
H2 | u[dl := dl', dr := dr'] !! H3 | v3
--------------------------------------------------------------- :: FillP
H0 | fillPair p t dl dr { u } !! H3 µ { d2^p <| <dl', dr'> } | v3

H0 | t !! H1 | d1
H1 | d1 -ind-> H2 | d2
fresh d'
H2 | u[d := d'] !! H3 | v3
--------------------------------------------------- :: FillR
H0 | fillRoll p R t d { u } !! H3 µ { d2^p <| roll R d' } | v3

parsing
v_Lam <= t_Sub
t_PatU <= t_App
t_PatU <= t_FillL
judg_HeapAffIn <= ha_Val
hcons_Inl <= terminals_v1
