% minimal + latex + comments

embed
{{ tex-preamble
\usepackage{stmaryrd}
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{multcolor}{RGB}{26, 87, 186}
\definecolor{holecolor}{RGB}{186, 58, 7}
\definecolor{kwcolor}{RGB}{0, 0, 0}
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\textcolor{kwcolor}{\mathsf{#1} } }
\newcommand{\ottdefault}[1]{\textcolor{black}{\mathsf{#1} } }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\ottho}[1]{\textcolor{holecolor}{#1 } }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\ottmult}[1]{\textcolor{multcolor}{\mathit{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle destent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\storearrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyStore}[1]{\textsc{TyStore\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\itshape #1} }
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar metavariable, x, y ::=
  {{ tex \ottmv{[[metavariable]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | v :: :: Val {{ com value }}
  | x :: :: Var {{ com variable }}
  | t u                                    ::   :: App      {{ com application }}
  | t ; u :: :: EffSeq {{ com effect sequencing }} {{ tex [[t]] ~\fatsemi\, [[u]] }}
  | case t of { * -> u }                   ::   :: PatU {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{ \star \mapsto [[u]] \} }}     {{ com pattern-matching on unit }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on exponentiated value }}
  | case t of { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
  | case t of { @ R x -> u } :: :: PatR {{ com unroll for recursive types }}
  | alloc x D { t }                                   ::   :: Alloc    {{ com allocate data }} {{ tex \underset{\ottty{[[D]]} }{\ottkw{alloc}~[[x]]}\,\textbf{.}\,[[t]] }}
  | fillUnit p t :: :: FillU {{ com fill destination with unit }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\star }}
  | fillFn p t { \ x : A . u } :: :: FillFn {{ com fill destination with function }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\lambda\,[[x]]:[[A]]\,\textbf{.}\,[[u]] }}
  | fillLeaf p t u :: :: FillL {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,[[u]] }}
  | fillUr p t y { u } :: :: FillE {{ com fill destination with exponential }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\ottcons{Ur}~[[y]]\,\textbf{.}\,[[u]] }}
  | fillLeft p t y { u }                          ::   :: FillInl   {{ com fill sum-type destination with variant 1 }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\ottcons{Inl}~[[y]]\,\textbf{.}\,[[u]] }}
  | fillRight p t y { u }                          ::   :: FillInr   {{ com fill sum-type destination with variant 2 }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\ottcons{Inr}~[[y]]\,\textbf{.}\,[[u]] }}
  | fillPair p t y1 y2 { u }                              ::   :: FillP    {{ com fill product-type destination }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\langle [[y1]] , [[y2]] \rangle\,\textbf{.}\,[[u]] }}
  | fillRoll p R t y { u } :: :: FillR {{ com fill destination with recursive type }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,[[@]][[R]]~[[y]]\,\textbf{.}\,[[u]] }}
  | ( t )                                   :: S :: Paren
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ subs ]                             :: M :: Sub

hole, h :: 'h_' ::= {{ tex \ottho{[[hole]]} }}

val, v :: 'v_' ::= {{ com unreducible value }}
  | o :: :: NoEff {{ com no-effect effect }}
  | d                                       ::   :: Data      {{ com data structure }}

data, d :: 'd_' ::=
  | Dest h :: :: Dest {{ tex \ottho{\lfloor[[h]]\rfloor} }}
  | * ::   :: U {{ tex \star }}
  | \ x : A . t :: :: Fn {{ tex \lambda\,[[x]]:[[A]]\,\textbf{.}\,[[t]] }}
  | Ur d :: :: E
  | Inl d :: :: Inl
  | Inr d :: :: Inr
  | < d1 , d2 > :: :: P
  | @ R d :: :: R
  | ( d ) :: S :: Paren

multiplicity, p :: 'mult_' ::= {{ com multiplicity }} {{ tex \ottmult{[[multiplicity]]} }}
  | l :: :: One {{ tex \ottmult{1} }}
  | w :: :: Many {{ tex \ottmult{\omega} }}

sub :: 'sub_' ::= {{ com substitution }}
  | x := t :: :: VarSub
  | h := dh :: :: HoleSub

subs :: 'subs_' ::= {{ com substitutions }}
  | sub :: :: Single
  | sub , subs :: :: Multiple

data_with_hole, dh {{ tex \ottnt{\underline{d} } }} :: 'dh_' ::=
  | d :: :: NoHole
  | h :: :: H
  | Ur dh :: :: E
  | Inl dh :: :: Inl
  | Inr dh :: :: Inr
  | < dh1 , dh2 > :: :: P
  | @ R dh :: :: R
  | ( dh ) :: S :: Paren

store_affect, sa :: 'sa_' ::= {{ com store cell }}
  | x : D = dh :: :: StoreVal

store_affects :: 'sas_' ::= {{ com store cells }}
  | sa :: :: Single
  | sa , store_affects :: :: Multiple

store, S {{ tex \mathbb{S} }} :: 's_' ::= {{ com store contents }}
  | empty :: :: Empty
  | { store_affects } :: :: Stmts
  | S1 µ S2 :: :: Union
  | S [ subs ] :: M :: Sub

type, A :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
  | _!_ :: :: Bottom {{ com bottom type }}
  | D :: :: Data {{ com data type }}

data_type, D :: 'ty_' ::= {{ tex \ottty{[[data_type]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
  | D1 * D2 :: :: Prod {{ com product type }} {{ tex \ottty{[[D1]] \otimes [[D2]]} }}
  | D1 + D2 :: :: Sum {{ com sum type }}
  | A1 --o A2 :: :: LinArr {{ com linear function type }}
  | | D | ^ p :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[D]] \rfloor}^{[[p]]} }}
  | ! D :: :: Exp {{ com exponential }} {{ tex \ottty{![[D]]} }}
  | ( D )  :: S :: Paren {{ tex \ottty{([[D]])} }}
  | DV [ X := D ] :: M :: Sub {{ tex [[DV]]\ottdefault{[} \ottty{X}~\ottdefault{[[:=]]}~\ottty{[[D]]} \ottdefault{]} }}

type_with_var, AV {{ tex \ottty{\underline{A} } }} :: 'twh_' ::= {{ tex \ottty{[[type_with_var]]} }}
  | _!_ :: :: Bottom
  | DV :: :: Data

data_type_with_var, DV {{ tex \ottty{\underline{D} } }} :: 'dtwh_' ::= {{ tex \ottty{[[data_type_with_var]]} }}
  | X :: :: Var {{ com type variable in recursive definition }} {{ tex \ottty{X} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
  | DV1 * DV2 :: :: Prod {{ com product type }} {{ tex \ottty{[[DV1]] \otimes [[DV2]]} }}
  | DV1 + DV2 :: :: Sum {{ com sum type }}
  | AV1 --o AV2 :: :: LinArr {{ com linear function type }}
  | | DV | ^ p :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[DV]] \rfloor}^{[[p]]} }}
  | ! DV :: :: Exp {{ com exponential }} {{ tex \ottty{![[DV]]} }}
  | ( DV )  :: S :: Paren {{ tex \ottty{([[DV]])} }}

rec_type_bound, R :: 'rtb_' ::= {{ com recursive type bound to a name }} {{ tex \ottty{[[rec_type_bound]]} }}

rec_type_def :: 'rtd_' ::=
  | µ X . DV :: :: Abs {{ tex \mu\,\ottty{X}\,\textbf{.}\,[[DV]] }}

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : A ::  :: Var {{ com variable }}
  | h ^ p : D ::  :: Hole {{ com hole }} {{ tex [[h]]~^{[[p]]}\!\!:~[[D]] }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, G {{ tex \Gamma }}, U {{ tex \mho }}, Gh {{ tex \mathrm{H} }}, P {{ tex \mathrm{H_{P} } }}, N {{ tex \mathrm{H_{N} } }} :: 'tc_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var
  | G1 µ G2    ::    :: Union

command :: 'com_' ::=
  | S | t :: :: Command {{ tex [[S]]\,|\,[[t]] }}

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

% judg :: 'judg_' ::=
%   | l in names ( P ) :: :: CtxLabelIn
%   | l notin names ( P ) :: :: CtxLabelNotIn
%   | type_affect in G :: :: CtxTypeAffIn
%   | % ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }}
%   | ctxdisjoint3 G1 G2 G3 :: :: CtxDisjoint3 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G1]]) \cap [[names]]([[G3]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G2]]) \cap [[names]]([[G3]]) = \emptyset }}
%   | names ( P ) µ names ( Y ) includedin L :: :: LabelSetDef2
%   | names ( P ) µ names ( Yh ) µ names ( Yt ) includedin L :: :: LabelSetDef3
%   | l in L :: :: LabelSetIn
%   | l notin L :: :: LabelSetNotIn
%   | store_affect in S :: :: StoreAffIn
%   | D is D2 :: :: EqType
%   | t is u :: :: EqTerm
%   | G is D :: :: EqContext
%   | { l <| v' , lbar <| vbar } = deepCopy ( L , v ) :: :: DeepCopyTree {{ tex \{ [[l]] [[<|]] [[v']], [[lbar]] [[<|]] [[vbar]] \} = \mathsf{deepCopy}([[L]], \ottlb{\lfloor[[l]]\rfloor}, [[v]]) }}
%   | R =fix rec_type_def :: :: TyRec
%   | D is destFree :: :: TyDestFree {{ tex \text{$[[D]]$ is destination-free} }}
%   | C : Abar >> D :: :: TyCtor
%   | P ; Yh u Yt ; U ; G |- command : D :: :: TyCommand
%   | P ; Y |- S :: :: TyStore
%   | P ; Y ; U ; G |- t : D ::  :: TyTerm
%   | command !! command' :: :: SemOp

terminals :: 'terminals_' ::=
  | () :: :: unit {{ tex \ottcons{()} }}
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | + :: :: sum {{ tex \ottty{\oplus} }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: with {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | -| :: :: stileturn {{ tex \dashv }}
  | µ :: :: dunion {{ tex \sqcup }}
  | empty :: :: empty {{ tex \emptyset }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | Inl :: :: v1 {{ tex \ottcons{Inl} }}
  | Inr :: :: v2 {{ tex \ottcons{Inr} }}
  | Ur :: :: ur {{ tex \ottcons{Ur}\, }}
  | Dest :: :: dest {{ tex \ottcons{Dest}\, }}
  | <| :: :: pointsto {{ tex \storearrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | >> :: :: consarrow {{ tex ~\ottty{\consarrow}~ }}
  | !! :: :: downto {{ tex ~~\Downarrow~~ }}
  | =fix :: :: fix {{ tex \overset{\mathsf{fix} }{=} }}
  | _!_ :: :: bottom {{ tex \ottty{\bot} }}
  | o :: :: bullet {{ tex \bullet }}
  | includedin :: :: includedin {{ tex \subset }}
  | names :: :: names {{ tex \mathcal{N} }}
  | => :: :: implies {{ tex \implies }}
  | '@' :: :: at {{ tex \ottty{\textsf{@} } }}
  | and :: :: land {{ tex \land }}

defns
Ctx :: '' ::=

defn
x in names ( G ) :: :: CtxVarIn :: CtxVarIn_ by

defn
x notin names ( G ) :: :: CtxVarNotIn :: CtxVarNotIn_ by

defn
type_affect in G :: :: CtxTypeAffIn :: CtxTypeAffIn_ by

defn
ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 :: CtxDisjoint2_ {{ com $[[G1]]$~~and~~$[[G2]]$ are disjoint typing contexts with no clashing variable names or labels }} {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }} by

defn
p1 = p2 => G1 = G2 :: :: CtxMultiplicity :: CtxMultiplicity_ by

defn
p1 = p2 => ( G1 = G2 and G3 = G4 ) :: :: CtxMultiplicity2 :: CtxMultiplicity2_ by

defns
Store :: '' ::=

defn
fresh h :: :: FreshHole :: FreshHole_ by

defn
store_affect in S :: :: StoreAffIn :: StoreAffIn_ by

defn
x notin names ( S ) :: :: StoreVarNotIn :: StoreVarNotIn_ by

defns
Eq :: '' ::=

defn
A1 is A2 :: :: EqType :: EqType_ {{ tex [[A1]] = [[A2]] }} by
defn
A1 isnt A2 :: :: NeqType :: NeqType_ {{ tex [[A1]] \neq [[A2]] }} by
defn
t is u :: :: EqTerm :: EqTerm_ {{ tex [[t]] = [[u]] }} by
defn
G is D :: :: EqContext :: EqContext_ {{ tex [[G]] = [[D]] }} by

defns
Ty :: '' ::=

defn
R =fix rec_type_def :: :: TyRec :: TyRec_ by

defn
U ; G |- command : A :: :: TyComm :: TyComm_ {{ tex [[U]]~;\,[[G]] [[|-]] [[command]] : [[A]] }} by

Gh -| S
U ; Gh u G |- t : A
-------------------------------- :: Def
U ; G |- S | t : A

defn
P ; N -||- dh ^ p : D :: :: TyDh :: TyDh_ {{ tex [[N]]\vdash[[dh]]~^{[[p]]}\!\!:~[[D]]\vdash[[P]] }} {{ com $[[P]]$ stands for "provides", $[[N]]$ for "needs" }} by

------------------ :: H
{h ^p: D} ; empty -||- h^p : D

------------------ :: Dest
empty ; { h ^p: D } -||- Dest h ^l : |D|^p

------------------ :: U
empty ; empty -||- *^p : 1

empty ; N u { x : A1 } |- t : A2
p = w => N = empty
------------------ :: Fn
empty ; N -||- \x:D. t ^p : A1 --o A2

P ; N -||- dh ^w : D
---------------- :: E
P ; N -||- Ur dh ^p: !D

P ; N -||- dh ^p : D1
------------------- :: Inl
P ; N -||- Inl dh ^p : D1+D2

P ; N -||- dh ^p : D2
------------------- :: Inr
P ; N -||- Inr dh ^p : D1+D2

P1 ; N1 -||- dh1 ^p : D1
P2 ; N2 -||- dh2 ^p : D2
% ctxdisjoint2 P1 P2
% ctxdisjoint2 N1 N2
-------------------------- :: P
P1 µ P2 ; N1 µ N2 -||- <dh1, dh2> ^p: D1 * D2

R =fix µ X. DV
P ; N -||- dh ^p : DV[X := R]
----------------------------- :: R
P ; N -||- @R dh ^p : R

defn
Gh -| S :: :: TyStore :: TyStore_ {{ tex [[S]]\vdash[[Gh]] }} by

------------------- :: Empty
empty -| empty

Gh µ N -| S
P ; N -||- dh ^l : D
% ctxdisjoint2 Gh P
% x notin names (S)
-------------------- :: Root
Gh µ P -| S µ { x : D = dh }


defn
U ; Gh u G |- t : A :: :: TyTerm :: TyTerm_ {{ tex [[U]]~;\,[[Gh]]\mathrel{\raisebox{1pt}{\scalebox{0.5}{$\sqcup$}\!\! } }[[G]] [[|-]] [[t]] : [[A]] }} by

------------------------ :: NoEff
U ; empty u empty |- o : _!_

------------------------- :: Dest
U ; { h ^p : D } u empty |- Dest h : |D|^p

--------------- :: U
U ; empty u empty |- * : 1

empty ; Gh u { x : A1 } |- t : A2
------------------------------- :: Fn
U ; Gh u empty |- \ x : A1 . t : A1 --o A2

empty ; empty u empty |- d : D
--------------------- :: E
U ; empty u empty |- Ur d : !D

empty ; Gh u empty |- d : D1
-------------------- :: Inl
U ; Gh u empty |- Inl d : D1 + D2

empty ; Gh u empty |- d : D2
-------------------- :: Inr
U ; Gh u empty |- Inr d : D1 + D2

empty ; Gh1 u empty |- d1 : D1
empty ; Gh2 u empty |- d2 : D2
% ctxdisjoint2 Gh1 Gh2
----------------------- :: P
U ; Gh1 µ Gh2 u empty |- <d1, d2> : D1 * D2

R =fix µX.DV
empty ; Gh u empty |- d : DV[X := R]
--------------------------------- :: R
U ; Gh u empty |- @R d : R

------------------------------- :: Id
U ; empty u { x : A } |- x : A

--------------- :: Id'
U µ { x : A } ; empty u empty |- x : A

U ; Gh1 u G1 |- t : A1 --o A2
U ; Gh2 u G2 |- u : A1
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
--------------------------------- :: App
U ; Gh1 µ Gh2 u G1 µ G2 |- t u : A2

U ; Gh1 u G1 |- t : _!_
U ; Gh2 u G2 |- u : A2
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
--------------------------------- :: EffSeq
U ; Gh1 µ Gh2 u G1 µ G2 |- t ; u : A2

U ; Gh1 u G1 |- t : 1
U ; Gh2 u G2 |- u : A
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
----------------------------------------- :: PatU
U ; Gh1 µ Gh2 u G1 µ G2 |- case t of { * -> u } : A

U ; Gh1 u G1 |- t : !D
U µ { x : D } ; Gh2 u G2 |- u: A
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
----------------------------------------- :: PatE
U ; Gh1 µ Gh2 u G1 µ G2 |- case t of { Ur x -> u } : A

U ; Gh1 u G1 |- t : D1 + D2
U ; Gh2 u G2 µ { x1 : D1 } |- u1 : A
U ; Gh2 u G2 µ { x2 : D2 } |- u2 : A
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
------------------------------------------------------- :: PatS
U ; Gh1 µ Gh2 u G1 µ G2 |- case t of { Inl x1 -> u1 , Inr x2 -> u2 } : A

U ; Gh1 u G1 |- t : D1 * D2
U ; Gh2 u G2 µ { x1 : D1 , x2 : D2 } |- u : A
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
------------------------------------------------------- :: PatP
U ; Gh1 µ Gh2 u G1 µ G2 |- case t of {<x1, x2> -> u} : A

R =fix µ X. DV
U ; Gh1 u G1 |- t : R
U ; Gh2 u G2 µ { x : DV[X := R] } |- u : A
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
----------------------------- :: PatR
U ; Gh1 µ Gh2 u G1 µ G2 |- case t of { @R x -> u } : A

U ; Gh u G µ { x : |D|^l } |- t : _!_
------------------------------ :: Alloc
U ; Gh u G |- alloc x D { t } : D

U ; Gh u G |- t : |1|^p
----------------------- :: FillU
U ; Gh u G |- fillUnit p t : _!_

U ; Gh1 u G1 |- t : |A1 --o A2|^p
U ; Gh2 u G2 µ { x : A1 } |- u : A2
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
p = w => (Gh2 = empty and G2 = empty)
----------------------------- :: FillFn
U ; Gh1 µ Gh2 u G1 µ G2 |- fillFn p t { \ x : A1 . u } : _!_

U ; Gh1 u G1 |- t : |D|^p
U ; Gh2 u G2 |- u : D
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
p = w => (Gh2 = empty and G2 = empty)
---------------------- :: FillL
U ; Gh1 µ Gh2 u G1 µ G2 |- fillLeaf p t u : _!_

U ; Gh1 u G1 |- t : |!D|^p
U ; Gh2 u G2 µ { x : |D|^w } |- u : A
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
----------------------------------- :: FillE
U ; Gh1 µ Gh2 u G1 µ G2 |- fillUr p t x { u } : A

U ; Gh1 u G1 |- t : |D1 + D2|^p
U ; Gh2 u G2 µ { x : |D1|^p } |- u : A
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
----------------------------------------- :: FillInl
U ; Gh1 µ Gh2 u G1 µ G2 |- fillLeft p t x { u } : A

U ; Gh1 u G1 |- t : |D1 + D2|^p
U ; Gh2 u G2 µ { x : |D2|^p } |- u : A
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
----------------------------------------- :: FillInr
U ; Gh1 µ Gh2 u G1 µ G2 |- fillRight p t x { u } : A

U ; Gh1 u G1 |- t : |D1 * D2|^p
U ; Gh2 u G2 µ { x1 : |D1|^p , x2 : |D2|^p } |- u : A
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
----------------------------------------------:: FillP
U ; Gh1 µ Gh2 u G1 µ G2 |- fillPair p t x1 x2 { u } : A

R =fix µ X. DV
U ; Gh1 u G1 |- t : |R|^p
U ; Gh2 u G2 µ { x : |DV[X := R]|^p } |- u : A
% ctxdisjoint2 Gh1 Gh2
% ctxdisjoint2 G1 G2
---------------------------------------------------------------- :: FillR
U ; Gh1 µ Gh2 u G1 µ G2 |- fillRoll p R t x { u } : A

defns
Sem :: '' ::=

defn
command !! command' :: :: Reduce :: SemOp_ by

------------------- :: Val
S | v !! S | v

S0 | t !! S1 | \ x : A . t'
S1 | u !! S2 | v2
S2 | t'[x := v2] !! S3 | v3
---------------------------- :: App
S0 | t u !! S3 | v3

S0 | t !! S1 | o
S1 | u !! S2 | v2
------------------------------------------------------ :: EffSeq
S0 | t ; u !! S2 | v2

S0 | t !! S1 | *
S1 | u !! S2 | v2
--------------------------------------------- :: PatU
S0 | case t of { * -> u } !! S2 | v2

S0 | t !! S1 | Ur d
S1 | u[y := d] !! S2 | v2
----------------------------------------------------- :: PatE
S0 | case t of { Ur y -> u } !! S2 | v2

S0 | t !! S1 | Inl d
S1 | u1[y1 := d] !! S2 | v2
----------------------------------------- :: PatInl
S0 | case t of {Inl y1 -> u1, Inr y2 -> u2} !! S2 | v2

S0 | t !! S1 | Inr d
S1 | u2[y2 := d] !! S2 | v2
----------------------------------------- :: PatInr
S0 | case t of {Inl y1 -> u1, Inr y2 -> u2} !! S2 | v2

S0 | t !! S1 | <d1, d2>
S1 | u[y1 := d1, y2 := d2] !! S2 | v2
-------------------------------------------------------------------------------- :: PatP
S0 | case t of {<y1,y2> -> u} !! S2 | v2

S0 | t !! S1 | @R d
S1 | u[y := d] !! S2 | v2
------------------------------------------------------ :: PatR
S0 | case t of { @ R y -> u } !! S2 | v2

fresh h
S0 µ { x : D = h } | t[x := Dest h] !! S1 µ { x : D = d } | o
--------------------------------------------------- :: Alloc
S0 | alloc x D { t } !! S1 | d

S0 | t !! S1 | Dest h
---------------------------- :: FillU
S0 | fillUnit p t !! S1[h := *] | o

S0 | t !! S1 | Dest h
-------------------------- :: FillFn
S0 | fillFn p t { \x:A. u } !! S1[h := \x:A. u] | o

S0 | t !! S1 | Dest h
S1 | u !! S2 | d2
---------------------------- :: FillL
S0 | fillLeaf p t u !! S2[h := d2] | o

fresh h'
S0 | t !! S1 | Dest h
S1[h := Ur h'] | u[y := Dest h'] !! S2 | v2
--------------------------------------------------- :: FillE
S0 | fillUr p t y { u } !! S2 | v2

fresh h'
S0 | t !! S1 | Dest h
S1[h := Inl h'] | u[y := Dest h'] !! S2 | v2
------------------------------------------------------------ :: FillInl
S0 | fillLeft p t y { u } !! S2 | v2

fresh h'
S0 | t !! S1 | Dest h
S1[h := Inr h'] | u[y := Dest h'] !! S2 | v2
------------------------------------------------------------ :: FillInr
S0 | fillRight p t y { u } !! S2 | v2

fresh h1
fresh h2
S0 | t !! S1 | Dest h
S1[h := <h1, h2>] | u[y1 := Dest h1, y2 := Dest h2] !! S2 | v2
--------------------------------------------------------------- :: FillP
S0 | fillPair p t y1 y2 { u } !! S2 | v2

fresh h'
S0 | t !! S1 | Dest h
S1[h := @R h'] | u[y := Dest h'] !! S2 | v2
--------------------------------------------------- :: FillR
S0 | fillRoll p R t x { u } !! S2 | v2

parsing
t_PatU <= t_App
t_PatU <= t_FillL
