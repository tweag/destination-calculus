% minimal + latex + comments

embed
{{ tex-preamble
\usepackage{stmaryrd}
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{multcolor}{RGB}{26, 87, 186}
\definecolor{holecolor}{RGB}{186, 58, 7}
\definecolor{kwcolor}{RGB}{0, 0, 0}
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\textcolor{kwcolor}{\mathsf{#1} } }
\newcommand{\ottdefault}[1]{\textcolor{black}{\mathsf{#1} } }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\ottho}[1]{\textcolor{holecolor}{#1 } }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\ottmult}[1]{\textcolor{multcolor}{\mathit{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle destent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\storearrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyStore}[1]{\textsc{TyStore\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\small\itshape #1} }
\newcommand{\holearrowgen}[1]{\ottho{\text{#1}\!\!\!\rightharpoonup} } % 
\def\restriction#1#2{\mathchoice
              {\setbox1\hbox{${\displaystyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\textstyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptscriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} } }
\def\restrictionaux#1#2{ {#1\,\smash{\vrule height .8\ht1 depth .85\dp1} }_{\,#2} }
\newcommand{\tickedsquare}{\makebox[0pt][l]{$\square$}\raisebox{.15ex}{\hspace{0.1em}$\checkmark$} }
\newcommand{\notickedsquare}{\makebox[0pt][l]{$\square$}\raisebox{.15ex}{\hspace{0.1em}$\,$} }
\newcommand{\holearrow}{\holearrowgen{\notickedsquare} }
\newcommand{\noholearrow}{\holearrowgen{\tickedsquare} }
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar metavariable, x, y ::=
  {{ tex \ottmv{[[metavariable]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | v :: :: Val {{ com value }}
  | x :: :: Var {{ com variable }}
  | x bar :: :: VarGeneric {{ tex \ottmv{\bar{[[x]]} } }}
  | t u                                    ::   :: App      {{ com application }}
  | t ; u :: :: EffSeq {{ com effect sequencing }} {{ tex [[t]] \,\fatsemi\, [[u]] }}
  | case t of { * -> u }                   ::   :: PatU {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{ \star \mapsto [[u]] \} }}     {{ com pattern-matching on unit }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on exponentiated value }}
  | case t of { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
  | case t of { @ R x -> u } :: :: PatR {{ com pattern-matching on recursive data }}
  | alloc C D x { t }                                   ::   :: Alloc    {{ com get data from a dest-filling statement }} {{ tex \underset{\ottty{[[D]]} }{\ottkw{alloc}~[[C]]~[[x]]}\,\textbf{.}\,[[t]] }}
  | t with hole_subs :: :: HComp {{ com hole composition }}
  | fillUnit p t :: :: FillU {{ com fill destination with unit }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\star }}
  | fillFn p t { \ x : A . u } :: :: FillFn {{ com fill destination with function }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\lambda\,[[x]]\!:\![[A]]\,\textbf{.}\,[[u]] }}
  | fillLeaf p t u :: :: FillL {{ com fill destination with value }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,[[u]] }}
  | fillUr p t y { u } :: :: FillE {{ com fill destination with exponential }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\ottcons{Ur}~[[y]]\,\textbf{.}\,[[u]] }}
  | fillLeft p t y { u }                          ::   :: FillInl   {{ com fill destination with sum variant 1 }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\ottcons{Inl}~[[y]]\,\textbf{.}\,[[u]] }}
  | fillRight p t y { u }                          ::   :: FillInr   {{ com fill destination with sum variant 2 }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\ottcons{Inr}~[[y]]\,\textbf{.}\,[[u]] }}
  | fillPair p t y1 y2 { u }                              ::   :: FillP    {{ com fill destination with product }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,\langle [[y1]] , [[y2]] \rangle\,\textbf{.}\,[[u]] }}
  | fillRoll p R t y { u } :: :: FillR {{ com fill destination with recursive data }} {{ tex [[t]]\,\triangleleft^{\,[[p]]}\,[[@]][[R]]~[[y]]\,\textbf{.}\,[[u]] }}
  | ( t )                                   :: S :: Paren
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ subs ]                             :: M :: Sub

hole, h :: 'h_' ::= {{ com hole in the lexical store }} {{ tex \ottho{[[hole]]} }}
  | C [ x ] :: :: Conn

val, v :: 'v_' ::= {{ com value (unreducible term) }}
  | o :: :: NoEff {{ com empty effect }}
  | d                                       ::   :: Data      {{ com data structure }}

data, d :: 'd_' ::=
  | x asDest :: :: Dest {{ com stored destination }} {{ tex [[x]]^{\lfloor\!\rfloor} }}
  | h :: :: H {{ com hole }}
  | * ::   :: U {{ com unit }} {{ tex \star }}
  | \ x : A . t :: ::  Fn {{ com lambda abstraction }} {{ tex \lambda\,[[x]]\!:\![[A]]\,\textbf{.}\,[[t]] }}
  | Ur d :: :: E {{ com exponential }}
  | Inl d :: :: Inl {{ com sum variant 1 }}
  | Inr d :: :: Inr {{ com sum variant 2 }}
  | < d1 , d2 > :: :: P {{ com product }}
  | @ R d :: :: R {{ com recursive data }}
  | ( d ) :: S :: Paren

multiplicity, p :: 'mult_' ::= {{ com multiplicity }} {{ tex \ottmult{[[multiplicity]]} }}
  | l :: :: One {{ com for holes/destinations not under a $\ottcons{Ur}$ }} {{ tex \ottmult{1} }}
  | w :: :: Many {{ com for holes/destinations under a $\ottcons{Ur}$ }} {{ tex \ottmult{\omega} }}

sub :: 'sub_' ::= {{ com substitution }}
  | var_sub :: :: VarSub
  | hole_sub :: :: HoleSub

subs :: 'subs_' ::= {{ com substitutions }}
  | var_subs :: :: VarSubs
  | hole_subs :: :: HoleSubs

var_sub :: 'vsub_' ::= {{ com variable substitution }}
  | x := v :: :: VarSub

var_subs :: 'vsubs_' ::= {{ com variable substitutions }}
  | var_sub :: :: Single
  | var_sub , var_subs :: :: Multiple

hole_sub :: 'hsub_' ::= {{ com hole substitution }}
  | h := t :: :: HoleSub % {{ com note: $\ottho{\lfloor{}h\rfloor}$ won't be replaced in $\mathbb{S}[\ottho{h} := \ottnt{dh}]$ }}

hole_subs :: 'hsubs_' ::= {{ com hole substitutions }}
  | hole_sub :: :: Single
  | hole_sub , hole_subs :: :: Multiple

dest_conns, C {{ tex \ottho{\mathcal{C} } }} :: 'dconns_' ::= {{ com dest substitutions by holes }}
  | empty :: :: Empty
  | { dest_conn } :: :: Some

dest_conn :: 'dconn_' ::=
  | x -> h :: :: Single
  | x -> h , dest_conn :: :: Multiple
  | x bar -> h bar :: M :: Generic {{ tex \ottmv{\bar{[[x]]} }[[->]]\ottho{\bar{[[h]]} } }}

% store_affect, sa :: 'sa_' ::= {{ com store cell }}
%   | x : D = dh :: :: StoreVal

% store_affects :: 'sas_' ::= {{ com store cells }}
%   | sa :: :: Single
%   | sa , store_affects :: :: Multiple

% store, S {{ tex \mathbb{S} }} :: 's_' ::=
%   | empty :: :: Empty
%   | { store_affects } :: :: Stmts
%   | S1 Âµ S2 :: :: Union
%   | S [ subs ] :: M :: Sub

type, A :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
  | _!_ :: :: Bottom {{ com bottom (effect) type }}
  | H #- D :: :: DataWithHole {{ tex \boxed{\scriptstyle[[H]]}[[D]] }}
  | emptyH #- D :: :: Data {{ tex [\!][[D]] }}

data_type, D :: 'ty_' ::= {{ tex \ottty{[[data_type]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
  | D1 * D2 :: :: Prod {{ com product type }} {{ tex \ottty{[[D1]]\!\otimes\![[D2]]} }}
  | D1 + D2 :: :: Sum {{ com sum type }} {{ tex \ottty{[[D1]]\!\oplus\![[D2]]} }}
  | A1 --o A2 :: :: LinArr {{ com linear function type }}
  | | D | ^ p :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[D]] \rfloor}^{[[p]]} }}
  | | D bar | ^ p bar :: M :: DestGeneric {{ com destination type }} {{ tex \ottty{\bar{\lfloor [[D]]\rfloor} }^{\ottmult{\bar{[[p]]} } } }}
  | ! D :: :: Exp {{ com exponential }} {{ tex \ottty{![[D]]} }}
  | ( D )  :: S :: Paren {{ tex \ottty{([[D]])} }}
  | DV [ X := D ] :: M :: Sub {{ com unroll a recursive data type }} {{ tex [[DV]]\ottdefault{[} \ottty{X}~\ottdefault{[[:=]]}~\ottty{[[D]]} \ottdefault{]} }}

type_with_var, AV {{ tex \ottty{\underline{A} } }} :: 'twh_' ::= {{ tex \ottty{[[type_with_var]]} }}
  | _!_ :: :: Bottom
  | H #- DV :: :: DataWithHole {{ tex \ottty{\boxed{\scriptstyle[[H]]} }[[DV]] }}
  | emptyH #- DV :: :: Data {{ tex \ottty{[]}[[DV]] }}

data_type_with_var, DV {{ tex \ottty{\underline{D} } }} :: 'dtwh_' ::= {{ tex \ottty{[[data_type_with_var]]} }}
  | X :: :: Var {{ tex \ottty{X} }}
  | 1 :: :: One {{ tex \ottty{[[1]]} }}
  | R :: :: Rec
  | DV1 * DV2 :: :: Prod {{ tex \ottty{[[DV1]] \otimes [[DV2]]} }}
  | DV1 + DV2 :: :: Sum {{ tex \ottty{[[DV1]] \oplus [[DV2]]} }}
  | AV1 --o AV2 :: :: LinArr
  | | DV | ^ p :: :: Dest {{ tex \ottty{\lfloor [[DV]] \rfloor}^{[[p]]} }}
  | ! DV :: :: Exp {{ tex \ottty{![[DV]]} }}
  | ( DV )  :: S :: Paren {{ tex \ottty{([[DV]])} }}

rec_type_bound, R :: 'rtb_' ::= {{ com name for recursive type }} {{ tex \ottty{[[rec_type_bound]]} }}

rec_type_def :: 'rtd_' ::= {{ com recursive type definition }}
  | Âµ X . DV :: :: Abs {{ tex \mu\,\ottty{X}\,\textbf{.}\,[[DV]] }}

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : A ::  :: Var {{ com variable }}
  | h ^ p : D ::  :: Hole {{ com hole }} {{ tex [[h]]~^{[[p]]}\!:~[[D]] }}
  | h bar ^ p bar : D bar :: M :: Generic {{ tex \ottho{\bar{[[h]]} }~^{\ottmult{\bar{[[p]]} } }\!:~\ottty{\bar{[[D]]} } }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, G {{ tex \Gamma }}, Gd {{tex \restriction{\Gamma}{\lfloor\!\rfloor} }}, U {{ tex \mho }}, H {{ tex \ottho{\mathrm{H} } }}, Hw {{tex \restriction{\ottho{\mathrm{H} } }{\ottmult{ \omega} } }} :: 'tc_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var
  | G1 Âµ G2    ::    :: Union

% command :: 'com_' ::=
%   | S | t :: :: Command {{ tex [[S]]\,|\,[[t]] }}

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

% judg :: 'judg_' ::=
%   | type_affect in G :: :: CtxTypeAffIn
%   | % ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }}
%   | ctxdisjoint3 G1 G2 G3 :: :: CtxDisjoint3 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G1]]) \cap [[names]]([[G3]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G2]]) \cap [[names]]([[G3]]) = \emptyset }}
%   | l in L :: :: LabelSetIn
%   | l notin L :: :: LabelSetNotIn
%   | store_affect in S :: :: StoreAffIn
%   | D is D2 :: :: EqType
%   | t is u :: :: EqTerm
%   | G is D :: :: EqContext
%   | { l <| v' , lbar <| vbar } = deepCopy ( L , v ) :: :: DeepCopyTree {{ tex \{ [[l]] [[<|]] [[v']], [[lbar]] [[<|]] [[vbar]] \} = \mathsf{deepCopy}([[L]], \ottlb{\lfloor[[l]]\rfloor}, [[v]]) }}
%   | R =fix rec_type_def :: :: TyRec
%   | D is destFree :: :: TyDestFree {{ tex \text{$[[D]]$ is destination-free} }}
%   | C : Abar >> D :: :: TyCtor
%   | command !! command' :: :: SemOp

terminals :: 'terminals_' ::=
  | () :: :: unit {{ tex \ottcons{()} }}
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: with {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | Âµ :: :: dunion {{ tex \sqcup }}
  | empty :: :: empty {{ tex \emptyset }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | Inl :: :: v1 {{ tex \ottcons{Inl} }}
  | Inr :: :: v2 {{ tex \ottcons{Inr} }}
  | Ur :: :: ur {{ tex \ottcons{Ur}\, }}
  | Dest :: :: dest {{ tex \ottcons{Dest}\, }}
  | <| :: :: pointsto {{ tex \storearrow }}
  | |> :: :: connectsto {{ tex \triangleright }}
  | '|' :: :: against {{ tex \,|\, }}
  | !! :: :: downto {{ tex ~~\Downarrow~~ }}
  | =fix :: :: fix {{ tex \overset{\mathsf{fix} }{=} }}
  | _!_ :: :: bottom {{ tex \ottty{\bot} }}
  | o :: :: bullet {{ tex \bullet }}
  | includedin :: :: includedin {{ tex \subset }}
  | names :: :: names {{ tex \mathcal{N} }}
  | => :: :: implies {{ tex \implies }}
  | '@' :: :: at {{ tex \ottty{\textsf{@} } }}
  | and :: :: land {{ tex \land }}
  | ';' :: :: sep {{ tex ~{;}~ }}

defns
Ctx :: '' ::=

defn
x in names ( G ) :: :: CtxVarIn :: CtxVarIn_ by

defn
x notin names ( G ) :: :: CtxVarNotIn :: CtxVarNotIn_ by

defn
type_affect in G :: :: CtxTypeAffIn :: CtxTypeAffIn_ by

defn
ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 :: CtxDisjoint2_ {{ com $[[G1]]$~~and~~$[[G2]]$ are disjoint typing contexts with no clashing variable names or labels }} {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }} by

defn
p1 = p2 => G1 = G2 :: :: CtxMultiplicity :: CtxMultiplicity_ by

defn
p1 = p2 => ( G1 = G2 and G3 = G4 ) :: :: CtxMultiplicity2 :: CtxMultiplicity2_ by

defns
Store :: '' ::=

defn
fresh h :: :: FreshHole :: FreshHole_ by

defn
store_affect in S :: :: StoreAffIn :: StoreAffIn_ by

defn
x notin names ( S ) :: :: StoreVarNotIn :: StoreVarNotIn_ by

defns
Eq :: '' ::=

defn
A1 is A2 :: :: EqType :: EqType_ {{ tex [[A1]] = [[A2]] }} by
defn
A1 isnt A2 :: :: NeqType :: NeqType_ {{ tex [[A1]] \neq [[A2]] }} by
defn
t is u :: :: EqTerm :: EqTerm_ {{ tex [[t]] = [[u]] }} by
defn
G is D :: :: EqContext :: EqContext_ {{ tex [[G]] = [[D]] }} by

defns
Ty :: '' ::=

defn
R =fix rec_type_def :: :: TyRec :: TyRec_ by

defn
U ; G |- t : A :: :: TyTerm :: TyTerm_ by

------------------------ :: NoEff
U ; empty |- o : _!_

------------------------- :: H
U ; empty |- h : { h ^p : D } #- D

------------------------- :: Dest {{ com \remark{Used to restrict syntax space for values} }}
U ; { x : emptyH #- |D|^p } |- x asDest : emptyH #- |D|^p

--------------- :: U
U ; empty |- * : emptyH #- 1

empty ; Gd Âµ { x : A1 } |- t : A2
------------------------------- :: Fn
U ; Gd |- \ x : A1 . t : emptyH #- A1 --o A2

empty ; empty |- d : Hw #- D
--------------------- :: E
U ; empty |- Ur d : Hw #- !D

empty ; Gd |- d : H #- D1
-------------------- :: Inl
U ; Gd |- Inl d : H #- D1 + D2

empty ; Gd |- d : H #- D2
-------------------- :: Inr
U ; Gd |- Inr d : H #- D1 + D2

empty ; Gd1 |- d1 : H1 #- D1
empty ; Gd2 |- d2 : H2 #- D2
% ctxdisjoint2 H1 H2
% ctxdisjoint2 Gd1 Gd2
----------------------- :: P
U ; Gd1 Âµ Gd2 |- <d1, d2> : H1 Âµ H2 #- D1 * D2

R =fix ÂµX.DV
empty ; empty |- d : H #- DV[X := R]
--------------------------------- :: R
U ; empty |- @R d : H #- R

x notin names(U)
------------------------------- :: Id
U ; { x : A } |- x : A

--------------- :: Id'
U Âµ { x : A } ; empty |- x : A

U ; G1 |- t : emptyH #- A1 --o A2
U ; G2 |- u : A1
% ctxdisjoint2 G1 G2
--------------------------------- :: App
U ; G1 Âµ G2 |- t u : A2

U ; G1 |- t : _!_
U ; G2 |- u : A2
% ctxdisjoint2 G1 G2
--------------------------------- :: EffSeq
U ; G1 Âµ G2 |- t ; u : A2

U ; G1 |- t : emptyH #- 1
U ; G2 |- u : A
% ctxdisjoint2 G1 G2
----------------------------------------- :: PatU
U ; G1 Âµ G2 |- case t of { * -> u } : A

U ; G1 |- t : emptyH #- !D
U Âµ { x : emptyH #- D } ; G2 |- u: A
% ctxdisjoint2 G1 G2
----------------------------------------- :: PatE
U ; G1 Âµ G2 |- case t of { Ur x -> u } : A

U ; G1 |- t : emptyH #- D1 + D2
U ; G2 Âµ { x1 : emptyH #- D1 } |- u1 : A
U ; G2 Âµ { x2 : emptyH #- D2 } |- u2 : A
% ctxdisjoint2 G1 G2
------------------------------------------------------- :: PatS
U ; G1 Âµ G2 |- case t of { Inl x1 -> u1 , Inr x2 -> u2 } : A

U ; G1 |- t : emptyH #- D1 * D2
U ; G2 Âµ { x1 : emptyH #- D1 , x2 : emptyH #- D2 } |- u : A
% ctxdisjoint2 G1 G2
------------------------------------------------------- :: PatP
U ; G1 Âµ G2 |- case t of {<x1, x2> -> u} : A

R =fix Âµ X. DV
U ; G1 |- t : emptyH #- R
U ; G2 Âµ { x : emptyH #- DV[X := R] } |- u : A
% ctxdisjoint2 G1 G2
----------------------------- :: PatR
U ; G1 Âµ G2 |- case t of { @R x -> u } : A

U ; G Âµ { x : emptyH #- |D|^l } |- t ; x bar : emptyH #- |D bar| ^ p bar
------------------------------ :: Alloc
U ; G |- alloc { x bar -> h bar } D x { t } : {h bar ^ p bar : D bar} #- D

U ; G1 |- t : H1 Âµ { h ^p : D' } #- D
U ; G2 |- u : H2 #- D'
% ctxdisjoint2 G1 G2
% ctxdisjoint2 H1 H2
p = w => G2 = empty
------------------------ :: HComp
U ; G1 Âµ G2 |- t with h := u : H1 Âµ H2 #- D

U ; G |- t : emptyH #- |1|^p
----------------------- :: FillU
U ; G |- fillUnit p t : _!_

U ; G1 |- t : emptyH #- |A1 --o A2|^p
U ; G2 Âµ { x : A1 } |- u : A2
% ctxdisjoint2 G1 G2
p = w => G2 = empty
----------------------------- :: FillFn
U ; G1 Âµ G2 |- fillFn p t { \ x : A1 . u } : _!_

% We could fill with holed things ??
% How to propagate holes ? Should we have H #- _!_ too?
U ; G1 |- t : emptyH #- |D|^p
U ; G2 |- u : emptyH #- D
% ctxdisjoint2 G1 G2
p = w => G2 = empty
---------------------- :: FillL {{ com \remark{How to propagate holes ?} }}
U ; G1 Âµ G2 |- fillLeaf p t u : _!_

U ; G1 |- t : emptyH #- |!D|^p
U ; G2 Âµ { x : emptyH #- |D|^w } |- u : A
% ctxdisjoint2 G1 G2
----------------------------------- :: FillE
U ; G1 Âµ G2 |- fillUr p t x { u } : A

U ; G1 |- t : emptyH #- |D1 + D2|^p
U ; G2 Âµ { x : emptyH #- |D1|^p } |- u : A
% ctxdisjoint2 G1 G2
----------------------------------------- :: FillInl
U ; G1 Âµ G2 |- fillLeft p t x { u } : A

U ; G1 |- t : emptyH #- |D1 + D2|^p
U ; G2 Âµ { x : emptyH #- |D2|^p } |- u : A
% ctxdisjoint2 G1 G2
----------------------------------------- :: FillInr
U ; G1 Âµ G2 |- fillRight p t x { u } : A

U ; G1 |- t : emptyH #- |D1 * D2|^p
U ; G2 Âµ { x1 : emptyH #- |D1|^p , x2 : emptyH #- |D2|^p } |- u : A
% ctxdisjoint2 G1 G2
----------------------------------------------:: FillP
U ; G1 Âµ G2 |- fillPair p t x1 x2 { u } : A

R =fix Âµ X. DV
U ; G1 |- t : emptyH #- |R|^p
U ; G2 Âµ { x : emptyH #- |DV[X := R]|^p } |- u : A
% ctxdisjoint2 G1 G2
---------------------------------------------------------------- :: FillR
U ; G1 Âµ G2 |- fillRoll p R t x { u } : A

% defns
% Sem :: '' ::=

% defn
% t --> t' :: :: Reduce :: SemOp_ by

% ------------------- :: Val
% S | v !! S | v

% S0 | t !! S1 | \ x : A . t'
% S1 | u !! S2 | v2
% S2 | t'[x := v2] !! S3 | v3
% ---------------------------- :: App
% S0 | t u !! S3 | v3

% S0 | t !! S1 | o
% S1 | u !! S2 | v2
% ------------------------------------------------------ :: EffSeq
% S0 | t ; u !! S2 | v2

% S0 | t !! S1 | *
% S1 | u !! S2 | v2
% --------------------------------------------- :: PatU
% S0 | case t of { * -> u } !! S2 | v2

% S0 | t !! S1 | Ur d
% S1 | u[y := d] !! S2 | v2
% ----------------------------------------------------- :: PatE
% S0 | case t of { Ur y -> u } !! S2 | v2

% S0 | t !! S1 | Inl d
% S1 | u1[y1 := d] !! S2 | v2
% ----------------------------------------- :: PatInl
% S0 | case t of {Inl y1 -> u1, Inr y2 -> u2} !! S2 | v2

% S0 | t !! S1 | Inr d
% S1 | u2[y2 := d] !! S2 | v2
% ----------------------------------------- :: PatInr
% S0 | case t of {Inl y1 -> u1, Inr y2 -> u2} !! S2 | v2

% S0 | t !! S1 | <d1, d2>
% S1 | u[y1 := d1, y2 := d2] !! S2 | v2
% -------------------------------------------------------------------------------- :: PatP
% S0 | case t of {<y1,y2> -> u} !! S2 | v2

% S0 | t !! S1 | @R d
% S1 | u[y := d] !! S2 | v2
% ------------------------------------------------------ :: PatR
% S0 | case t of { @ R y -> u } !! S2 | v2

% fresh h
% S0 Âµ { x : D = h } | t[x := Dest h] !! S1 Âµ { x : D = d } | o
% --------------------------------------------------- :: Alloc
% S0 | alloc x D { t } !! S1 | d

% S0 | t !! S1 | Dest h
% ---------------------------- :: FillU
% S0 | fillUnit p t !! S1[h := *] | o

% S0 | t !! S1 | Dest h
% -------------------------- :: FillFn
% S0 | fillFn p t { \x:A. u } !! S1[h := \x:A. u] | o

% S0 | t !! S1 | Dest h
% S1 | u !! S2 | d2
% ---------------------------- :: FillL
% S0 | fillLeaf p t u !! S2[h := d2] | o

% fresh h'
% S0 | t !! S1 | Dest h
% S1[h := Ur h'] | u[y := Dest h'] !! S2 | v2
% --------------------------------------------------- :: FillE
% S0 | fillUr p t y { u } !! S2 | v2

% fresh h'
% S0 | t !! S1 | Dest h
% S1[h := Inl h'] | u[y := Dest h'] !! S2 | v2
% ------------------------------------------------------------ :: FillInl
% S0 | fillLeft p t y { u } !! S2 | v2

% fresh h'
% S0 | t !! S1 | Dest h
% S1[h := Inr h'] | u[y := Dest h'] !! S2 | v2
% ------------------------------------------------------------ :: FillInr
% S0 | fillRight p t y { u } !! S2 | v2

% fresh h1
% fresh h2
% S0 | t !! S1 | Dest h
% S1[h := <h1, h2>] | u[y1 := Dest h1, y2 := Dest h2] !! S2 | v2
% --------------------------------------------------------------- :: FillP
% S0 | fillPair p t y1 y2 { u } !! S2 | v2

% fresh h'
% S0 | t !! S1 | Dest h
% S1[h := @R h'] | u[y := Dest h'] !! S2 | v2
% --------------------------------------------------- :: FillR
% S0 | fillRoll p R t x { u } !! S2 | v2

parsing
t_PatU <= t_App
t_PatU <= t_FillL
