% minimal + latex + comments

embed
{{ tex-preamble
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathit{#1} } }
\renewcommand{\ottkw}[1]{\mathsf{#1} }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle indent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
}}

metavar metavariable, x, xs, y, z, uf, f, d, dl, dr, dh, dt, l ::=
  {{ tex \ottmv{[[metavariable]]} }}

% indexvar index, i ::=
%   {{ tex \textcolor{red}{[[index]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | x                                       ::   :: Var      {{ com variable }}
  | v :: :: Val {{ com value }}
  | t u                                    ::   :: App      {{ com application }}
  | t ; u                   ::   :: PatU     {{ com pattern-matching on unit }}
  | case t of { 1. x1 -> u1 , 2. x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
  | case t of { Nil -> u1 , x1 Cons x2 -> u2 } :: :: PatL {{ com pattern-matching on list }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on exponentiated value }}
  | alloc d A { t }                                   ::   :: Alloc    {{ com allocate data }} {{ tex \ottkw{alloc}_{[[d]] \hookrightarrow [[A]]}\,\left\{[[t]]\right\} }}
  | t |> fillLeaf u                            ::   :: FillL    {{ com fill terminal-type destination }} {{ tex [[t]]\,\triangleright\,\ottkw{fill}_{\ottkw{\bullet} }\,[[u]] }}
  | t |> fillLeft                          ::   :: FillV1   {{ com fill sum-type destination with variant 1 }} {{ tex [[t]]\,\triangleright\,\ottkw{fill}_{\ottcons{1.} } }}
  | t |> fillRight                          ::   :: FillV2   {{ com fill sum-type destination with variant 2 }} {{ tex [[t]]\,\triangleright\,\ottkw{fill}_{\ottcons{2.} } }}
  | t |> fillPair dl dr { u }                              ::   :: FillP    {{ com fill product-type destination }} {{ tex [[t]]\,\triangleright\,\ottkw{fill}_{\langle [[dl]] , [[dr]] \rangle}.\,[[u]] }}
  | t |> fillNil                               ::   :: FillNil {{ com fill list destination with nil }} {{ tex [[t]]\,\triangleright\,\ottkw{fill}_{[[Nil]]} }}
  | t |> fillCons dh dt { u }                             ::  :: FillCons {{ com fill list destination with cons }} {{ tex [[t]]\,\triangleright\,\ottkw{fill}_{[[dh]] [[Cons]] [[dt]]}.\,[[u]] }}
  | ( t )                                   :: S :: Paren
  | b sp t b spe :: S :: BreakSpacing1
  | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ var_subs ]                             :: M :: Sub
%  | t [ x |> x' ]                            :: M :: Alpha
  | foldl t1 t2 t3 :: :: FoldL {{ com Built-in foldl function (for example) }}

var_sub, vs :: 'vs_' ::= {{ com variable substitution }}
  | x := t :: :: VarSub

var_subs :: 'vss_' ::= {{ com variable substitutions }}
  | vs :: :: Single
  | vs , var_subs :: :: Multiple

% label, l :: 'l_' ::= {{ com label }} {{ tex \ottlb{[[label]]} }}

val, v :: 'v_' ::= {{ com unreducible value }}
  | ()                                      ::   :: Unit     {{ com unit }}
  | \ x : A . t                                ::   :: Lam      {{ com lambda abstraction }} {{ tex \lambda\aunderbrace[l1r]{\,[[x]]{:}[[A]]\,}.\,[[t]] }}
  | Ur t :: :: Exp {{ com exponential }}
  | * l :: M :: Deref

label_stmt, s :: 's_' ::= {{ com label statement }}
  | l .> 1. l' :: :: V1
  | l .> 2. l' :: :: V2
  | l .> < l1 , l2 > :: :: P
  | l .> Nil :: :: Nil
  | l .> l1 Cons l2 :: :: Cons
  | l .> null :: :: Null
  | l .> v :: :: Val

label_stmts :: 'ss_' ::= {{ com label statements }}
  | s :: :: Single
  | s , label_stmts :: :: Multiple

heap_context, H {{ tex \mathbb{H} }} :: 'h_' ::= {{ com label statements }}
  | empty :: :: Empty
  | { label_stmts } :: :: Stmts
  | H1 µ H2 :: :: Union

type, A, B :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{1} }}
%  | P :: :: Prim {{ com primitive type }}
  | A * B :: :: Prod {{ com product type }} {{ tex \ottty{[[A]] \otimes [[B]]} }}
  | A + B :: :: Sum {{ com sum type }}
  | A --o B :: :: LinArr {{ com linear function type }}
  | | A | :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[A]] \rfloor} }}
  | [ A ] :: :: List {{ com list type }} {{ tex \ottty{[[A]]^\star } }}
  | ! A :: :: Exp {{ com exponential }} {{ tex \ottty{![[A]]} }}
  | ( A )  :: S :: Paren {{ tex \ottty{([[A]])} }}

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : A ::  :: Var {{ com var }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, G {{ tex \Gamma }}, D {{ tex \Delta }}, U {{ tex \mho }} :: 'G_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var {{ com variable $[[x]]$ has type $[[A]]$ and must be consumed once }}
  | G µ D    ::    :: Union

spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
  | s :: :: space1 {{ tex \myspace{1} }}
  | ss :: :: space2 {{ tex \myspace{2} }}
  | sss :: :: space3 {{ tex \myspace{3} }}
  | ssss :: :: space4 {{ tex \myspace{4} }}
  | sssss :: :: space5 {{ tex \myspace{5} }}
  | ssssss :: :: space6 {{ tex \myspace{6} }}

spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
  | se :: :: space1e {{ tex \myspace{1} }}
  | sse :: :: space2e {{ tex \myspace{2} }}
  | ssse :: :: space3e {{ tex \myspace{3} }}
  | sssse :: :: space4e {{ tex \myspace{4} }}
  | ssssse :: :: space5e {{ tex \myspace{5} }}
  | sssssse :: :: space6e {{ tex \myspace{6} }}

judg :: 'judg_' ::=
  | H ; U ; G |- t : A ::  :: Jtype
  | H | t --> H' | t' ::  :: Jop

terminals :: 'terminals_' ::=
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | * :: :: prod {{ tex \star }}
  | + :: :: sum {{ tex \ottty{\oplus} }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: with {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | ; :: :: lseq {{ tex ~;~ }}
  | /\ :: :: intersection {{ tex \cap }}
  | empty :: :: empty {{ tex \emptyset }}
  | --> :: :: reducesto {{ tex \longrightarrow }}
  | '|>' :: :: renamedto {{ tex \,\triangleright\, }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
%   | subto :: :: subto {{ tex \underset{[:=]}{\rightarrow} }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | '1.' :: :: v1 {{ tex \ottcons{1.} }}
  | '2.' :: :: v2 {{ tex \ottcons{2.} }}
  | Nil :: :: nil {{ tex \ottcons{Nil} }}
  | Cons :: :: cons {{ tex {:}\!{:} }}
  | Ur :: :: ur {{ tex \ottcons{Ur}\, }}
%  | ++ :: :: concat {{ tex {\small{+}\mspace{-6mu}{+} } }}
%  | <- :: :: affect {{ tex \leftarrow }}
  | .> :: :: pointsto {{ tex \hookrightarrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | null :: :: null {{ tex \oslash }}

defns
JMvar :: '' ::=

% defn
% x != y :: :: JMVarNeq :: JMVar_ {{ com $[[x]]$ and $[[y]]$ stands for different variables }} by

defn
x notin free ( t ) :: :: JMVarNFree :: JMVar_ {{ com $[[x]]$ is not a free variable in $[[t]]$ }} by

defn
x in free ( t ) :: :: JMVarFree :: JMVar_ {{ com $[[x]]$ is a free variable used in $[[t]]$ }} by

defns
Jctx :: '' ::=

defn
names ( G ) /\ names ( D ) = empty :: :: Jctxd :: Jctx_ {{ com $[[G]]$ and $[[D]]$ are disjoint typing contexts with no clashing variable names }} by

defns
Jtype :: '' ::=

defn
H ; U ; G |- t : A :: :: Jtypec :: Jtype_ {{ com $[[t]]$ is a well-typed term of type $[[A]]$ given heap context $[[H]]$, unrestricted typing context $[[U]]$ and linear typing context $[[G]]$ }} by

--------------- :: Id
H ; U ; { x : A } |- x : A

--------------- :: Id'
H ; U µ { x : A} ; empty |- x : A

---------------- :: Unit
H ; U ; empty |- () : 1


H ; U ; G µ { x : A } |- t : B
----------------------- :: Lam
H ; U ; G |- \x:A.t : A --o B

H ; U ; G |- t : A --o B
H ; U ; D |- u : A
names( G ) /\ names( D ) = empty
--------------------------------- :: App
H ; U ; G µ D |- t u : B

H ; U ; G |- t : 1
H ; U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatU
H ; U ; G µ D |- t ; u : A
%U ; G µ D |- case t of { () -> u } : A

H ; U ; G |- t : A1 * A2
H ; U ; D µ { x1 : A1 , x2 : A2 } |- u : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatP
H ; U ; G µ D |- case t of {<x1, x2> -> u} : B

H ; U ; G |- t : A1 + A2
H ; U ; D µ { x1 : A1 } |- u1 : B
H ; U ; D µ { x2 : A2 } |- u2 : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatS
H ; U ; G µ D |- case t of { 1. x1 -> u1 , 2. x2 -> u2 } : B

H ; U ; G |- t : [A]
H ; U ; D |- u1 : B
H ; U ; D µ { x1 : A , x2 : [A] } |- u2 : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatL
H ; U ; G µ D |- case t of { Nil -> u1 , x1 Cons x2 -> u2 } : B

H ; U ; G |- t : !A
H ; U µ { x : A } ; D |- u: B
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatE
H ; U ; G µ D |- case t of { Ur x -> u } : B

H ; U ; G µ { d : |A| } |- t : 1
------------------------------ :: Alloc
H ; U ; G |- alloc d A { t } : A

H ; U ; G |- t : |A|
H ; U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------- :: FillL
H ; U ; G µ D |- t |> fillLeaf u : 1

H ; U ; G |- t : |A1 + A2|
----------------------------------------- :: FillV1
H ; U ; G |- t |> fillLeft : |A1|

H ; U ; G |- t : |A1 + A2|
----------------------------------------- :: FillV2
H ; U ; G |- t |> fillRight : |A2|

H ; U ; G |- t : |A1 * A2|
H ; U ; D µ { dl : |A1| , dr : |A2| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------------:: FillP
H ; U ; G µ D |- t |> fillPair dl dr { u } : B

H ; U ; G |- t : |[A]|
----------------------------------- :: FillNil
H ; U ; G |- t |> fillNil : 1

H ; U ; G |- t : |[A]|
H ; U ; D µ { dh : |A| , dt : |[A]| } |- u : B
names( G ) /\ names( D ) = empty
---------------------------------------------------------------- :: FillCons
H ; U ; G µ D |- t |> fillCons dh dt { u } : B

H ; U ; empty |- t : A
----------------------- :: Exp
H ; U ; empty |- Ur t : !A

H ; U ; G µ { x : A } |- t : B
H ; U ; D |- u : A
names( G ) /\ names( D ) = empty
--------------------------------- :: Sub
H ; U ; G µ D |- t[x := u] : B

defns
Jop :: '' ::=

defn
H | t --> H' | t' :: :: reduce :: Jop_ {{ com $[[t]]$ reduces to $[[t']]$, with heap changing from $[[H]]$ to $[[H']]$ }} by

H | t --> H' | t'
------------------- :: UnderApp
H | t u --> H' | t' u

---------------------------- :: App
H | (\x:A.t) u --> H | t[x := u]

H | t --> H' | t'
--------------------------------------------- :: UnderPatU
H | t ; u --> H' | t' ; u
%case t of {() -> u} --> case t' of {() -> u}

--------------------- :: PatU
H | () ; u --> H | u

---------------------------------- :: Deref
H µ { l .> v } | *l --> H | v

H | t --> H' | t'
------------------------------------------------------------------------------- :: UnderPatS
H | case t of {1. x1 -> u1, 2. x2 -> u2} --> H' | case t' of {1. x1 -> u1, 2. x2 -> u2}

----------------------------------------- :: PatSV1
H µ { l .> 1. l' } | case *l of {1. x1 -> u1, 2. x2 -> u2} --> H | u1[x1 := *l']

----------------------------------------- :: PatSV2
H µ { l .> 2. l' } | case *l of {1. x1 -> u1, 2. x2 -> u2} --> H | u2[x2 := *l']

H | t --> H' | t'
----------------------------------------------------------------------------- :: UnderPatP
H | case t of {<x1,x2> -> u} --> H' | case t' of {<x1,x2> -> u}

-------------------------------------------------------------------------------- :: PatP
H µ { l .> <l1, l2> } | case *l of {<x1,x2> -> u} --> H | u[x1 := *l1, x2 := *l2]

H | t --> H' | t'
------------------------------------------------------------------------------------- :: UnderPatL
H | case t of {Nil -> u1, x1 Cons x2 -> u2} --> H' | case t' of {Nil -> u1, x1 Cons x2 -> u2}

----------------------------------------------------------------------- :: PatLNil
H µ { l .> Nil } | case *l of {Nil -> u1, x1 Cons x2 -> u2} --> H | u1

----------------------------------------------------------------------- :: PatLCons
H µ { l .> l1 Cons l2 } | case *l of {Nil -> u1, x1 Cons x2 -> u2} --> H | u2[x1 := *l1, x2 := *l2]

H | t --> H' | t'
------------------------------------------------------------------------------------- :: UnderPatE
H | case t of {Ur x -> u} --> H' | case t' of {Ur x -> u}

--------------------------------------------------- :: Alloc
H | alloc l A { t } --> H µ { l .> null } | t ; *l

------------------------------------------------------------ :: FillL
H µ { l .> null } | l |> fillLeaf v --> H µ { l .> v } | ()

------------------------------------------------------------ :: FillV1
H µ { l .> null } | l |> fillLeft --> H µ { l .> 1. l', l' .> null } | l'

------------------------------------------------------------ :: FillV2
H µ { l .> null } | l |> fillRight --> H µ { l .> 2. l', l' .> null } | l'

----------------------------------------------- :: FillP
H µ { l .> null } | l |> fillPair l1 l2 { t } --> H µ { l .> <l1, l2> , l1 .> null, l2 .> null } | t

----------------------------------------------- :: FillNil
H µ { l .> null } | l |> fillNil --> H µ { l .> Nil } | ()

----------------------------------------------------- :: FillCons
H µ { l .> null } | l |> fillCons l1 l2 { t } --> H µ { l .> l1 Cons l2 , l1 .> null, l2 .> null } | t

embed
{{ tex

\textbf{Theorem: Progress}

\newcommand{\Jtype}[1]{\textsc{Jtype\_#1} }
\newcommand{\Jop}[1]{\textsc{Jop\_#1} }
\newcommand{\TODO}[1]{\textcolor{red}{$\langle$TODO: #1$\rangle$} }
\newcommand{\is}{\overset{\mathit{is} }{=} }

Suppose $[[t]]$ is a closed, well-typed term (that is, $[[ H ; empty ; empty |- t : A ]]$). Then $[[t]]$ is a value or there are $[[t']]$ and $[[H']]$ such as $[[ H | t --> H' | t' ]]$.

Let's focus on the last derivation of the typing tree of $[[t]]$:

\begin{itemize}


\item It can be neither \Jtype{Id} nor \Jtype{Id'}, because no variable can type with both typing contexts being empty.

\item If it's \Jtype{Unit}, then $[[t]]$ is a value.
\item If it's \Jtype{Lam}, then $[[t]]$ is a value.

\item If it's \Jtype{App}, then there are $[[t']]$, $[[u]]$ such as $[[t]] \is [[t' u]]$. In addition, there is a type $[[B]]$ such as $[[H ; empty ; empty |- t' : B --o A]].

Either $[[t']]$ is a value, in which case:

\begin{itemize}
    \item $[[t']]$ can be neither $[[()]]$ nor $[[Ur t'']]$ ;
    \item if $[[t']] \is [[\ x:B. t'']]$, then $[[t' u]]$ can be reduced via \Jop{App} ;
    \item otherwise, $[[t']]$ is of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
\end{itemize}

or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderApp}.

\item If it's \Jtype{PatU}, then there are $[[t']]$, $[[u]]$ such as $[[t]] \is [[t' ; u]]$ and $[[H ; empty ; empty |- t' : 1]]$.

Either $[[t']]$ is a value, in which case:

\begin{itemize}
    \item $[[t']]$ can be neither $[[\ x:B. t'']]$ nor $[[Ur t'']]$.
    \item if $[[t']] \is [[()]]$, then $[[t' ; u]]$ can be reduced via \Jop{PatU} ;
    \item otherwise, $[[t']]$ is of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
\end{itemize}

or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderPatU}.

\item If it's \Jtype{PatP}, then there are $[[t']]$, $[[u]]$, $[[x1]]$, $[[x2]]$, $[[B1]]$, $[[B2]]$ such as $[[t]] \is [[case t' of { <x1, x2> -> u }]]$ and $[[H ; empty ; empty |- t' : B1 * B2]]$.

Either $[[t']]$ is a value, in which case:

\begin{itemize}
    \item $[[t']]$ can be none of $[[()]]$, $[[\ x:B'. t'']]$ or $[[Ur t'']]$.
    \item so t' must of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
\end{itemize}

or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderPatP}.

\item If it's \Jtype{PatS}, then there are $[[t']]$, $[[u1]]$, $[[u2]]$, $[[x1]]$, $[[x2]]$, $[[B1]]$, $[[B2]]$ such as $[[t]] \is [[case t' of { 1. x1 -> u1, 2. x2 -> u2 }]]$ and $[[H ; empty ; empty |- t' : B1 + B2]]$.

Either $[[t']]$ is a value, in which case:

\begin{itemize}
    \item $[[t']]$ can be none of $[[()]]$, $[[\ x:B'. t'']]$ or $[[Ur t'']]$.
    \item so t' must of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
\end{itemize}

or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderPatS}.

\item If it's \Jtype{PatL}, then there are $[[t']]$, $[[u1]]$, $[[u2]]$, $[[x1]]$, $[[x2]]$, $[[B]]$ such as $[[t]] \is [[case t' of { Nil -> u1, x1 Cons x2 -> u2 }]]$ and $[[H ; empty ; empty |- t' : [B] ]]$.

Either $[[t']]$ is a value, in which case:

\begin{itemize}
    \item $[[t']]$ can be none of $[[()]]$, $[[\ x:B'. t'']]$ or $[[Ur t'']]$.
    \item so t' must of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
\end{itemize}

or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderPatL}.

\item If it's \Jtype{PatE}, then there are $[[t']]$, $[[u]]$, $[[x]]$, $[[B]]$ such as $[[t]] \is [[case t' of { Ur x -> u }]]$ and $[[H ; empty ; empty |- t' : !B ]]$.

Either $[[t']]$ is a value, in which case:

\begin{itemize}
    \item $[[t']]$ can be neither $[[()]]$ nor $[[\ x:B'. t'']]$ ;
    \item 
    \item so t' must of the form $[[*l]]$ and then \TODO{Pointer lemma} says that $[[t]]$ can be reduced.
\end{itemize}

or $[[t']]$ can be reduced, in which case we can apply \Jop{UnderPatE}.

\end{itemize}

\bigskip
\bigskip
\togglespaces

Let's implement $\ottkw{map}$ using $\ottkw{foldl}$ !



\[\begin{array}{l}
\ottkw{map} \defeq [[
\uf: !(A --o B). \xs: [A]. \d: |[B]|. (
b s (foldl
b ss case uf of { Ur f -> Ur (
b sss \d': |[B]|. \x: A. (d' |> fillCons dh dt { dh |> fillLeaf (f x) ; dt })
b sse )}
b ss d
b ss xs
) b se |> fillNil)
]]
\end{array}\]
}}


parsing
v_Lam <= t_Sub
t_PatU <= t_App
t_PatU <= t_FillL
