% minimal + latex + comments

embed
{{ tex-preamble
\usepackage{stmaryrd}
\geometry{a4paper,left=0.75cm,right=0.75cm,top=1.25cm,bottom=2cm}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{bbold}
\DeclareSymbolFont{bbsymbol}{U}{bbold}{m}{n}
\DeclareMathSymbol{\bbcomma}{\mathbin}{bbsymbol}{"2C}
\DeclareMathAlphabet{\mathsfbf}{T1}{\sfdefault}{sbc}{n}
\definecolor{ntcolor}{RGB}{75, 75, 75}
\definecolor{kwcolor}{RGB}{0, 0, 0}
\definecolor{effcolor}{HTML}{F8980F} % yellow-orange, underlined
\definecolor{tycolor}{HTML}{176FC1} % blue, bold
\definecolor{spcolor}{HTML}{1C5737} % dark green, not official one
\definecolor{modecolor}{HTML}{00AAA0} % green-blue, tt
\definecolor{mvcolor}{HTML}{F35EB7} % pink, sf
\definecolor{holecolor}{HTML}{F14B2D} % red, itshape
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsfbf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\newcommand{\ottextval}[1]{\textcolor{ntcolor}{\mathsf{\replacewv{\overline{#1} } } } }
\newcommand{\ottextterm}[1]{\textcolor{ntcolor}{\mathsf{\replacejt{\overline{#1} } } } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\textcolor{kwcolor}{\mathsfbf{#1} } }
\newcommand{\ottdefault}[1]{\textcolor{black}{#1} }
\newcommand{\ottcons}[1]{\textcolor{black}{\mathsf{#1} } }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathit{#1} } }
\newcommand{\otteff}[1]{#1}
\newcommand{\otthol}[1]{\textcolor{holecolor}{\mathtt{#1} } }
\newcommand{\ottmod}[1]{\textcolor{modecolor}{\mathit{#1} } }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\replacejt}[1]{%
  \begingroup%
  \mathcode`j=\mathcode`t
  #1%
  \endgroup%
}
\newcommand{\replacewv}[1]{%
  \begingroup%
  \mathcode`w=\mathcode`v
  #1%
  \endgroup%
}
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle destent \rangle} } }
\makeatletter
\newcommand{\shorteq}{%
  \settowidth{\@tempdima}{--}% Width of hyphen
  \resizebox{\@tempdima}{\height}{=}%
}
\newcommand{\coloneq}{\mathrel{%
  \!\raisebox{0.09ex}{$\mathop{:}$\hspace{-0.1ex}%
  }%
  \shorteq\hspace{-0.2ex}%
}%
}
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\storearrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyStore}[1]{\textsc{TyStore\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\small\itshape #1} }
\newcommand{\holearrowgen}[1]{\ottho{\text{#1}\!\!\!\rightharpoonup} } % 
\def\restriction#1#2{\mathchoice
              {\setbox1\hbox{${\displaystyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\textstyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptscriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} } }
\def\restrictionaux#1#2{ {#1\,\smash{\vrule height .8\ht1 depth .85\dp1} }_{\,#2} }
\usepackage[safe]{tipa}
\newcommand{\mpar}{\ottty{\text{\large\textramshorns} } }
\newcommand{\mparcomma}{ {\scriptstyle\odot} }
\newcommand{\expc}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{-.1ex}{\hspace{-0.4ex}\scriptsize c} } }\hspace{-0.7ex} }
\newcommand{\expw}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{0.05ex}{\hspace{-0.6ex}${\scriptscriptstyle\omega}$} } }\hspace{-0.7ex} }
\newcommand{\putarrow}[1]{\!\overset{#1}{\triangleleft}\!}
\newcommand{\lam}[3]{\ottcons{\lambda}\,#1\!:\!#2\,\textbf{.}\,#3}
\newcommand{\lamnt}[2]{\ottcons{\lambda}#1\,\textbf{.}\,#2}
\newcommand{\Lam}[2]{\ottcons{\Lambda}\,#1\,\textbf{.}\,#2}
\newcommand{\nuabs}[1]{\nu#1\textbf{.}\,}
\newcommand{\expcons}[1]{\ottcons{\rrparenthesis }^{#1}\,}
\newlength{\mylen}
\setbox1=\hbox{$\bullet$}\setbox2=\hbox{$\scriptscriptstyle\bullet$}
\setlength{\mylen}{\dimexpr0.5\ht1-0.5\ht2}
\def\mybullet{\raisebox{\mylen}{$\scriptscriptstyle\bullet$} }

% https://tex.stackexchange.com/questions/597955/a-math-font-size-knowledgeable-raisebox
\makeatletter

\newcommand{\topprod}[1]{\mathpalette\abcd@{#1\ottmod{\cdot} } }
\newcommand{\abcd@}[2]{%
  % #1 = math style
  % #2 = text to be lowered
  \raisebox{%
    % we make it so that the top of the
    % lowered part is at the formula axis
    \dimexpr+\abcd@fontdimen{#1}%
  }{%
    % we don't want that \scriptspace kicks in
    \scriptspace=\z@
    % the part to be lowered
    $\m@th#1#2$%
  }%
}
\newcommand{\abcd@fontdimen}[1]{%
  % the height of the formula axis is \fontdimen22 <math font of family 2>
  \fontdimen22
  \ifx#1\displaystyle\textfont\else
  \ifx#1\textstyle\textfont\else
  \ifx#1\scriptstyle\scriptfont\else
  \scriptscriptfont\fi\fi\fi 2
}
\makeatother

}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar termvar, x, y, d ::= {{ com Term-level variable }}
  {{ tex \ottmv{[[termvar]]} }}

metavar holevar, h ::= {{ com Hole }}
  {{ tex \otthol{[[holevar]]} }}

grammar

term_value, v :: 'TermVal_' ::= {{ com Term value }}
  | < v1 ¤ w2 > H :: :: Ampar {{ com Ampar }} {{ tex \ottcons{\langle}[[v1]]\,\ottcons{\bbcomma}~[[w2]]\ottcons{\rangle}_{[[H]]} }}
  | @ h :: :: Dest {{ tex \otthol{@}[[h]] }} {{ com Destination }}
  | () :: :: Unit {{ com Unit }}
  | Inl v :: :: Inl {{ com Left variant for sum }}
  | Inr v :: :: Inr {{ com Right variant for sum }}
  | ( v1 , v2 ) :: :: Prod {{ tex \ottcons{(}[[v1]]\,\ottcons{,}~[[v2]]\ottcons{)} }} {{ com Product }}
  | exp m v :: :: Exp {{ tex \expcons{[[m]]}[[v]] }} {{ com Exponential }}
  | \ x -> t :: :: Lambda {{ tex \lamnt{[[x]]}{[[t]]} }} {{ com Linear function }}
  | ( v ) :: S :: Paren

extended_value, w :: 'ExtVal_' ::= {{ com Store value }} {{ tex \ottextval{[[extended_value]]} }}
  | v :: :: TermVal {{ com Term value }}
  | h :: :: Hole {{ com Hole }}
  | Inl w :: :: Inl {{ com Left variant with val or hole }}
  | Inr w :: :: Inr {{ com Right variant with val or hole }}
  | ( w1 , w2 ) :: :: Prod {{ tex \ottcons{(}[[w1]]\,\ottcons{,}~[[w2]]\ottcons{)} }} {{ com Product with val or hole }}
  | exp m w :: :: Exp {{ tex \expcons{[[m]]}[[w]] }} {{ com Exponential with val or hole }}
  | ( w ) :: S :: Paren
  | w [ e ] :: M :: Effect

term, t, u :: 'Term_' ::=                                               {{ com Term }}
  | v :: :: TermVal {{ com Term value }}
  | x :: :: Var {{ com Variable }}
  | t & u                                    ::   :: App      {{ com Application }} {{ tex [[t]]~\succ~[[u]] }}
  | t ; u                   ::   :: PatUnit {{ com Pattern-match on unit }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,[[()]]\![[->]]\,[[u]] }}
  | t & \case { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatSum     {{ com Pattern-match on sum }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\{\,\ottcons{Inl}\,[[x1]][[->]][[u1]]\,,~\ottcons{Inr}\,[[x2]][[->]][[u2]]\,\} }}
  | t & \case ( x1 , x2 ) -> u            ::   :: PatProd     {{ com Pattern-match on product }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\ottcons{(}[[x1]]\,\ottcons{,}~[[x2]]\ottcons{)}\![[->]]\,[[u]] }}
  | t & \case exp m x -> u            ::   :: PatExp     {{ com Pattern-match on exponential }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\expcons{[[m]]}[[x]][[->]]\,[[u]] }}
  | t <&> \ x -> u :: :: MapAmpar {{ com Map over the left side of the ampar }} {{ tex [[t]]~\succ\!\!\ottkw{mapL}\,[[x]]\![[->]]\,[[u]] }}

  % | toGlobal t :: :: ToGlobal {{ tex \ottkw{to}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion to ${\ottmod{\scriptstyle G} }$ }}
  % | fromGlobal t :: :: FromGlobal {{ tex \ottkw{from}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion from ${\ottmod{\scriptstyle G} }$ }}
  | toAmpar t :: :: ToAmpar {{ tex \ottkw{to}_{[[><|]]}\,[[t]] }} {{ com Wrap $[[t]]$ into a trivial ampar }}
  | fromAmpar t :: :: FromAmpar {{ tex \ottkw{from}_{[[><|]]}\,[[t]] }} {{ com Extract value from trivial ampar }}

  | alloc A :: :: Alloc {{ com Return a fresh "identity" ampar object }} {{ tex \ottkw{alloc}_{ [[A]]} }}
  | t <| () :: :: FillUnit {{ com Fill destination with unit }}
  | t <| Inl                          ::   :: FillInl   {{ com Fill destination with left variant }}
  | t <| Inr                          ::   :: FillInr   {{ com Fill destination with right variant }}
  | t <| (,)                              ::   :: FillProd    {{ com Fill destination with product constructor }}
  | t <| exp m :: :: FillExp {{ com Fill destination with exponential constructor }} {{ tex [[t]][[<|]]\expcons{[[m]]} }}
  | t <|. u :: :: FillComp {{ com Fill destination with root of ampar $[[u]]$ }}

  | ( t )                                   :: S :: Paren
  | t [ sub ]                             :: M :: Sub
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
  % | t b spe : : S :: BreakSpacing3

% extended_term, j :: 'ExtTerm_' ::= {{ com Extended term }} {{ tex \ottextterm{[[extended_term]]} }}
%   | t :: :: Term
%   | w :: :: ExtVal

sub :: 'Sub_' ::= {{ com Variable substitution }}
  | x := v :: :: Single
  | sub1 , sub2 :: :: Multiple
  | ( sub ) :: S :: Paren {{ tex [[sub]] }}

effect, e :: 'Eff_' ::= {{ com Effect }}
  | o :: :: NoEff {{ tex \varepsilon }} {{ com No effect }}
  | h := w :: :: Single {{ tex [[h]][[:=]][[w]] }}
  | e1 . e2 :: :: Multiple {{ tex [[e1]]\,\cdot\,[[e2]] }}
  | ( e ) :: S :: Paren {{ tex [[e]] }}

type, A, B :: 'Ty_' ::= {{ com Type }} {{ tex \ottty{[[type]]} }}
  | 1 :: :: Unit {{ tex \ottty{1} }} {{ com Unit }}
  | A1 + A2 :: :: Sum {{ tex [[A1]]\ottty{\oplus}[[A2]] }} {{ com Sum }}
  | A1 * A2 :: :: Prod {{ tex [[A1]]\ottty{\otimes}[[A2]] }} {{ com Product }}
  | ! m A :: :: Exp {{ tex \ottty{!}^{[[m]]}\,[[A]] }} {{ com Exponential }}
  | A1 ><| A2 :: :: Ampar {{ tex [[A1]]\,[[><|]]\,[[A2]] }} {{ com Ampar type (consuming $[[A1]]$ yields $[[A2]]$) }}
  | A1 m -> A2 :: :: Lambda {{ tex [[A1]]\,_{[[m]]}\!\ottty{\to}\,[[A2]] }} {{ com Linear function }}
  | | A | m :: :: Dest {{ tex \,^{[[m]]}\hspace{-0.2ex}\ottty{\lfloor}[[A]]\ottty{\rfloor} }} {{ com Destination }}
  | ( A ) :: S :: Paren {{ tex \ottty{(}[[A]]\ottty{)} }}

multiplicity, m, n :: 'Mult_' ::= {{ tex \ottmod{[[multiplicity]]} }} {{ com Multiplicity (Semiring with product $[[.]]$) }}
  | 0 :: :: Now {{ tex \ottmod{\nu} }} {{ com Born now. Identity of the product }}
  | I :: :: One {{ tex \ottmod{\uparrow} }} {{ com One scope older }}
  | inf :: :: Inf {{ tex \ottmod{\infty} }} {{ com Infinitely old / static. Absorbing for product }}
  | m1 . m2 :: :: SemiringTimes {{ com Semiring product }}
  | ( m ) :: S :: Paren {{ tex \ottmod{(}[[m]]\ottmod{)} }}

typing_context, D {{ tex \Delta }} :: 'TyCtx_' ::= {{ com Typing context }}
  | G    ::   :: OnlyPos
  | H ::    :: OnlyNeg
  | G u H :: :: SepPosNeg {{ tex [[G]]\mathrel{\raisebox{1pt}{\scalebox{0.5}{$\sqcup$}\!\! } }[[H]] }}

pos_context, G {{ tex \Gamma }} :: 'PosCtx_' ::= {{ com Positive typing context }}
  | {}    ::   :: Empty
  | { pos_assigns } :: :: Assigns
  | G1 µ G2    ::    :: Disjoint
  | - H :: :: Minus {{ tex \otthol{@}[[H]] }} {{ com Inverse the sign of the context }}
  | m . G :: :: SemiringTimes {{ com Increase age of bindings by $[[m]]$ }}
  | ( G ) :: S :: Paren
  | _ :: M :: Placeholder

pos_assign, pa :: 'PosAssign_' ::= {{ com Positive type assignment }}
%  | x : A :: :: LocalVar
  | x : m A :: :: Var {{ com Variable }} {{ tex [[x]]:_{[[m]]}[[A]] }}
  | @ h : m | A | n :: :: Dest {{ com Destination ($[[m]]$ is its own age; $[[n]]$ is the age of values it accepts) }} {{ tex \otthol{@}[[h]]:_{[[m]]}\,\!^{[[n]]}\!\ottty{\lfloor}[[A]]\ottty{\rfloor} }}
pos_assigns :: 'PosAssigns_' ::= {{ com Positive type assignments }}
  | pa :: :: Single
  | pa , pos_assigns :: :: Multiple

neg_assign, na :: 'NegAssign_' ::= {{ com Negative type assignment }}
  | h : n A :: :: Hole {{ com Hole ($[[n]]$ is the age of values it accepts, its own age is undefined) }} {{ tex [[h]]:^{[[n]]}[[A]] }}
neg_assigns :: 'NegAssigns_' ::= {{ com Negative type assignments }}
  | na :: :: Single
  | na , neg_assigns :: :: Multiple

neg_context, H {{ tex \textrm{H} }} :: 'NegCtx_' ::= {{ com Negative typing context }}
  | {}    ::   :: Empty
  | { neg_assigns } :: :: Assigns
  | H1 µ H2    ::    :: Disjoint
  | - G :: :: Minus  {{ tex \otthol{@^{-1} }[[G]] }} {{ com Inverse the sign of the context }}
  | m . H :: :: SemiringTimes {{ com Increase age of bindings by $[[m]]$ }} {{ tex \topprod{[[m]]}[[H]] }}
  | ( H ) :: S :: Paren
  | _ :: M :: Placeholder

eff_app :: 'EffApp_' ::= {{ com Effect application }}
  | e , w H :: :: Explicit {{ tex [[e]],\,[[w]]\,_{[[H]]} }}
  | apply ( eff_app ) :: :: Apply
  | e .^ eff_app :: :: Compose {{ tex [[e]]~\,\hat{\cdot}\,~[[eff_app]] }}

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=
% === Type syntax ===
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | ><| :: :: rtimes {{ tex \ottty{\rtimes} }}

% === Term syntax ===
  | ->                                     ::   :: mapsto       {{ tex \mapsto }}
  | () :: :: unit {{ tex \ottcons{()} }}
  | Inl :: :: inl {{ tex \ottcons{Inl} }}
  | Inr :: :: inr {{ tex \ottcons{Inr} }}
  | (,) :: :: prod {{ tex \ottcons{({,})} }}
  | <| :: :: fill {{ tex \triangleleft }}
  | <|. :: :: fillcomp {{ tex \triangleleft\!\mybullet\, }}
  | := :: :: assign {{ tex \coloneq }}
  | '.' :: :: semiring {{ tex \ottmod{\hspace{-0.1ex}\cdot\hspace{-0.1ex} } }}

% === Contexts ===
  | µ :: :: dunion {{ tex \sqcup }}
%  | µ+ :: :: sdunion {{ tex \,\text{\makebox[0pt][l]{$\sqcup$}\raisebox{.40ex}{\hspace{.15ex}$\scriptscriptstyle\pm$} } }}
  | '{}' :: :: empty {{ tex \emptyset }}

% === Judgements ===
  | exists :: :: exists {{ tex \exists }}
  | != :: :: neq {{ tex \neq }}
  | <= :: :: leq {{ tex \leq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | includedin :: :: includedin {{ tex \subset }}
  % | names :: :: names {{ tex \mathcal{N} }}

% === Typing ===
  | |- :: :: turnstile {{ tex \,\vdash\, }}
  | ||- :: :: dturnstile {{ tex \,\Vdash\, }}

% === Semantics ===
  | '|' :: :: cmd {{ tex ~|~ }}
  | !! :: :: downto {{ tex ~\Downarrow~ }}

defns
Ctx :: '' ::=

defn
x in names ( D ) :: :: CtxVarIn :: CtxVarIn_ by

% defn
% l in names ( G ) :: :: CtxLblIn :: CtxLblIn_ by

defn
h in names ( D ) :: :: CtxHoleIn :: CtxHoleIn_ by

defn
x notin names ( D ) :: :: CtxVarNotIn :: CtxVarNotIn_ by

% defn
% l notin names ( G ) :: :: CtxLblNotIn :: CtxLblNotIn_ by

defn
h notin names ( D ) :: :: CtxHoleNotIn :: CtxHoleNotIn_ by

defn
fresh x :: :: FreshVar :: FreshVar_ by

% defn
% fresh l :: :: FreshLbl :: FreshLbl_ by

defn
fresh h :: :: FreshHole :: FreshHole_ by

defn
pos_assign in G :: :: PosCtxAssignIn :: PosCtxAssignIn_ by

defn
neg_assign in H :: :: NegCtxAssignIn :: NegCtxAssignIn_ by

defn
onlyPositive ( D ) :: :: CtxPos :: CtxPos_ by

defn
onlyNegative ( D ) :: :: CtxNeg :: CtxNeg_ by

defns
Eq :: '' ::=

defn
A1 = A2 :: :: EqType :: EqType_ by
defn
A1 != A2 :: :: NeqType :: NeqType_ by
defn
t = u :: :: EqTerm :: EqTerm_ by
defn
t != u :: :: NeqTerm :: NeqTerm_ by
defn
D1 = D2 :: :: EqCtx :: EqCtx_ by
defn
D1 disjoint D2 :: :: DisjointCtx :: DisjointCtx_ {{ tex [[names]]([[D1]]) \cap [[names]]([[D2]]) = \emptyset }} by

defns
Ty :: '' ::=

% defn
% D ||- e :: :: TyEff :: TyEff_ by

% -------------- :: NoEff
% {} u {} ||- o

% G u H ||- w : A
% h notin names (G)
% ------------------- :: Single
% G µ {+h : 0 n A} u H ||- h := w

% G1 u H1 µ H ||- e1
% G2 µ -H u H2 ||- e2
% G1 u H1 disjoint G2 u H2
% ------------------------- :: Union
% G1 µ G2 u H1 µ H2 ||- e1 . e2

% defn
% G |- v | e : A :: :: TyCmd :: TyCmd_ by

% G1 µ -H |- v : A
% G2 u H ||- e
% G1 disjoint G2
% ------------------ :: Cmd
% G1 µ G2 |- v | e : A


defn
D ||- w : A :: :: TyValExt :: TyValExt_ by

--------------------- :: Hole
{} u { h : 0 A } ||- h : A

---------------- :: Dest
{ @h : 0 |A|m } u {} ||- @h : |A|m

--------------------- :: Unit
{} u {} ||- () : 1

G u H ||- w : A1
--------------------- :: Inl
G u H ||- Inl w : A1 + A2

G u H ||- w : A2
--------------------- :: Inr
G u H ||- Inr w : A1 + A2

G1 u H1 ||- w1 : A1
G2 u H2 ||- w2 : A2
G1 u H1 disjoint G2 u H2
------------------------- :: Prod
G1 µ G2 u H1 µ H2 ||- (w1, w2) : A1 * A2

% TODO: should we augment age of holes which are below an exponential?
% TODO: yes so that they match their destination mode?
G u H ||- w : A
--------------------- :: Exp
m.G u m.H ||- exp m w : ! m A

-H u {} ||- v1 : A1
G2 u H ||- w2 : A2
---------------- :: Ampar
G2 u {} ||- <v1 ¤ w2> H : A1 ><| A2

G µ { x : m A1 } |- t : A2
----------------- :: Lambda
G u {} ||- \x -> t : A1 m -> A2

defn
G |- t : A :: :: TyTerm :: TyTerm_ by

G u {} ||- v : A
----------------- :: Val
G |- v : A

-------------------- :: VarNow
{ x : 0 A } |- x : A

-------------------- :: VarInf
{ x : inf A } |- x : A

G1 |- t : A1
G2 |- u : A1 m -> A2
G1 disjoint G2
----------------- :: App
m.G1 µ G2 |- t & u : A2

G1 |- t : 1
G2 |- u : B
G1 disjoint G2
----------------- :: PatUnit
G1 µ G2 |- t ; u : B

G1 |- t : A1 + A2
G2 µ { x1 : m A1 } |- u1 : B
G2 µ { x2 : m A2 } |- u2 : B
G1 disjoint G2
----------------- :: PatSum
m.G1 µ G2 |- t & \case { Inl x1 -> u1 , Inr x2 -> u2 } : B

G1 |- t : A1 * A2
G2 µ { x1 : m A1, x2 : m A2 } |- u : B
G1 disjoint G2
----------------- :: PatProd
m.G1 µ G2 |- t & \case ( x1 , x2) -> u : B

G1 |- t : !m' A
G2 µ { x : m.m' A1 } |- u : B
G1 disjoint G2
----------------- :: PatExp
m.G1 µ G2 |- t & \case exp m' x -> u : B

G1 |- t : A1 ><| A2
I.G2 µ { x : 0 A1 } |- u : B
G1 disjoint G2
-------------------------------- :: MapAmpar
G1 µ G2 |- t <&> \ x -> u : B ><| A2

G1 |- t : |A2|m
G2 |- u : A1 ><| A2
G1 disjoint G2
----------------------------- :: FillComp
G1 µ (I.m).G2 |- t <|. u : A1

G |- t : |1|m
------------------------------ :: FillUnit
G |- t <| () : 1

G |- t : |A1 + A2| m
------------------------------ :: FillInl
G |- t <| Inl : |A1|m

G |- t : |A1 + A2| m
------------------------------ :: FillInr
G |- t <| Inr : |A2|m

G |- t : |A1 * A2|m
------------------------------ :: FillProd
G |- t <| (,) : |A1|m * |A2|m

G |- t : |!m' A|m
------------------------------ :: FillExp
G |- t <| exp m' : |A|m.m'

-------------------------------- :: Alloc
{} |- alloc A : |A|0 ><| A

G |- t : A
------------------------------- :: ToAmpar
G |- toAmpar t : 1 ><| A

G |- t : 1 ><| A
------------------------------- :: FromAmpar
G |- fromAmpar t : A

defns
Sem :: '' ::=

defn
eff_app1 = eff_app2 :: :: EffApp :: EffApp_ {{ com (we assume effect lists are $\otteff{\varepsilon}$-terminated) }} by

------------- :: NoEff
apply (o, w H) = o , w H

% Those two conditions ensures that no destination escapes its inner scope
% TODO Should we put them there?
% G' u _ ||- w' : A
% G' disjoint -H
h notin names(H)
--------------------- :: Skip
apply (h := w2 . e, w1 H) = h := w2 .^ apply (e, w1 H)

% ------------------ :: FillUnit
% apply(h := () . e, w H µ { -h : 0 1 }) = apply(e , w[h := ()] H)

% ------------------ :: FillInl
% apply(h := Inl h' . e, w H µ { -h : 0 A1 + A2 }) = apply(e , w[h := Inl h'] H µ {-h' : 0 A1})

% ------------------ :: FillInr
% apply(h := Inr h' . e, w H µ { -h : 0 A1 + A2 }) = apply(e , w[h := Inr h'] H µ {-h' : 0 A2})

% ------------------ :: FillProd
% apply(h := (h1, h2) . e, w H µ { -h : 0 A1 * A2 }) = apply(e , w[h := (h1, h2)] H µ {-h1 : 0 A1, -h2 : 0 A2})

_ u H' ||- w2 : A
H µ { h : m A } disjoint H'
--------------------- :: FillComp {{ com \quad\textnormal{(Encompasses all other \textsc{Fill} rules)} }}
apply (h := w2 . e, w1 H µ { h : m A }) = apply (e, w1[h := w2] H µ m.H')

defn
t !! v | e :: :: BigStep :: BigStep_ by

------------------ :: Val
v !! v | o

t1 !! v1 | e1
t2 !! \x -> u | e2
u[x := v1] !! v3 | e3
------------------ :: App
t1 & t2 !! v3 | (e1 . e2) . e3

t1 !! () | e1
t2 !! v2 | e2
----------------------- :: PatUnit
t1 ; t2 !! v2 | e1 . e2

t !! Inl v1 | e1
u1[x1 := v1] !! v2 | e2
----------------------- :: PatInl
t & \case { Inl x1 -> u1, Inr x2 -> u2 } !! v2 | e1 . e2

t !! Inr v1 | e1
u2[x2 := v1] !! v2 | e2
----------------------- :: PatInr
t & \case { Inl x1 -> u1, Inr x2 -> u2 } !! v2 | e1 . e2

t !! (v1,v2) | e1
u[x1 := v1, x2 := v2] !! v2 | e2
----------------------- :: PatProd
t & \case (x1,x2) -> u !! v2 | e1 . e2

% Can e1 have effect on the content of the ampar? I don't think so, but maybe
t !! < v1 ¤ w2 > H | e1
u[x := v1] !! v3 | e2
e3, w4 H' = apply(e2, w2 H)
---------------------------------- :: MapAmpar
t <&> \ x -> u !! <v3 ¤ w4> H' | e1 . e3

fresh h
-------------------------- :: Alloc
alloc A !! < @h ¤ h > { h : 0 A } | o

t !! v | e
----------------------------------------- :: ToAmpar
toAmpar t !! < () ¤ v > {} | e

t !! < () ¤ v > {} | e
-------------------------------------- :: FromAmpar
fromAmpar t !! v | e

t !! @h | e
------------------------------------- :: FillUnit
t <| () !! () | e . h := ()

t !! @h | e
fresh h'
--------------------------------------- :: FillInl
t <| Inl !! @h' | e . h := Inl h'

t !! @h | e
--------------------------------------- :: FillInr
t <| Inr !! @h' | e . h := Inr h'

t !! @h | e
fresh h1
fresh h2
--------------------------------------- :: FillProd
t <| (,) !! (@h1, @h2) | e . h := (h1,h2)

t !! @h | e1
u !! <v1 ¤ w2> H | e2
---------------------------------------- :: FillComp
t <|. u !! v1 | (e1 . e2) . h := w2

parsing
PosCtx_Disjoint <= PosCtx_Minus
NegCtx_Disjoint <= NegCtx_Minus
PosCtx_Disjoint <= PosCtx_SemiringTimes
