% minimal + latex + comments

embed
{{ tex-preamble
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{lbcolor}{RGB}{186, 58, 7}
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\mathsf{#1} }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\ottlb}[1]{\textcolor{lbcolor}{\mathit{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle indent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\heaparrow\hookrightarrow
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newcommand{\JtypeT}[1]{\textsc{JtypeT\_#1}%
}
\newcommand{\JtypeHT}[1]{\textsc{JtypeHT\_#1}%
}
\newcommand{\JtypeH}[1]{\textsc{JtypeH\_#1}%
}
\newcommand{\Jop}[1]{\textsc{Jop\_#1}%
}
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar metavariable, x, xs, y, z, uf, f, d ::=
  {{ tex \ottmv{[[metavariable]]} }}

% indexvar index, i ::=
%   {{ tex \textcolor{red}{[[index]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | x                                       ::   :: Var      {{ com variable }}
  | v :: :: Val {{ com value }}
  | t u                                    ::   :: App      {{ com application }}
  | t ; u                   ::   :: PatU     {{ com pattern-matching on unit }}
  | case t of { 1. x1 -> u1 , 2. x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
  | case t of { Nil -> u1 , x1 Cons x2 -> u2 } :: :: PatL {{ com pattern-matching on list }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on exponentiated value }}
  | alloc d A { t }                                   ::   :: Alloc    {{ com allocate data }} {{ tex \underset{\ottty{\lfloor[[A]]\rfloor \rightarrow [[A]]} }{\ottkw{alloc}~[[d]]}\,\textbf{.}\,[[t]] }}
  | t |> fillLeaf u                            ::   :: FillL    {{ com fill terminal-type destination }} {{ tex [[t]]\,\triangleleft\,[[u]] }}
  | t |> fillLeft d' { u }                          ::   :: FillV1   {{ com fill sum-type destination with variant 1 }} {{ tex [[t]]\,\triangleleft\,\ottcons{1.} [[d']]~;~[[u]] }}
  | t |> fillRight d' { u }                          ::   :: FillV2   {{ com fill sum-type destination with variant 2 }} {{ tex [[t]]\,\triangleleft\,\ottcons{2.} [[d']]~;~[[u]] }}
  | t |> fillPair d1 d2 { u }                              ::   :: FillP    {{ com fill product-type destination }} {{ tex [[t]]\,\triangleleft\,\langle [[d1]] , [[d2]] \rangle~;~[[u]] }}
  | t |> fillNil                               ::   :: FillNil {{ com fill list destination with nil }} {{ tex [[t]]\,\triangleleft\,[[Nil]] }}
  | t |> fillCons d1 d2 { u }                             ::  :: FillCons {{ com fill list destination with cons }} {{ tex [[t]]\,\triangleleft\,[[d1]] [[Cons]] [[d2]]~;~[[u]] }}
  | * l :: :: Deref {{ com note: $\ottlb{\star l}$ is not a part of the user syntax }}
  | ( t )                                   :: S :: Paren
  | b sp t b spe :: S :: BreakSpacing1
  | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ var_subs ]                             :: M :: Sub
%  | t [ x |> x' ]                            :: M :: Alpha
  | foldl t1 t2 t3 :: :: FoldL {{ com TODO: hide }}

var_sub, vs :: 'vs_' ::= {{ com variable substitution }}
  | x := t :: :: VarSub

var_subs :: 'vss_' ::= {{ com variable substitutions }}
  | vs :: :: Single
  | vs , var_subs :: :: Multiple

val, v :: 'v_' ::= {{ com unreducible value }}
  | ()                                      ::   :: Unit     {{ com unit }}
  | \ x : A . t                                ::   :: Lam      {{ com lambda abstraction }} {{ tex \lambda\aunderbrace[l1r]{\,[[x]]{:}[[A]]\,}\textbf{.}\,[[t]] }}
  | Ur t :: :: Exp {{ com exponential }}
  | ° l :: :: DerefVal {{ com note: $\ottlb{\ostar l}$ is not a part of the user syntax }}
  | l                                       :: :: Label {{ com note: $[[l]]$ is not a part of the user syntax }}

label, l :: 'l_' ::= {{ com label }} {{ tex \ottlb{[[label]]} }}

label_stmt, s :: 's_' ::= {{ com label statement }}
  | l .> 1. l' :: :: V1
  | l .> 2. l' :: :: V2
  | l .> < l1 , l2 > :: :: P
  | l .> Nil :: :: Nil
  | l .> l1 Cons l2 :: :: Cons
  | l .> null :: :: Null
  | l .> v :: :: Val
  | l .> C lbar :: M :: Generic {{ tex [[l]] \heaparrow [[C]] \ottlb{\bar{l} } }} {{ com TODO: hide. $[[l]] \heaparrow [[C]] \ottlb{\bar{l} }$ is an alias for any heap constructor }}

label_stmts :: 'ss_' ::= {{ com label statements }}
  | s :: :: Single
  | s , label_stmts :: :: Multiple

heap_context, H {{ tex \mathbb{H} }} :: 'h_' ::= {{ com label statements }}
  | empty :: :: Empty
  | { label_stmts } :: :: Stmts
  | H1 µ H2 :: :: Union

type, A, B :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{1} }}
%  | P :: :: Prim {{ com primitive type }}
  | A * B :: :: Prod {{ com product type }} {{ tex \ottty{[[A]] \otimes [[B]]} }}
  | A + B :: :: Sum {{ com sum type }}
  | A --o B :: :: LinArr {{ com linear function type }}
  | | A | :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[A]] \rfloor} }}
  | [ A ] :: :: List {{ com list type }} {{ tex \ottty{[[A]]^\star } }}
  | ! A :: :: Exp {{ com exponential }} {{ tex \ottty{![[A]]} }}
  | ( A )  :: S :: Paren {{ tex \ottty{([[A]])} }}

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : A ::  :: Var {{ com var }}
  | l : A :: :: Label {{ com label }}
  | l bar : A bar :: :: LabelBar {{ tex \ottlb{\bar{[[l]]} } : \ottty{\bar{[[A]]} } }} {{ com labels }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, G {{ tex \Gamma }}, D {{ tex \Delta }}, U {{ tex \mho }}, P {{ tex \Phi }} :: 'G_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var
  | G µ D    ::    :: Union

types, Abar {{ tex \ottty{\bar{A} } }} :: 'tys_' ::= {{ tex \ottty{[[types]]} }}
  | none :: :: None {{ tex \ottty{\bullet} }} {{ com empty type list }}
  | A :: :: Single
  | A types :: :: Multiple {{ tex [[A]]~~[[types]] }}

spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
  | s :: :: space1 {{ tex \myspace{1} }}
  | ss :: :: space2 {{ tex \myspace{2} }}
  | sss :: :: space3 {{ tex \myspace{3} }}
  | ssss :: :: space4 {{ tex \myspace{4} }}
  | sssss :: :: space5 {{ tex \myspace{5} }}
  | ssssss :: :: space6 {{ tex \myspace{6} }}

spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
  | se :: :: space1e {{ tex \myspace{1} }}
  | sse :: :: space2e {{ tex \myspace{2} }}
  | ssse :: :: space3e {{ tex \myspace{3} }}
  | sssse :: :: space4e {{ tex \myspace{4} }}
  | ssssse :: :: space5e {{ tex \myspace{5} }}
  | sssssse :: :: space6e {{ tex \myspace{6} }}

heap_constructor, C :: 'hcons_' ::= {{ tex \ottcons{[[heap_constructor]]} }}
  | ( 1. ) :: :: V1
  | ( 2. ) :: :: V2
  | ( < , > ) :: :: Pair
  | ( Nil ) :: :: Nil
  | ( Cons ) :: :: Cons

judg :: 'judg_' ::=
  | P ; U ; G |- H :: :: JtypeH
  | P ; U ; G |- H | t : A :: :: JtypeHT
  | P ; U ; G |- t : A ::  :: JtypeT
  | C : Abar >> A :: :: JtypeC
  | A is B :: :: JeqType
  | t is u :: :: JeqTerm
  | G is D :: :: JeqContext
  | H | t --> H' | t' ::  :: Jop
  | type_affect in G :: :: JctxIn
  | label_stmt in H :: :: JheapIn
  | names ( G ) /\ names ( D ) = empty :: :: JctxClash

terminals :: 'terminals_' ::=
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | * :: :: deref {{ tex \ottlb{\star} }}
  | ° :: :: valderef {{ tex \ottlb{\ostar} }}
  | + :: :: sum {{ tex \ottty{\oplus} }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: with {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | ; :: :: lseq {{ tex ~;~ }}
  | /\ :: :: intersection {{ tex \cap }}
  | empty :: :: empty {{ tex \emptyset }}
  | --> :: :: reducesto {{ tex \longrightarrow }}
  | '|>' :: :: renamedto {{ tex \,\triangleright\, }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
%   | subto :: :: subto {{ tex \underset{[:=]}{\rightarrow} }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | 1. :: :: v1 {{ tex \ottcons{1.} }}
  | 2. :: :: v2 {{ tex \ottcons{2.} }}
  | Nil :: :: nil {{ tex \ottcons{Nil} }}
  | Cons :: :: cons {{ tex {:}{:} }}
  | Ur :: :: ur {{ tex \ottcons{Ur}\, }}
%  | ++ :: :: concat {{ tex {\small{+}\mspace{-6mu}{+} } }}
%  | <- :: :: affect {{ tex \leftarrow }}
  | .> :: :: pointsto {{ tex \heaparrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | null :: :: null {{ tex \oslash }}
  | >> :: :: consarrow {{ tex \ottty{\consarrow} }}
  | is :: :: is {{ tex = }}

% defns
% JMvar :: '' ::=

% % defn
% % x != y :: :: JMVarNeq :: JMVar_ {{ com $[[x]]$~~and~~$[[y]]$ stands for different variables }} by

% defn
% x notin free ( t ) :: :: JmvarNFree :: JmvarNFree_ {{ com $[[x]]$ is not a free variable in $[[t]]$ }} by

% defn
% x in free ( t ) :: :: JmvarFree :: JmvarFree_ {{ com $[[x]]$ is a free variable used in $[[t]]$ }} by

defns
Jctx :: '' ::=

defn
names ( G ) /\ names ( D ) = empty :: :: JctxClash :: JctxClash_ {{ com $[[G]]$~~and~~$[[D]]$ are disjoint typing contexts with no clashing variable names or labels }} by

defn
type_affect in G :: :: JctxIn :: JcxtIn_ by

defns
Jheap :: '' ::=

defn
label_stmt in H :: :: JheapIn :: JheapIn_ by

defns
Jeq :: '' ::=

defn
A is B :: :: JeqType :: JeqType_ by
defn
t is u :: :: JeqTerm :: JeqTerm_ by
defn
G is D :: :: JeqContext :: JeqContext_ by

defns
Jtype :: '' ::=

defn
P ; U ; G |- H :: :: JtypeH :: JtypeH_ {{ com $[[H]]$ is a well-typed heap given heap typing context $[[P]]$, unrestricted typing context $[[U]]$ and linear typing context $[[G]]$ }} by

P1 ; U ; G |- H1
P2 ; U ; D |- H2
names(P1) /\ names(P2) = empty
names(G) /\ names(D) = empty
------------------ :: Union
P1 µ P2 ; U ; G µ D |- H1 µ H2

C : Abar >> A
P µ { l bar : A bar } ; U ; G |- H
------------------ :: Constructor
P µ { l bar : A bar, l : A } ; U ; G |- H µ { l .> C lbar }

------------------- :: Null
{ l : A } ; U ; empty |- { l .> null }

P ; U ; G |- v : A
------------------- :: Val
P µ { l : A } ; U ; G |- H µ { l .> v }

defn
P ; U ; G |- H | t : A :: :: JtypeHT :: JTypeHT_ by

P ; U ; G |- H
P ; U ; D |- t : A
names(G) /\ names(D) = empty
-------------------------------- :: Def
P ; U ; G |- H | t : A

defn
P ; U ; G |- t : A :: :: JtypeT :: JtypeT_ {{ com $[[t]]$ is a well-typed term of type $[[A]]$ given heap typing context $[[P]]$, unrestricted typing context $[[U]]$ and linear typing context $[[G]]$ }} by

--------------- :: Id
P ; U ; { x : A } |- x : A

--------------- :: Id'
P ; U µ { x : A} ; empty |- x : A

---------------- :: Unit
P ; U ; empty |- () : 1

P ; U ; empty |- t : A
----------------------- :: Exp
P ; U ; empty |- Ur t : !A

------------------------------------- :: LabelAsDest
P µ { l : A } ; U ; empty |- l : |A|

------------------------------------ :: Deref
P µ { l : A } ; U ; empty |- *l : A

------------------------------------ :: DerefVal
P µ { l : A } ; U ; empty |- °l : A

P ; U ; G µ { x : A } |- t : B
----------------------- :: Lam
P ; U ; G |- \x:A.t : A --o B

P ; U ; G |- t : A --o B
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
--------------------------------- :: App
P ; U ; G µ D |- t u : B

P ; U ; G |- t : 1
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatU
P ; U ; G µ D |- t ; u : A
%U ; G µ D |- case t of { () -> u } : A

P ; U ; G |- t : A1 * A2
P ; U ; D µ { x1 : A1 , x2 : A2 } |- u : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatP
P ; U ; G µ D |- case t of {<x1, x2> -> u} : B

P ; U ; G |- t : A1 + A2
P ; U ; D µ { x1 : A1 } |- u1 : B
P ; U ; D µ { x2 : A2 } |- u2 : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatS
P ; U ; G µ D |- case t of { 1. x1 -> u1 , 2. x2 -> u2 } : B

P ; U ; G |- t : [A]
P ; U ; D |- u1 : B
P ; U ; D µ { x1 : A , x2 : [A] } |- u2 : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatL
P ; U ; G µ D |- case t of { Nil -> u1 , x1 Cons x2 -> u2 } : B

P ; U ; G |- t : !A
P ; U µ { x : A } ; D |- u: B
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatE
P ; U ; G µ D |- case t of { Ur x -> u } : B

P ; U ; G µ { d : |A| } |- t : 1
------------------------------ :: Alloc
P ; U ; G |- alloc d A { t } : A

P ; U ; G |- t : |A|
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------- :: FillL
P ; U ; G µ D |- t |> fillLeaf u : 1

P ; U ; G |- t : |A1 + A2|
P ; U ; D µ { d' : |A1| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------- :: FillV1
P ; U ; G µ D |- t |> fillLeft d' { u } : B

P ; U ; G |- t : |A1 + A2|
P ; U ; D µ { d' : |A2| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------- :: FillV2
P ; U ; G |- t |> fillRight d' { u } : B

P ; U ; G |- t : |A1 * A2|
P ; U ; D µ { d1 : |A1| , d2 : |A2| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------------:: FillP
P ; U ; G µ D |- t |> fillPair d1 d2 { u } : B

P ; U ; G |- t : |[A]|
----------------------------------- :: FillNil
P ; U ; G |- t |> fillNil : 1

P ; U ; G |- t : |[A]|
P ; U ; D µ { d1 : |A| , d2 : |[A]| } |- u : B
names( G ) /\ names( D ) = empty
---------------------------------------------------------------- :: FillCons
P ; U ; G µ D |- t |> fillCons d1 d2 { u } : B

defn
C : Abar >> A :: :: JtypeC :: JtypeC_ {{ com Heap constructor $[[C]]$ builds a value of type $[[A]]$ given arguments of type $[[Abar]]$ }} by

-------------------  :: V1
(1.) : A >> A + B

----------------------- :: V2
(2.) : B >> A + B

--------------------------- :: Pair
(<,>) : A B >> A * B

------------------------ :: Nil
(Nil) : none >> [A]

------------------------- :: Cons
(Cons) : A [A] >> [A]

defns
Jop :: '' ::=

defn
H | t --> H' | t' :: :: reduce :: Jop_ {{ com $[[t]]$ reduces to $[[t']]$, with heap changing from $[[H]]$ to $[[H']]$ }} by

H | t --> H' | t'
------------------- :: UnderApp
H | t u --> H' | t' u

---------------------------- :: App
H | (\x:A.t) u --> H | t[x := u]

H | t --> H' | t'
--------------------------------------------- :: UnderPatU
H | t ; u --> H' | t' ; u
%case t of {() -> u} --> case t' of {() -> u}

--------------------- :: PatU
H | () ; u --> H | u

---------------------------------- :: DerefVal
H µ { l .> v } | *l --> H µ { l .> v } | v

---------------------------------- :: DerefConstructor
H µ { l .> C lbar } | *l --> H µ { l .> C lbar } | °l

H | t --> H' | t'
------------------------------------------------------------------------------- :: UnderPatS
H | case t of {1. x1 -> u1, 2. x2 -> u2} --> H' | case t' of {1. x1 -> u1, 2. x2 -> u2}

----------------------------------------- :: PatSV1
H µ { l .> 1. l' } | case °l of {1. x1 -> u1, 2. x2 -> u2} --> H µ { l .> 1. l' } | u1[x1 := *l']

----------------------------------------- :: PatSV2
H µ { l .> 2. l' } | case °l of {1. x1 -> u1, 2. x2 -> u2} --> H µ { l .> 2. l' } | u2[x2 := *l']

H | t --> H' | t'
----------------------------------------------------------------------------- :: UnderPatP
H | case t of {<x1,x2> -> u} --> H' | case t' of {<x1,x2> -> u}

-------------------------------------------------------------------------------- :: PatP
H µ { l .> <l1, l2> } | case °l of {<x1,x2> -> u} --> H µ { l .> <l1, l2> } | u[x1 := *l1, x2 := *l2]

H | t --> H' | t'
------------------------------------------------------------------------------------- :: UnderPatL
H | case t of {Nil -> u1, x1 Cons x2 -> u2} --> H' | case t' of {Nil -> u1, x1 Cons x2 -> u2}

----------------------------------------------------------------------- :: PatLNil
H µ { l .> Nil } | case °l of {Nil -> u1, x1 Cons x2 -> u2} --> H µ { l .> Nil } | u1

----------------------------------------------------------------------- :: PatLCons
H µ { l .> l1 Cons l2 } | case °l of {Nil -> u1, x1 Cons x2 -> u2} --> H µ { l .> l1 Cons l2 } | u2[x1 := *l1, x2 := *l2]

H | t --> H' | t'
------------------------------------------------------------------------------------- :: UnderPatE
H | case t of {Ur x -> u} --> H' | case t' of {Ur x -> u}

----------------------------------------------------- :: PatE
H | case Ur t of { Ur x -> u } --> H | u[x := t]

--------------------------------------------------- :: Alloc
H | alloc d A { t } --> H µ { l .> null } | t[d := l] ; *l

H | t --> H' | t'
------------------------------------- :: UnderFillL
H | t |> fillLeaf u --> H' | t' |> fillLeaf u

H | t --> H' | t'
------------------------------------- :: UnderFillL'
H | l |> fillLeaf t --> H' | l |> fillLeaf t'

H | t --> H' | t'
------------------------------------- :: UnderFillV1
H | t |> fillLeft d' {u} --> H' | t' |> fillLeft d' {u}

H | t --> H' | t'
------------------------------------- :: UnderFillV2
H | t |> fillRight d' {u} --> H' | t' |> fillRight d' {u}

H | t --> H' | t'
------------------------------------- :: UnderFillP
H | t |> fillPair d1 d2 {u} --> H' | t' |> fillPair d1 d2 {u}

H | t --> H' | t'
------------------------------------- :: UnderFillNil
H | t |> fillNil --> H' | t' |> fillNil

H | t --> H' | t'
------------------------------------- :: UnderFillCons
H | t |> fillCons d1 d2 {u} --> H' | t' |> fillCons d1 d2 {u}

------------------------------------------------------------ :: FillL
H µ { l .> null } | l |> fillLeaf v --> H µ { l .> v } | ()

------------------------------------------------------------ :: FillV1
H µ { l .> null } | l |> fillLeft d' { t } --> H µ { l .> 1. l', l' .> null } | t[d' := l']

------------------------------------------------------------ :: FillV2
H µ { l .> null } | l |> fillRight d' { t } --> H µ { l .> 2. l', l' .> null } | t[d' := l']

----------------------------------------------- :: FillP
H µ { l .> null } | l |> fillPair d1 d2 { t } --> H µ { l .> <l1, l2> , l1 .> null, l2 .> null } | t[d1 := l1, d2 := l2]

----------------------------------------------- :: FillNil
H µ { l .> null } | l |> fillNil --> H µ { l .> Nil } | ()

----------------------------------------------------- :: FillCons
H µ { l .> null } | l |> fillCons d1 d2 { t } --> H µ { l .> l1 Cons l2 , l1 .> null, l2 .> null } | t[d1 := l1, d2 := l2]

embed
{{ tex

\begin{lem}[Canonical forms]

Let $[[v]]$ be a value such that $[[P ; U ; G |- H | v : A]]$.

\begin{tabular}{ll}
Type & Value \\
$[[A is 1]]$ & $[[v is ()]]$ \\
$[[A is B1 * B2]]$ & $[[v is °l]] ~~\land~~ [[l .> <l1, l2> in H]]$ \\
$[[A is B1 + B2]]$ & $[[v is °l]] ~~\land~~ \left([[l .> 1. l' in H]]~~\lor~~[[l .> 2. l' in H]]\right)$ \\
$[[A is B1 --o B2]]$ & $[[v is \x:B1.t]]$ \\
$[[A is |B|]]$ & $[[v is l]]$ \\
$[[A is [B] ]]$ & $[[v is °l]] ~~\land~~ \left([[l .> Nil in H]] ~~\lor~~[[l .> l1 Cons l2 in H]]\right)$ \\
$[[A is !B ]]$ & $[[v is Ur t]]$\\
\end{tabular}

\bigskip

\noindent\textit{Proof:}

\begin{itemize}

\item If $[[A is 1]]$:
\begin{itemize}
\item $[[v]]$ cannot be one of $[[\x:A'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
\item $[[v]]$ can be $[[()]]$ (\JtypeT{Unit})
\item Let $[[v is °l]]$. Because $[[°l]]$ is not part of the user syntax, it would have been produced by either \Jop{DerefVal} or \Jop{DerefConstructor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \Jop{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \JtypeH{Constructor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : 1 in P]]$ from \JtypeT{DerefVal}, so we need a heap constructor $[[C : Abar >> 1]]$ (by application of \JtypeH{Constructor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
\end{itemize}
So $[[P ; U ; G |- H | v : 1]] \implies [[v is ()]]$

\item If $[[A is B1 * B2]]$:
\begin{itemize}
\item $[[v]]$ cannot be one of $[[()]]$, $[[\x:A'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
\item Let $[[v is °l]]$. Because $[[°l]]$ is not part of the user syntax, it would have been produced by either \Jop{DerefVal} or \Jop{DerefConstructor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \Jop{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \JtypeH{Constructor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : B1 * B2 in P]]$ from \JtypeT{DerefVal}, so we need a heap constructor $[[C : Abar >> B1 * B2]]$ (by application of \JtypeH{Constructor}). There is only one such $[[C]]$: $[[(<,>)]]$. In addition, we should have $[[l .> <l1, l2> in H]]$ (still from \JtypeH{Constructor}).
\end{itemize}
So $[[P ; U ; G |- H | v : B1 * B2]] \implies [[v is °l]] ~~\land~~ [[l .> <l1, l2> in H]]$

\item If $[[A is B1 + B2]]$:
\begin{itemize}
\item $[[v]]$ cannot be one of $[[()]]$, $[[\x:A'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
\item Let $[[v is °l]]$. Because $[[°l]]$ is not part of the user syntax, it would have been produced by either \Jop{DerefVal} or \Jop{DerefConstructor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \Jop{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \JtypeH{Constructor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : B1 + B2 in P]]$ from \JtypeT{DerefVal}, so we need a heap constructor $[[C : Abar >> B1 + B2]]$ (by application of \JtypeH{Constructor}). There are two constructors matching this criterion: $[[(1.)]]$~~and~~$[[(2.)]]$. With the former, we should have $[[l .> 1. l' in H]]$, and with the latter, we should have $[[l .> 2. l' in H]]$ (still from \JtypeH{Constructor}).
\end{itemize}
So $[[P ; U ; G |- H | v : B1 + B2]] \implies [[v is °l]] ~~\land~~ \left([[l .> 1. l' in H]]~~\lor~~[[l .> 2. l' in H]]\right)$

\item If $[[A is B1 --o B2]]$:
\begin{itemize}
\item $[[v]]$ cannot be one of $[[()]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
\item $[[v]]$ can be $[[\x:B1.t]]$ (\JtypeT{Lam})
\item Let $[[v is °l]]$. Because $[[°l]]$ is not part of the user syntax, it would have been produced by either \Jop{DerefVal} or \Jop{DerefConstructor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \Jop{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \JtypeH{Constructor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : B1 --o B2 in P]]$ from \JtypeT{DerefVal}, so we need a heap constructor $[[C : Abar >> B1 --o B2]]$ (by application of \JtypeH{Constructor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
\end{itemize}
So $[[P ; U ; G |- H | v : B1 --o B2]] \implies [[v is \x:B1.t]]$

\item If $[[A is |B|]]$:
\begin{itemize}
\item $[[v]]$ cannot be one of $[[()]]$, $[[\x:B'.t]]$ or $[[Ur t]]$ (Inversion lemma).
\item $[[v]]$ can be $[[l]]$ (\JtypeT{LabelAsDest}), in which case $[[l : A in P]]$.
\item Let $[[v is °l]]$. Because $[[°l]]$ is not part of the user syntax, it would have been produced by either \Jop{DerefVal} or \Jop{DerefConstructor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \Jop{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \JtypeH{Constructor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : |B| in P]]$ from \JtypeT{DerefVal}, so we need a heap constructor $[[C : Abar >> |B|]]$ (by application of \JtypeH{Constructor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
\end{itemize}
So $[[P ; U ; G |- H | v : |B|]] \implies [[v is l]]$

\item If $[[A is [B] ]]$:
\begin{itemize}
\item $[[v]]$ cannot be one of $[[()]]$, $[[\x:B'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
\item Let $[[v is °l]]$. Because $[[°l]]$ is not part of the user syntax, it would have been produced by either \Jop{DerefVal} or \Jop{DerefConstructor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \Jop{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \JtypeH{Constructor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : [B] in P]]$ from \JtypeT{DerefVal}, so we need a heap constructor $[[C : Abar >> [B] ]]$ (by application of \JtypeH{Constructor}). There are two constructors matching this criterion: $[[(Nil)]]$~~and~~$[[(Cons)]]$. With the former, we should have $[[l .> Nil in H]]$, and with the latter, we should have $[[l .> l1 Cons l2 in H]]$ (still from \JtypeH{Constructor}).
\end{itemize}
So $[[P ; U ; G |- H | v : [B] ]] \implies [[v is °l]] ~~\land~~ \left([[l .> Nil in H]] ~~\lor~~[[l .> l1 Cons l2 in H]]\right)$

\item If $[[A is !B ]]$:
\begin{itemize}
\item $[[v]]$ cannot be one of $[[()]]$, $[[\x:B'.t]]$ or $[[l]]$ (Inversion lemma).
\item $[[v]]$ can be $[[Ur t]]$ (\JtypeT{Exp}).
\item Let $[[v is °l]]$. Because $[[°l]]$ is not part of the user syntax, it would have been produced by either \Jop{DerefVal} or \Jop{DerefConstructor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \Jop{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \JtypeH{Constructor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : [B] in P]]$ from \JtypeT{DerefVal}, so we need a heap constructor $[[C : Abar >> !B]]$ (by application of \JtypeH{Constructor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
\end{itemize}
So $[[P ; U ; G |- H | v : !B ]] \implies [[v is Ur t]]$

\end{itemize}
\end{lem}

\begin{lem}[Inversion of the typing relation]\phantom{nl}

\begin{itemize}
\item If $[[P ; U ; G |- x : A]]$, then either $[[G is {x : A}]]$ or $[[x : A in U]]~\land~[[G is empty]]$ (\JtypeT{Id} and \JtypeT{Id'})
\item If $[[P ; U ; G |- () : A]]$, then $[[G is empty]]$~~and~~$[[A is 1]]$ (\JtypeT{Unit})
\item If $[[P ; U ; G |- Ur t : A]]$ then $[[G is empty]]$ and there is some type $[[B]]$ such that $[[A is !B]]$~~and~~$[[P ; U ; empty |- t : B]]$ (\JtypeT{Exp})
\item If $[[P ; U ; G |- l : A]]$ then $[[G is empty]]$ and there is some type $[[B]]$ such that $[[A is |B|]]$~~and~~$[[l : B in P]]$ (\JtypeT{LabelAsDest})
\item If $[[P ; U ; G |- *l : A]]$ then $[[G is empty]]$~~and~~$[[l : A in P]]$ (\JtypeT{Deref})
\item If $[[P ; U ; G |- °l : A]]$ then $[[G is empty]]$~~and~~$[[l : A in P]]$ (\JtypeT{DerefVal})
\item If $[[P ; U ; G |- \x:B1.t:A]]$, then there is some type $[[B2]]$ such that $[[A is B1 --o B2]]$~~and~~$[[P ; U ; G µ {x:B1} |- t : B2]]$ (\JtypeT{Lam})
\item If $[[P ; U ; G |- t u : A]]$, then there are some type $[[B]]$ and contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : B --o A]]$,~~~$[[P ; U ; D2 |- u : B]]$~~and~~$[[G is D1 µ D2]]$ (\JtypeT{App})
\item If $[[P ; U ; G |- t ; u : A]]$ then there are some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : 1]]$,~~~$[[P ; U ; D2 |- u : A]]$, and $[[G is D1 µ D2]]$ (\JtypeT{PatU})
\item If $[[P ; U ; G |- case t of { <x1, x2> -> u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : B1 * B2]]$,~~~$[[P ; U ; D2 µ { x1 : B1, x2 : B2 } |- u : A]]$ and , and $[[G is D1 µ D2]]$ (\JtypeT{PatP})
\item If $[[P ; U ; G |- case t of { 1.x1 -> u1, 2.x2 -> u2 } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : B1 + B2]]$,~~~$[[P ; U ; D2 µ { x1 : B1 } |- u1 : A]]$,~~~$[[P ; U ; D2 µ { x2 : B2 } |- u2 : A]]$~~and~~$[[G is D1 µ D2]]$ (\JtypeT{PatS})
\item If $[[P ; U ; G |- case t of { Nil -> u1, x1 Cons x2 -> u2 } : A]]$ then there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : [B] ]]$,~~~$[[P ; U ; D2 |- u1 : A]]$,~~~$[[P ; U ; D2 µ { x1 : B, x2 : [B] } |- u2 : A]]$~~and~~$[[G is D1 µ D2]]$ (\JtypeT{PatL})
\item If $[[P ; U ; G |- case t of { Ur x -> u } : A]]$ then there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : !B]]$,~~~$[[P ; U µ {x : B} ; D2 |- u : A]]$ and and $[[G is D1 µ D2]]$ (\JtypeT{PatE})
\item If $[[P ; U ; G |- t |> fillLeaf u : A]]$ then $[[A is 1]]$ and there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B|]]$,~~~$[[P ; U ; D2 |- u : B]]$~~and~~$[[G is D1 µ D2]]$ (\JtypeT{FillL})
\item If $[[P ; U ; G |- t |> fillLeft d' { u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B1 + B2|]]$,~~~$[[P ; U ; D2 µ { d' : |B1| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\JtypeT{FillV1})
\item If $[[P ; U ; G |- t |> fillRight d' { u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B1 + B2|]]$,~~~$[[P ; U ; D2 µ { d' : |B2| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\JtypeT{FillV2})
\item If $[[P ; U ; G |- t |> fillPair d1 d2 { u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B1 * B2|]]$,~~~$[[P ; U ; D2 µ { d1 : |B1|, d2 : |B2| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\JtypeT{FillP})
\item If $[[P ; U ; G |- t |> fillNil : A]]$ then $[[A is 1]]$ and there is some type $[[B]]$ such that $[[P ; U ; G |- t : |[B]| ]]$ (\JtypeT{FillNil})
\item If $[[P ; U ; G |- t |> fillCons d1 d2 { u } : A]]$ then there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |[B]|]]$,~~~$[[P ; U ; D2 µ { d1 : |B|, d2 : |[B]| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\JtypeT{FillP})

\end{itemize}

\bigskip

\noindent\textit{Proof:}

\smallskip

Immediate from the definition of the typing relation.

\end{lem}

\bigskip
\togglespaces

\noindent\textbf{Example 1 :} implementation of $\ottkw{map}$ with $\ottkw{foldl}$

\[\begin{array}{l}
\ottkw{map} \defeq [[
\uf: !(A --o B). \xs: [A]. \d0: |[B]|. (
b s (foldl
b ss case uf of { Ur f -> Ur (
b sss \d: |[B]|. \x: A. (d |> fillCons d1 d2 { d1 |> fillLeaf (f x) ; d2 })
b sse )}
b ss d0
b ss xs
) b se |> fillNil)
]]
\end{array}\]
}}


parsing
v_Lam <= t_Sub
t_PatU <= t_App
t_PatU <= t_FillL
judg_JheapIn <= s_V1
hcons_V1 <= terminals_v1
