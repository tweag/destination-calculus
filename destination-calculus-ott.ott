% minimal + latex + comments

embed
{{ tex-preamble
\usepackage{stmaryrd}
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{bbold}
\DeclareSymbolFont{bbsymbol}{U}{bbold}{m}{n}
\DeclareMathSymbol{\bbsemicolon}{\mathbin}{bbsymbol}{"3B}
\DeclareMathSymbol{\bbcomma}{\mathbin}{bbsymbol}{"2C}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{multcolor}{RGB}{26, 87, 186}
\definecolor{lbcolor}{RGB}{186, 58, 7}
\definecolor{scopecolor}{RGB}{200, 120, 211}
\definecolor{effcolor}{RGB}{186, 58, 7}
\definecolor{eccolor}{RGB}{58, 120, 7}
\definecolor{kwcolor}{RGB}{0, 0, 0}
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\textcolor{kwcolor}{\mathsf{#1} } }
\newcommand{\ottdefault}[1]{\textcolor{black}{\mathsf{#1} } }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\ottlb}[1]{\textcolor{lbcolor}{#1} }
\newcommand{\ottscope}[1]{\textcolor{scopecolor}{\mathsf{#1} } }
\newcommand{\otteff}[1]{\textcolor{effcolor}{\mathsf{#1} } }
\newcommand{\ottec}[1]{\textcolor{eccolor}{#1} }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\ottmult}[1]{\textcolor{multcolor}{\mathit{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle destent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\storearrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyStore}[1]{\textsc{TyStore\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\small\itshape #1} }
\newcommand{\holearrowgen}[1]{\ottho{\text{#1}\!\!\!\rightharpoonup} } % 
\def\restriction#1#2{\mathchoice
              {\setbox1\hbox{${\displaystyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\textstyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptscriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} } }
\def\restrictionaux#1#2{ {#1\,\smash{\vrule height .8\ht1 depth .85\dp1} }_{\,#2} }
\usepackage[safe]{tipa}
\newcommand{\mpar}{\ottty{\text{\large\textramshorns} } }
\newcommand{\mparcomma}{ {\scriptstyle\odot} }
\newcommand{\expc}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{-.1ex}{\hspace{-0.4ex}\scriptsize c} } }\hspace{-0.7ex} }
\newcommand{\expw}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{0.05ex}{\hspace{-0.6ex}${\scriptscriptstyle\omega}$} } }\hspace{-0.7ex} }
\newcommand{\putarrow}[1]{\!\overset{#1}{\triangleleft}\!}
\newcommand{\lam}[3]{\ottcons{\lambda}\,#1\!:\!#2\,\textbf{.}\,#3}
\newcommand{\Lam}[2]{\ottcons{\Lambda}\,#1\,\textbf{.}\,#2}
\newcommand{\nuabs}[1]{\nu#1\textbf{.}\,}
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar termvar, x, y, h ::=
  {{ tex \ottmv{[[termvar]]} }}

metavar idxvar, i ::=
  {{ tex \ottmv{[[idxvar]]} }}

grammar

% label, l :: 'l_' ::= {{ tex \ottlb{[[label]]} }}

type, A, B :: 'Ty_' ::= {{ com Type }} {{ tex \ottty{[[type]]} }}
  | P ^ n :: :: ScopeIdx {{ tex [[P]]^{[[n]]} }}

%ref_type, R :: 'RefTy_' ::= {{ com Reference type }} {{ tex \ottty{[[ref_type]]} }}
%non_ref_type, N :: 'NonRefTy_' ::= {{ com Non-reference type }} {{ tex \ottty{[[non_ref_type]]} }}

partial_type, T :: 'PTy_' ::= {{ tex \ottty{[[partial_type]]} }}
  % | _|_ :: :: Bottom {{ tex \ottty{\bot} }}
  % | n1 <w n2 :: :: Witness {{ tex \ottty{[[n1]]\overset{w}{<}[[n2]]} }} {{ com Scope nesting witness }}
  | 1 :: :: Unit {{ tex \ottty{1} }} {{ com Unit }}
  | A1 + A2 :: :: Sum {{ tex \ottty{[[A1]] \oplus [[A2]]} }} {{ com Sum }}
  | A1 * A2 :: :: Prod {{ tex \ottty{[[A1]] \otimes [[A2]]} }} {{ com Product }}
%  | Box N :: :: Box {{ tex \ottty{Box\,[[N]]} }} {{ com Non-reference type stored in the heap }}
  | A1 --o A2 :: :: Lambda {{ tex \ottty{_{[[n1]]}[[A1]]\,[[--o]]\,_{[[n2]]}[[A2]]} }} {{ com Linear function }}
  | Dest A :: :: Dest {{ tex \ottty{Dest\,_{[[n]]}[[A]]} }} {{ com Destination }}
  | A1 i ><| A2 :: :: Incomplete {{ tex \ottty{[[A1]]~_{[[i]]}\![[><|]]\,[[A2]]} }} {{ com Incomplete type (consuming $[[A1]]$ yields $[[A2]]$) }}
  % | A1 ><| A2 :: :: Incomplete {{ tex \ottty{[[A1]]\,[[><|]]\,[[A2]]} }} {{ com Incomplete type (consuming $[[A1]]$ yields $[[A2]]$) }}
  | ( P ) :: S :: Paren {{ tex \ottty{\left(}[[P]]\ottty{\right)} } }}

scope_index, s :: 'ScIdx_' ::= {{ com Concrete or abstract scope index }} {{ tex \ottscope{[[scope_index]]} }}
  | i :: :: Var
  | n :: :: Val

concrete_scope_index, n, m :: 'CScIdx_' ::= {{ com Concrete scope index }} {{ tex \ottscope{[[concrete_scope_index]]} }}
  | 0 :: :: Zero {{ tex \ottscope{0} }}
  | n + 1 :: :: Succ {{ tex [[n]]\ottscope{+1} }}
  | max ( n1 , n2 ) :: :: Maxnn
  | max ( n, G ) :: :: MaxnCtx
  | max ( G ) :: :: MaxCtx
  | _ :: M :: Placeholder
  | ( n ) :: S :: Paren {{ tex \ottscope{([[n]])} }}

% heap form: { @l1: hv1, @l2: hv2 }
dynamic_value, v :: 'DynVal_' ::= {{ com dynamic value }}
  % | o :: :: Bottom
  % | W :: :: Witness {{ tex \Lam{[[s]]}{[[n]]} }} {{ com Unit-like representation for witnesses }}
  | x :: :: VarHole {{ com Var or Hole }}
  | @ x :: :: Dest {{ tex \ottmv{@}[[x]] }} {{ com Destination }}
  | () :: :: Unit {{ com Unit }}
  | Inl v :: :: Inl {{ com Left variant for sum }}
  | Inr v :: :: Inr {{ com Right variant for sum }}
  | < v1 , v2 > :: :: Prod {{ tex \ottcons{\langle}\,[[v1]]\,\ottcons{,}~[[v2]]\,\ottcons{\rangle} }} {{ com Product }}
  | < v1 ¤ v2 > :: :: Incomplete {{ tex \ottcons{\langle}\,[[v1]]\,\ottcons{\bbcomma}~[[v2]]\,\ottcons{\rangle} }} {{ com Incomplete ($[[v2]]$ is the root of the structure being built) }}
  | \ x : A . t :: :: Lambda {{ tex \lam{[[x]]}{[[A]]}{[[t]]} }} {{ com linear function }}
  | ( v ) :: S :: Paren

term, t, u :: 'Term_' ::=                                               {{ com Term }}
  | v :: :: DynVal {{ com dynamic value }}
  | t u                                    ::   :: App      {{ com application }}
  % | t1 . t2 :: :: Transivity {{ com apply transitivity to scope witnesses }}
  % | box t :: :: Box {{ com store non-reference value in the heap }}
  % | * t :: :: Deref {{ tex \star[[t]] }} {{ com get non-reference value from the heap }}

  | t ; u                   ::   :: PatUnit {{ com discard unit }}
%  | case t of { () -> u } :: :: PatU {{ com pattern-match on unit }} {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{\,[[()]]\,[[->]]\,[[u]]\,\} }}
  | case t of { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatSum     {{ com pattern-match on sum }} {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{\,\ottcons{Inl}\,[[x1]]\,[[->]]\,[[u1]]\,,~\ottcons{Inr}\,[[x2]]\,[[->]]\,[[u2]]\,\} }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatProd     {{ com pattern-match on product }} {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{\,\ottcons{\langle}\,[[x1]]\,\ottcons{,}~[[x2]]\,\ottcons{\rangle}\,[[->]]\,[[u]]\,\} }}
  | case t of { < x ¤ _ > -> < u ¤ _ > } :: :: MapIncomplete {{ com map over the left side of the incomplete $[[t]]$ }} {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{\,\ottcons{\langle}\,[[x]]\,\ottcons{\bbcomma}~\_\,\ottcons{\rangle}\,[[->]]\,\ottcons{\langle}\,[[u]]\,\ottcons{\bbcomma}~\_\,\ottcons{\rangle}\,\} }}

  | alloc :: :: Alloc {{ com return a fresh Incomplete object }}
  | into t :: :: IntoIncomplete {{ com transform the ref value into a trivial incomplete }}
  | from t :: :: FromIncomplete {{ com transform a trivial incomplete into a ref value}}
  | t <| () :: :: FillUnit {{ com fill destination with unit }}
  | t <| Inl                          ::   :: FillInl   {{ com fill destination with left variant }}
  | t <| Inr                          ::   :: FillInr   {{ com fill destination with right variant }}
  | t <| <,>                              ::   :: FillProd    {{ com fill destination with product constructor }}
  | t <|. u :: :: FillComp {{ com fill destination with root of Incomplete $[[u]]$ }}

  | ( t )                                   :: S :: Paren
  | t [ e ]                             :: M :: SubEff
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
  % | t b spe :: S :: BreakSpacing3

sub :: 'Sub_' ::= {{ com variable or label substitution }}
  | x := v :: :: VarSub
  % | x := t :: :: VarSub

subs :: 'Subs_' ::= {{ com variable or  substitutions }}
  | sub :: :: Single
  | sub , subs :: :: Multiple

effect, e :: 'e_' ::= {{ tex \otteff{[[effect]]} }}
  | o :: :: NoEff {{ com empty effect }} {{ tex \otteff{\varepsilon} }}
  | subs :: :: Sub

% heap_affect, ha :: 'HeapAff_' ::=
%   | l = hv :: :: Aff {{ tex [[l]]\,=\,[hv]] }}

% heap_affects :: 'HeapAffs_' ::=
%   | ha :: :: Single
%   | ha , heap_affects :: :: Multiple

% heap, H :: 'Heap_' ::=
%   | empty :: :: Empty
%   | { heap_affects } :: :: Affs
%   | H1 µ H2 :: :: Disjoint

type_affect, ta :: 'TyAff_' ::= {{ com type affectation }}
  | x : n A :: :: VarHole {{ com Var or Hole }} {{ tex [[x]]:^{[[n]]}\,[[A]] }}
  | - x : n A :: :: Dest {{ com Destination }} {{ tex \ottmv{-}[[x]]:^{[[n]]}\, [[A]] }}

type_affects :: 'TyAffs_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, U {{ tex \mho }}, G {{ tex \Gamma }} :: 'TyCtx_' ::= {{ com typing context }}
  | {}    ::   :: Empty
  | { type_affects } ::    :: Affs
  | G1 µ G2    ::    :: Disjoint
  | G1 µ+ G2 :: :: DisjointInteract
  % | G1 µ~ G2 :: :: HDisjoint

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=
  | := :: :: subwith {{ tex := }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | ><| :: :: rtimes {{ tex \ottty{\rtimes} }}
  | ->                                     ::   :: mapsto       {{ tex \mapsto }}
  | |- :: :: turnstile {{ tex \vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | µ+ :: :: sdunion {{ tex \,\text{\makebox[0pt][l]{$\sqcup$}\raisebox{.40ex}{\hspace{.15ex}$\scriptscriptstyle\pm$} } }}
  % | µ~ :: :: hdunion {{ tex \,\text{\makebox[0pt][l]{$\sqcup$}\raisebox{-.7ex}{\hspace{.18ex}\text{\textasciitilde}\!}~\,} }}
  | '{}' :: :: empty {{ tex \{\} }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  % | b :: :: linebreak {{ tex \mynewline }}
  % | o :: :: bottom {{ tex \ottcons{\bullet} }}
  | () :: :: unit {{ tex \ottcons{()} }}
  | Inl :: :: inl {{ tex \ottcons{Inl} }}
  | Inr :: :: inr {{ tex \ottcons{Inr} }}
  | <,> :: :: prod {{ tex \ottcons{\langle{,}\rangle} }}
  | <| :: :: fill {{ tex \triangleleft }}
  | <|. :: :: fillcomp {{ tex \triangleleft\cdot\, }}
  % | <&> :: :: flipmap {{ tex \succ\!\!\!\succ }}
  % | S :: :: s {{ tex \ottcons{S} }}
  % | !c :: :: expc {{ tex \expc{} }}
  % | !w :: :: expw {{ tex \expw{} }}
  % | mpar :: :: mpar {{ tex \mpar{} }}
  % | Dest :: :: dest {{ tex \ottcons{Dest}\, }}
  % | <| :: :: pointsto {{ tex \storearrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | !! :: :: downto {{ tex \Downarrow }}
  % | =fix :: :: fix {{ tex \overset{\mathsf{fix} }{=} }}
  % | _!_ :: :: bottom {{ tex \ottty{\bot} }}
  | includedin :: :: includedin {{ tex \subset }}
  | names :: :: names {{ tex \mathcal{N} }}
  | => :: :: implies {{ tex \implies }}
  % | and :: :: land {{ tex \land }}
  | ';' :: :: sep {{ tex ~;\, }}
  % | '.' :: :: comp {{ tex \,.\, }}
  % | * :: :: deref {{ tex \star }}
  | ¤ :: :: mparcomma {{ tex \mparcomma }}
  | --> :: :: rlocal {{ tex \longrightarrow }}
  | ~~> :: :: rglobal {{ tex \rightsquigarrow }}
  % | with :: :: with {{ tex ~\textsf{with}~ }}
  % | nu :: :: nu {{ tex \nu\! }}
  % | \/ :: :: or {{ tex ~~\lor~~ }}

defns
Ctx :: '' ::=

defn
x != y :: :: CtxVarNe :: CtxVarNe_ by

defn
x in names ( G ) :: :: CtxVarIn :: CtxVarIn_ by

defn
x in names ( G ) :: :: CtxLblIn :: CtxLblIn_ by

defn
x notin names ( G ) :: :: CtxVarNotIn :: CtxVarNotIn_ by

defn
l notin names ( G ) :: :: CtxLblNotIn :: CtxLblNotIn_ by

defn
type_affect in G :: :: CtxTyAffIn :: CtxTyAffIn_ by

defn
ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 :: CtxDisjoint2_ {{ com $[[G1]]$~~and~~$[[G2]]$ are disjoint typing contexts}} {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }} by

defn
G3 = G1 µ+ G2 :: :: CtxInteract :: CtxInteract_

defn
fresh x :: :: FreshVarHole :: FreshVarHole_ by

% defns
% Heap :: '' ::=

% defn
% heap_affect in H :: :: HeapAffIn :: HeapAffIn_ by

% defn
% l in names ( H ) :: :: HeapLblIn :: HeapLblIn_ by

% defn
% l notin names ( H ) :: :: HeapLblNotIn :: HeapLblNotIn_ by

defns
Eq :: '' ::=

defn
A1 = A2 :: :: EqType :: EqType_ {{ tex [[A1]] = [[A2]] }} by
defn
A1 != A2 :: :: NeqType :: NeqType_ {{ tex [[A1]] \neq [[A2]] }} by
defn
t = u :: :: EqTerm :: EqTerm_ {{ tex [[t]] = [[u]] }} by
defn
G = D :: :: EqContext :: EqContext_ {{ tex [[G]] = [[D]] }} by

defns
Scope :: '' ::=

defn
s1 < s2 :: :: ScopeLt :: ScopeLt_ by
defn
s1 <= s2 :: :: ScopeLeq :: ScopeLeq_ {{ tex [[s1]] \leq [[s2]] }} by
defn
s1 > s2 :: :: ScopeGt :: ScopeGt_ by
defn
s1 >= s2 :: :: ScopeGeq :: ScopeGeq_ {{ tex [[s1]] \geq [[s2]] }} by

defns
Ty :: '' ::=

% Une dest qui parait plus vieille qu'elle ne l'est réellement (donc qui aurait une date de naissance plus petite que la vraie) peut fuiter dans le scope parent en étant utilisée comme valeur stockée. C'est un problème immédiat, qui doit être étendu à tout conteneur qui contiendrait une telle dest => Date de naissance d'un truc = max de la date de naissance de ses composants

% Une dest qui parait plus jeune qu'elle ne l'est pourrait servir à faire fuiter une dest dans le scope parent, mais impossible tant que son type ne change pas -> aucun problème à prendre le max des dates de naissance.

defn
s G |- t : n A :: :: TyTerm :: TyTerm_ {{ tex ^{[[s]]}\,[[G]][[|-]][[t]]:^{[[n]]}\,[[A]] }} by

% m G |- t : n A
% ----------------- :: FastForward
% m + 1 G |- t : n A

---------------- :: VarHole
m { x : A } |- x : A

n <= m
---------------- :: Dest
m { - x : A } |- @x : (Dest A)^s

---------------- :: Unit
m {} |- () : 1^0

m G |- v : P1^n1
---------------- :: Inl
m G |- Inl v : (P1^n1 + P2^n2)^max(n1, n2)

m G |- v : P2^n2
---------------- :: Inr
m G |- Inr v : (P1^n1 + P2^n2)^max(n1, n2)

m G1 |- v1 : P1^n1
m G2 |- v2 : P2^n2
----------------- :: Prod
m G1 µ G2 |- < v1, v2 > : (P1^n1 * P2^n2)^max(n1, n2)

m G1 |- v1 : A1
m G2 |- v2 : A2
G3 = G1 µ+ G2
----------------- :: Incomplete
m G3 |- < v1 ¤ v2 > : (A1 i ><| A2)^max(A1[i := 0])

m G µ { x : A1 } |- t : A2
----------------- :: Lambda
m G |- \x:A.t : max(G) A1 --o A2

m G1 |- t : n n1 A1 --o n2 A2
m G2 |- u : n1 A1
----------------- :: App
m G1 µ G2 |- t u : n2 A2

% TODO: should be n or 0?
m G1 |- t : 0 1
m G2 |- u : A
----------------- :: PatUnit
m G1 µ G2 |- t ; u : A

m G1 |- t : (A1 + A2)^n
m G2 µ { x : A1 } |- u1 : B
m G2 µ { x : A2 } |- u2 : B
----------------- :: PatSum
m G1 µ G2 |- case t of { Inl x1 -> u1 , Inr x2 -> u2 } : B

m G1 |- t : (A1 * A2)^n
m G2 µ { x1 : A1, x2 : A2 } |- u : B
----------------- :: PatProd
m G1 µ G2 |- case t of { < x1 , x2 > -> u } : B

% inv : n <= s(Left). Any captured value must appear in the signature. if n < s(Left) it means Left is only dest neutralized by the ¤. So 
% case < @h ¤ h> of { <x ¤ _> -> <<x ¤ h> ¤ _> } ??

% mapL \() -> d : d appears in context; new lifetime = s(d) = lifetime output > before
% mapL \d -> d : d doesn't appear in context; new lifetime = old = lifetime output
% mapL \d -> () : d doesn't appear in context; new lifetime = old != lifetime output
% mapL \d1 -> d1 <| (); d2 where s(d2) < s(d1) : d2 appears in context; new lifetime = lifetime output < old
m G1 |- t : (A1 ><| A2)^n
m G2 µ { x : A1 } |- 