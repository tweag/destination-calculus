% minimal + latex + comments

% truc zarbi avec unit : il n'est pas facile/possible d'avoir fillUnit
% 1 (unit) est utilisé comme monoid dans le type des commandes
% le remplacer par bottom créé une assymétrie entre fillUnit et fillPair

% TODO
% H > Phi
% sem grand pas

embed
{{ tex-preamble
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{lbcolor}{RGB}{186, 58, 7}
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\mathsf{#1} }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\ottlb}[1]{\textcolor{lbcolor}{\mathit{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle indent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\heaparrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyHeap}[1]{\textsc{TyHeap\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar metavariable, x, xs, y, uf, f, d ::=
  {{ tex \ottmv{[[metavariable]]} }}

% indexvar index, i ::=
%   {{ tex \textcolor{red}{[[index]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | x                                       ::   :: Var      {{ com variable }}
  | z :: :: Val {{ com value }}
  | t u                                    ::   :: App      {{ com application }}
  | t ; u                   ::   :: PatU     {{ com pattern-matching on unit }}
  | case t of { 1. x1 -> u1 , 2. x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
% | case t of { Nil -> u1 , x1 Cons x2 -> u2 } :: :: PatL {{ com pattern-matching on list }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on exponentiated value }}
  | case t of { roll R x -> u } :: :: PatR {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{ \underset{[[R]] }{\ottkw{roll} }~[[x]] \mapsto [[u]] \} }} {{ com unroll for recursive types }}
  | alloc d A { t }                                   ::   :: Alloc    {{ com allocate data }} {{ tex \underset{\ottty{[[A]]} }{\ottkw{alloc}~[[d]]}\,\textbf{.}\,[[t]] }}
  | fillLeaf t u                            ::   :: FillL    {{ com fill terminal-type destination }} {{ tex [[t]]\,\triangleleft\,[[u]] }}
  | fillLeft t d' { u }                          ::   :: FillV1   {{ com fill sum-type destination with variant 1 }} {{ tex [[t]]\,\triangleleft\,\ottcons{1.} [[d']]\,\textbf{.}\,[[u]] }}
  | fillRight t d' { u }                          ::   :: FillV2   {{ com fill sum-type destination with variant 2 }} {{ tex [[t]]\,\triangleleft\,\ottcons{2.} [[d']]\,\textbf{.}\,[[u]] }}
  | fillPair t d1 d2 { u }                              ::   :: FillP    {{ com fill product-type destination }} {{ tex [[t]]\,\triangleleft\,\langle [[d1]] , [[d2]] \rangle\,\textbf{.}\,[[u]] }}
% | fillNil t                               ::   :: FillNil {{ com fill list destination with nil }} {{ tex [[t]]\,\triangleleft\,[[Nil]] }}
% | fillCons t d1 d2 { u }                             ::  :: FillCons {{ com fill list destination with cons }} {{ tex [[t]]\,\triangleleft\,[[d1]] [[Cons]] [[d2]]\,\textbf{.}\,[[u]] }}
  | * l :: :: Deref {{ com note: $\ottlb{\star l}$ is not a part of the user syntax }}
  | ( t )                                   :: S :: Paren
  | b sp t b spe :: S :: BreakSpacing1
  | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ var_subs ]                             :: M :: Sub
%  | t [ x |> x' ]                            :: M :: Alpha
%  | rolll t1 t2 t3 :: :: RollL {{ com TODO: hide }}

var_sub, vs :: 'vs_' ::= {{ com variable substitution }}
  | x := t :: :: VarSub

var_subs :: 'vss_' ::= {{ com variable substitutions }}
  | vs :: :: Single
  | vs , var_subs :: :: Multiple

data_val, v :: 'v_' ::= {{ com data value }}
  | ()                                      ::   :: Unit     {{ com unit }}
  | \ x : A . t                                ::   :: Lam      {{ com lambda abstraction }} {{ tex \lambda\aunderbrace[l1r]{\,[[x]]{:}[[A]]\,}\textbf{.}\,[[t]] }}
  | Ur t :: :: Exp {{ com exponential }}
  | roll R t :: :: Roll {{ tex \underset{[[R]] }{\ottkw{roll} }~[[t]] }} {{ com roll for recursive types }}

val, z :: 'z_' ::= {{ com unreducible value }}
  | v :: :: DataVal
  | l @ | A |                                       :: :: Label {{ com note: $[[l]]$ is not a part of the user syntax }} {{ tex {\scriptsize\vcenter{\offinterlineskip      \ialign{##\cr$\,\,\,[[l]]$\cr\noalign{\kern0.5pt}$\ottty{\lfloor[[A]]\rfloor}$\cr} } } }}
  | 1. l :: :: V1
  | 2. l :: :: V2
  | < l1 , l2 > :: :: P
  | C lbar :: M :: Generic {{ tex [[C]] \ottlb{\bar{l} } }}

label, l :: 'l_' ::= {{ com label }} {{ tex \ottlb{[[label]]} }}

label_stmt, s :: 's_' ::= {{ com label statement }}
  | l .> v :: :: Val
  | l .> 1. l' :: :: V1
  | l .> 2. l' :: :: V2
  | l .> < l1 , l2 > :: :: P
% | l .> Nil :: :: Nil
% | l .> l1 Cons l2 :: :: Cons
  | l .> null :: :: Null
  | l .> C lbar :: M :: Generic {{ tex [[l]] \heaparrow [[C]] \ottlb{\bar{l} } }} {{ com TODO: hide. $[[l]] \heaparrow [[C]] \ottlb{\bar{l} }$ is an alias for any heap constructor }}
  | l .> __ :: M :: In

label_stmts :: 'ss_' ::= {{ com label statements }}
  | s :: :: Single
  | s , label_stmts :: :: Multiple

heap_context, H {{ tex \mathbb{H} }} :: 'h_' ::= {{ com label statements }}
  | empty :: :: Empty
  | { label_stmts } :: :: Stmts
  | H1 µ H2 :: :: Union

type, A, B :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
%  | P :: :: Prim {{ com primitive type }}
  | A * B :: :: Prod {{ com product type }} {{ tex \ottty{[[A]] \otimes [[B]]} }}
  | A + B :: :: Sum {{ com sum type }}
  | A --o B :: :: LinArr {{ com linear function type }}
  | | A | :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[A]] \rfloor} }}
%  | [ A ] :: :: List {{ com list type }} {{ tex \ottty{[[A]]^\star } }}
  | ! A :: :: Exp {{ com exponential }} {{ tex \ottty{![[A]]} }}
  | ( A )  :: S :: Paren {{ tex \ottty{([[A]])} }}
  | W [ r := A ] :: M :: Sub {{ tex [[W]][ \ottmv{r} [[:=]] \ottty{[[A]]} ] }}

type_with_hole, W :: 'twh_' ::= {{ tex \ottty{[[type_with_hole]]} }}
  | r :: :: Hole {{ com type hole in recursive definition }} {{ tex \ottmv{[[r]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
  | W1 * W2 :: :: Prod {{ com product type }} {{ tex \ottty{[[W1]] \otimes [[W2]]} }}
  | W1 + W2 :: :: Sum {{ com sum type }}
  | W1 --o W2 :: :: LinArr {{ com linear function type }}
  | | W | :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[W]] \rfloor} }}
%  | [ W ] :: :: List {{ com list type }} {{ tex \ottty{[[W]]^\star } }}
  | ! W :: :: Exp {{ com exponential }} {{ tex \ottty{![[W]]} }}
  | ( W )  :: S :: Paren {{ tex \ottty{([[W]])} }}

rec_type_bound, R :: 'rtb_' ::= {{ com recursive type bound to a name }} {{ tex \ottty{[[rec_type_bound]]} }}

rec_type_def :: 'rtd_' ::=
  | µ r . W :: :: Abs {{ tex \mu\,\ottmv{[[r]]}\,\textbf{.}\,[[W]] }}

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : A ::  :: Var {{ com var }}
  | l : A :: :: Label {{ com label }}
  | l bar : A bar :: :: LabelBar {{ tex \ottlb{\bar{[[l]]} } : \ottty{\bar{[[A]]} } }} {{ com labels }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, G {{ tex \Gamma }}, D {{ tex \Delta }}, U {{ tex \mho }}, P {{ tex \Phi }} :: 'G_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var
  | G µ D    ::    :: Union

types, Abar {{ tex \ottty{\bar{A} } }} :: 'tys_' ::= {{ tex \ottty{[[types]]} }}
  | none :: :: None {{ tex \ottty{\bullet} }} {{ com empty type list }}
  | A :: :: Single
  | A types :: :: Multiple {{ tex [[A]]~~[[types]] }}

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

heap_constructor, C :: 'hcons_' ::= {{ tex \ottcons{[[heap_constructor]]} }}
  | ( 1. ) :: :: V1
  | ( 2. ) :: :: V2
  | ( < , > ) :: :: Pair
  % | ( Nil ) :: :: Nil
  % | ( Cons ) :: :: Cons

judg :: 'judg_' ::=
  | P ; U ; G |- H :: :: TyHeap
  | P ; U ; G |- H | t : A :: :: TyCommand
  | P ; U ; G |- t : A ::  :: TyTerm
  | C : Abar >> A :: :: TyCtor
  | A is B :: :: EqType
  | t is u :: :: EqTerm
  | G is D :: :: EqContext
  | H | t --> H' | t' ::  :: SemMut
  | type_affect in G :: :: CtxIn
  | label_stmt in H :: :: HeapIn
  | names ( G ) /\ names ( D ) = empty :: :: CtxClash

terminals :: 'terminals_' ::=
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | * :: :: deref {{ tex \ottlb{\star} }}
  | ° :: :: valderef {{ tex \ottlb{\ostar} }}
  | + :: :: sum {{ tex \ottty{\oplus} }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: with {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | ; :: :: lseq {{ tex ~;~ }}
  | /\ :: :: intersection {{ tex \cap }}
  | empty :: :: empty {{ tex \emptyset }}
  | --> :: :: reducesto {{ tex \longrightarrow }}
  | '|>' :: :: renamedto {{ tex \,\triangleright\, }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
%   | subto :: :: subto {{ tex \underset{[:=]}{\rightarrow} }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | 1. :: :: v1 {{ tex \ottcons{1.} }}
  | 2. :: :: v2 {{ tex \ottcons{2.} }}
% | Nil :: :: nil {{ tex \ottcons{Nil} }}
% | Cons :: :: cons {{ tex {:}{:} }}
  | Ur :: :: ur {{ tex \ottcons{Ur}\, }}
%  | ++ :: :: concat {{ tex {\small{+}\mspace{-6mu}{+} } }}
%  | <- :: :: affect {{ tex \leftarrow }}
  | .> :: :: pointsto {{ tex \heaparrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | null :: :: null {{ tex \oslash }}
  | >> :: :: consarrow {{ tex \ottty{\consarrow} }}
  | is :: :: is {{ tex = }}
  | !! :: :: downto {{ tex ~~\Downarrow~~ }}
  | __ :: :: heapany {{ tex ... }}
  | =fix :: :: fix {{ tex \overset{\mathsf{fix} }{=} }}

% defns
% JMvar :: '' ::=

% % defn
% % x != y :: :: JMVarNeq :: JMVar_ {{ com $[[x]]$~~and~~$[[y]]$ stands for different variables }} by

% defn
% x notin free ( t ) :: :: JmvarNFree :: JmvarNFree_ {{ com $[[x]]$ is not a free variable in $[[t]]$ }} by

% defn
% x in free ( t ) :: :: JmvarFree :: JmvarFree_ {{ com $[[x]]$ is a free variable used in $[[t]]$ }} by

defns
Ctx :: '' ::=

defn
names ( G ) /\ names ( D ) = empty :: :: CtxClash :: CtxClash_ {{ com $[[G]]$~~and~~$[[D]]$ are disjoint typing contexts with no clashing variable names or labels }} by

defn
type_affect in G :: :: CtxIn :: JcxtIn_ by

defns
Heap :: '' ::=

defn
label_stmt in H :: :: HeapIn :: HeapIn_ by

defns
Eq :: '' ::=

defn
A is B :: :: EqType :: EqType_ by
defn
t is u :: :: EqTerm :: EqTerm_ by
defn
G is D :: :: EqContext :: EqContext_ by

defns
Ty :: '' ::=

defn
R =fix rec_type_def :: :: TyRec :: TyRec_ by

defn
P ; U ; G |- H :: :: TyHeap :: TyHeap_ {{ com $[[H]]$ is a well-typed heap given heap typing context $[[P]]$, unrestricted typing context $[[U]]$ and linear typing context $[[G]]$ }} by

P1 ; U ; G |- H1
P2 ; U ; D |- H2
names(P1) /\ names(P2) = empty
names(G) /\ names(D) = empty
------------------ :: Union
P1 µ P2 ; U ; G µ D |- H1 µ H2

C : Abar >> A
P µ { l bar : A bar } ; U ; G |- H
------------------ :: Ctor
P µ { l bar : A bar, l : A } ; U ; G |- H µ { l .> C lbar }

------------------- :: Null
{ l : A } ; U ; empty |- { l .> null }

P ; U ; G |- v : A
------------------- :: Val
P µ { l : A } ; U ; G |- H µ { l .> v }

defn
P ; U ; G |- H | t : A :: :: TyCommand :: TyCommand_ by

P ; U ; G |- H
P ; U ; D |- t : A
names(G) /\ names(D) = empty
-------------------------------- :: Def
P ; U ; G |- H | t : A

defn
P ; U ; G |- t : A :: :: TyTerm :: TyTerm_ {{ com $[[t]]$ is a well-typed term of type $[[A]]$ given heap typing context $[[P]]$, unrestricted typing context $[[U]]$ and linear typing context $[[G]]$ }} by

--------------- :: Id
P ; U ; { x : A } |- x : A

--------------- :: Id'
P ; U µ { x : A} ; empty |- x : A

---------------- :: Unit
P ; U ; empty |- () : 1

P ; U ; empty |- t : A
----------------------- :: Exp
P ; U ; empty |- Ur t : !A

% TODO: we should have either l : A in P or l not in names(P)
------------------------------------- :: LabelAsDest
P ; U ; empty |- l@|A| : |A|

------------------------------------ :: Deref
P µ { l : A } ; U ; empty |- *l : A

C : Abar >> A
------------------------------------ :: Ctor
P µ { l bar : A bar } ; U ; empty |- C lbar : A

R =fix µ r. W
P ; U ; G |- t : W[r := R]
----------------------------- :: Roll
P ; U ; G |- roll R t : R

P ; U ; G µ { x : A } |- t : B
----------------------- :: Lam
P ; U ; G |- \x:A.t : A --o B

P ; U ; G |- t : A --o B
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
--------------------------------- :: App
P ; U ; G µ D |- t u : B

P ; U ; G |- t : 1
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatU
P ; U ; G µ D |- t ; u : A
%U ; G µ D |- case t of { () -> u } : A

P ; U ; G |- t : A1 * A2
P ; U ; D µ { x1 : A1 , x2 : A2 } |- u : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatP
P ; U ; G µ D |- case t of {<x1, x2> -> u} : B

P ; U ; G |- t : A1 + A2
P ; U ; D µ { x1 : A1 } |- u1 : B
P ; U ; D µ { x2 : A2 } |- u2 : B
names( G ) /\ names( D ) = empty
------------------------------------------------------- :: PatS
P ; U ; G µ D |- case t of { 1. x1 -> u1 , 2. x2 -> u2 } : B

% P ; U ; G |- t : [A]
% P ; U ; D |- u1 : B
% P ; U ; D µ { x1 : A , x2 : [A] } |- u2 : B
% names( G ) /\ names( D ) = empty
% ------------------------------------------------------- :: PatL
% P ; U ; G µ D |- case t of { Nil -> u1 , x1 Cons x2 -> u2 } : B

P ; U ; G |- t : !A
P ; U µ { x : A } ; D |- u: B
names( G ) /\ names( D ) = empty
----------------------------------------- :: PatE
P ; U ; G µ D |- case t of { Ur x -> u } : B

R =fix µ r. W
P ; U ; G |- t : R
P ; U ; D µ { x : W[r := R] } |- u : B
names( G ) /\ names( D ) = empty
----------------------------- :: PatR
P ; U ; G µ D |- case t of { roll R x -> u } : B

P ; U ; G µ { d : |A| } |- t : 1
------------------------------ :: Alloc
P ; U ; G |- alloc d A { t } : A

P ; U ; G |- t : |A|
P ; U ; D |- u : A
names( G ) /\ names( D ) = empty
----------------------------------- :: FillL
P ; U ; G µ D |- fillLeaf t u : 1

P ; U ; G |- t : |A1 + A2|
P ; U ; D µ { d' : |A1| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------- :: FillV1
P ; U ; G µ D |- fillLeft t d' { u } : B

P ; U ; G |- t : |A1 + A2|
P ; U ; D µ { d' : |A2| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------- :: FillV2
P ; U ; G |- fillRight t d' { u } : B

P ; U ; G |- t : |A1 * A2|
P ; U ; D µ { d1 : |A1| , d2 : |A2| } |- u : B
names( G ) /\ names( D ) = empty
----------------------------------------------:: FillP
P ; U ; G µ D |- fillPair t d1 d2 { u } : B

% P ; U ; G |- t : |[A]|
% ----------------------------------- :: FillNil
% P ; U ; G |- fillNil t : 1

% P ; U ; G |- t : |[A]|
% P ; U ; D µ { d1 : |A| , d2 : |[A]| } |- u : B
% names( G ) /\ names( D ) = empty
% ---------------------------------------------------------------- :: FillCons
% P ; U ; G µ D |- fillCons t d1 d2 { u } : B

defn
C : Abar >> A :: :: TyCtor :: TyCtor_ {{ com Heap constructor $[[C]]$ builds a value of type $[[A]]$ given arguments of type $[[Abar]]$ }} by

-------------------  :: V1
(1.) : A >> A + B

----------------------- :: V2
(2.) : B >> A + B

--------------------------- :: Pair
(<,>) : A B >> A * B

% ------------------------ :: Nil
% (Nil) : none >> [A]

% ------------------------- :: Cons
% (Cons) : A [A] >> [A]

defns
Sem :: '' ::=

defn
H | t --> H' | t' :: :: ReduceMut :: SemMut_ {{ com $[[t]]$ reduces to $[[t']]$, with heap changing from $[[H]]$ to $[[H']]$ }} by

H | t --> H' | t'
------------------- :: uApp
H | t u --> H' | t' u

---------------------------- :: App
H | (\x:A.t) u --> H | t[x := u]

H | t --> H' | t'
--------------------------------------------- :: uPatU
H | t ; u --> H' | t' ; u
%case t of {() -> u} --> case t' of {() -> u}

--------------------- :: PatU
H | () ; u --> H | u

---------------------------------- :: DerefVal
H µ { l .> v } | *l --> H µ { l .> v } | v

---------------------------------- :: DerefCtor
H µ { l .> C lbar } | *l --> H µ { l .> C lbar } | C lbar

H | t --> H' | t'
------------------------------------------------------------------------------- :: uPatS
H | case t of {1. x1 -> u1, 2. x2 -> u2} --> H' | case t' of {1. x1 -> u1, 2. x2 -> u2}

----------------------------------------- :: PatSV1
H | case 1. l of {1. x1 -> u1, 2. x2 -> u2} --> H | u1[x1 := *l]

----------------------------------------- :: PatSV2
H | case 2. l of {1. x1 -> u1, 2. x2 -> u2} --> H | u2[x2 := *l]

H | t --> H' | t'
----------------------------------------------------------------------------- :: uPatP
H | case t of {<x1,x2> -> u} --> H' | case t' of {<x1,x2> -> u}

-------------------------------------------------------------------------------- :: PatP
H | case <l1, l2> of {<x1,x2> -> u} --> H | u[x1 := *l1, x2 := *l2]

% H | t --> H' | t'
% ------------------------------------------------------------------------------------- :: uPatL
% H | case t of {Nil -> u1, x1 Cons x2 -> u2} --> H' | case t' of {Nil -> u1, x1 Cons x2 -> u2}

% ----------------------------------------------------------------------- :: PatLNil
% H µ { l .> Nil } | case °l of {Nil -> u1, x1 Cons x2 -> u2} --> H µ { l .> Nil } | u1

% ----------------------------------------------------------------------- :: PatLCons
% H µ { l .> l1 Cons l2 } | case °l of {Nil -> u1, x1 Cons x2 -> u2} --> H µ { l .> l1 Cons l2 } | u2[x1 := *l1, x2 := *l2]

H | t --> H' | t'
------------------------------------------------------------------------------------- :: uPatE
H | case t of {Ur x -> u} --> H' | case t' of {Ur x -> u}

----------------------------------------------------- :: PatE
H | case Ur t of { Ur x -> u } --> H | u[x := t]

H | t --> H' | t'
------------------------------------------------------ :: uPatR
H | case t of { roll R x -> u} --> H' | case t' of { roll R x -> u}

------------------------------------------------------ :: PatR
H | case roll R t of { roll R x -> u } --> H | u[x := t]

H | t --> H' | t'
------------------------------------- :: uFillL
H | fillLeaf t u --> H' | fillLeaf t' u

H | t --> H' | t'
------------------------------------- :: uFillL'
H | fillLeaf l@|A| t --> H' | fillLeaf l@|A| t'

H | t --> H' | t'
------------------------------------- :: uFillV1
H | fillLeft t d' {u} --> H' | fillLeft t' d' {u}

H | t --> H' | t'
------------------------------------- :: uFillV2
H | fillRight t d' {u} --> H' | fillRight t' d' {u}

H | t --> H' | t'
------------------------------------- :: uFillP
H | fillPair t d1 d2 {u} --> H' | fillPair t' d1 d2 {u}

% H | t --> H' | t'
% ------------------------------------- :: uFillNil
% H | fillNil t --> H' | fillNil t'

% H | t --> H' | t'
% ------------------------------------- :: uFillCons
% H | fillCons t d1 d2 {u} --> H' | fillCons t' d1 d2 {u}

--------------------------------------------------- :: Alloc
H | alloc d A { t } --> H µ { l .> null } | t[d := l@|A|] ; *l

------------------------------------------------------------ :: FillLV
H µ { l .> null } | fillLeaf l@|A| v --> H µ { l .> v } | ()

------------------------------------------------------------ :: FillLCtor
H µ { l .> null } | fillLeaf l@|A| C lbar --> H µ { l .> C lbar } | ()

------------------------------------------------------------ :: FillV1
H µ { l .> null } | fillLeft l@|A1+A2| d' { t } --> H µ { l .> 1. l', l' .> null } | t[d' := l'@|A1|]

------------------------------------------------------------ :: FillV2
H µ { l .> null } | fillRight l@|A1+A2| d' { t } --> H µ { l .> 2. l', l' .> null } | t[d' := l'@|A2|]

----------------------------------------------- :: FillP
H µ { l .> null } | fillPair l@|A1*A2| d1 d2 { t } --> H µ { l .> <l1, l2> , l1 .> null, l2 .> null } | t[d1 := l1@|A1|, d2 := l2@|A2|]

% ----------------------------------------------- :: FillNil
% H µ { l .> null } | fillNil l --> H µ { l .> Nil } | ()

% ----------------------------------------------------- :: FillCons
% H µ { l .> null } | fillCons l d1 d2 { t } --> H µ { l .> l1 Cons l2 , l1 .> null, l2 .> null } | t[d1 := l1, d2 := l2]

defn
H | t !! H' | t' :: :: ReduceImm :: SemImm_ {{ com $[[t]]$ reduces to $[[t']]$, with heap growing from $[[H]]$ to $[[H']]$ }} by

--------------------------- :: Roll
H | roll R t !! H | t

H | t !! H' | t'
------------------- :: uApp
H | t u !! H' | t' u

---------------------------- :: App
H | (\x:A.t) u !! H | t[x := u]

H | t !! H' | t'
--------------------------------------------- :: uPatU
H | t ; u !! H' | t' ; u
%case t of {() -> u} --> case t' of {() -> u}

--------------------- :: PatU
H | () ; u !! H | u

---------------------------------- :: DerefVal
H µ { l .> v } | *l !! H µ { l .> v } | v

---------------------------------- :: DerefCtor
H µ { l .> C lbar } | *l !! H µ { l .> C lbar } | C lbar

H | t !! H' | t'
------------------------------------------------------------------------------- :: uPatS
H | case t of {1. x1 -> u1, 2. x2 -> u2} !! H' | case t' of {1. x1 -> u1, 2. x2 -> u2}

----------------------------------------- :: PatSV1
H | case 1. l of {1. x1 -> u1, 2. x2 -> u2} !! H | u1[x1 := *l]

----------------------------------------- :: PatSV2
H | case 2. l of {1. x1 -> u1, 2. x2 -> u2} !! H | u2[x2 := *l]

H | t !! H' | t'
----------------------------------------------------------------------------- :: uPatP
H | case t of {<x1,x2> -> u} !! H' | case t' of {<x1,x2> -> u}

-------------------------------------------------------------------------------- :: PatP
H | case <l1, l2> of {<x1,x2> -> u} !! H | u[x1 := *l1, x2 := *l2]

% H | t --> H' | t'
% ------------------------------------------------------------------------------------- :: uPatL
% H | case t of {Nil -> u1, x1 Cons x2 -> u2} --> H' | case t' of {Nil -> u1, x1 Cons x2 -> u2}

% ----------------------------------------------------------------------- :: PatLNil
% H µ { l .> Nil } | case °l of {Nil -> u1, x1 Cons x2 -> u2} --> H µ { l .> Nil } | u1

% ----------------------------------------------------------------------- :: PatLCons
% H µ { l .> l1 Cons l2 } | case °l of {Nil -> u1, x1 Cons x2 -> u2} --> H µ { l .> l1 Cons l2 } | u2[x1 := *l1, x2 := *l2]

H | t !! H' | t'
------------------------------------------------------------------------------------- :: uPatE
H | case t of {Ur x -> u} !! H' | case t' of {Ur x -> u}

----------------------------------------------------- :: PatE
H | case Ur t of { Ur x -> u } !! H | u[x := t]

H | t !! H' | t'
------------------------------------------------------ :: uPatR
H | case t of { roll R x -> u} !! H' | case t' of { roll R x -> u}

------------------------------------------------------ :: PatR
H | case roll R t of { roll R x -> u } !! H | u[x := t]

H | t !! H' | t'
------------------------------------- :: uFillL
H | fillLeaf t u !! H' | fillLeaf t' u

H | t !! H' | t'
------------------------------------- :: uFillL'
H | fillLeaf l@|A| t !! H' | fillLeaf l@|A| t'

H | t !! H' | t'
------------------------------------- :: uFillV1
H | fillLeft t d' {u} !! H' | fillLeft t' d' {u}

H | t !! H' | t'
------------------------------------- :: uFillV2
H | fillRight t d' {u} !! H' | fillRight t' d' {u}

H | t !! H' | t'
------------------------------------- :: uFillP
H | fillPair t d1 d2 {u} !! H' | fillPair t' d1 d2 {u}

% H | t --> H' | t'
% ------------------------------------- :: uFillNil
% H | fillNil t --> H' | fillNil t'

% H | t --> H' | t'
% ------------------------------------- :: uFillCons
% H | fillCons t d1 d2 {u} --> H' | fillCons t' d1 d2 {u}

%---------------------------------------------------------------------------
% TODO: changes under this line
%---------------------------------------------------------------------------

H | t[d := l@|A|] !! H' µ { l .> __ } | ()
--------------------------------------------------- :: Alloc  {{ com ~~\textnormal{\itshape --- Changes start from there ---} }}
H | alloc d A { t } !! H' µ { l .> __ } | *l

------------------------------------------------------------ :: FillLV
H | fillLeaf l@|A| v !! H µ { l .> v } | ()

------------------------------------------------------------ :: FillLCtor
H | fillLeaf l@|A| C lbar !! H µ { l .> C lbar } | ()

H | t[d' := l'@|A1|] !! H' µ { l' .> __ } | ()
------------------------------------------------------------ :: FillV1
H | fillLeft l@|A1+A2| d' { t } !! H' µ { l' .> __ , l .> 1. l' } | ()

H | t[d' := l'@|A2|] !! H' µ { l' .> __ } | ()
------------------------------------------------------------ :: FillV2
H | fillRight l@|A1+A2| d' { t } !! H' µ { l' .> __ , l .> 2. l' } | ()

H | t[d1 := l1@|A1|, d2 := l2@|A2|] !! H' µ { l1 .> __, l2 .> __ } | ()
----------------------------------------------- :: FillP
H | fillPair l@|A1*A2| d1 d2 { t } !! H' µ { l1 .> __, l2 .> __ , l .> <l1, l2> } | ()

% ----------------------------------------------- :: FillNil
% H µ { l .> null } | fillNil l --> H µ { l .> Nil } | ()

% ----------------------------------------------------- :: FillCons
% H µ { l .> null } | fillCons l d1 d2 { t } --> H µ { l .> l1 Cons l2 , l1 .> null, l2 .> null } | t[d1 := l1, d2 := l2]

% embed
% {{ tex

% \begin{defi}[Pointer-less term]
% A term $[[t]]$ is said "pointer-less" if neither itself nor one of its subterms are one of $[[l]]$, $[[*l]]$ or $[[°l]]$.
% \end{defi}

% \begin{lem}[Canonical forms]

% Let $[[v]]$ be a value such that $[[H0]] | [[t0]] \overset{n}{\longrightarrow} [[H]] | [[v]]$ and $[[P ; U ; G |- H | v : A]]$ for some \emph{pointer-less} term $[[t0]]$.

% \begin{tabular}{ll}
% Ty & Value \\
% $[[A is 1]]$ & $[[v is ()]]$ \\
% $[[A is B1 * B2]]$ & $[[v is °l]] ~~\land~~ [[l .> <l1, l2> in H]]$ \\
% $[[A is B1 + B2]]$ & $[[v is °l]] ~~\land~~ \left([[l .> 1. l' in H]]~~\lor~~[[l .> 2. l' in H]]\right)$ \\
% $[[A is B1 --o B2]]$ & $[[v is \x:B1.t]]$ \\
% $[[A is |B|]]$ & $[[v is l]]$ \\
% $[[A is [B] ]]$ & $[[v is °l]] ~~\land~~ \left([[l .> Nil in H]] ~~\lor~~[[l .> l1 Cons l2 in H]]\right)$ \\
% $[[A is !B ]]$ & $[[v is Ur t]]$\\
% \end{tabular}

% \bigskip

% \noindent\textit{Proof:}

% \begin{itemize}
% \item If $[[A is 1]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[\x:A'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
% \item $[[v]]$ can be $[[()]]$ (\TyTerm{Unit})
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : 1 in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> 1]]$ (by application of \TyHeap{Ctor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
% \end{itemize}
% So $[[P ; U ; G |- H | v : 1]] \implies [[v is ()]]$

% \item If $[[A is B1 * B2]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[\x:A'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : B1 * B2 in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> B1 * B2]]$ (by application of \TyHeap{Ctor}). There is only one such $[[C]]$: $[[(<,>)]]$. In addition, we should have $[[l .> <l1, l2> in H]]$ (still from \TyHeap{Ctor}).
% \end{itemize}
% So $[[P ; U ; G |- H | v : B1 * B2]] \implies [[v is °l]] ~~\land~~ [[l .> <l1, l2> in H]]$

% \item If $[[A is B1 + B2]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[\x:A'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : B1 + B2 in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> B1 + B2]]$ (by application of \TyHeap{Ctor}). There are two constructors matching this criterion: $[[(1.)]]$~~and~~$[[(2.)]]$. With the former, we should have $[[l .> 1. l' in H]]$, and with the latter, we should have $[[l .> 2. l' in H]]$ (still from \TyHeap{Ctor}).
% \end{itemize}
% So $[[P ; U ; G |- H | v : B1 + B2]] \implies [[v is °l]] ~~\land~~ \left([[l .> 1. l' in H]]~~\lor~~[[l .> 2. l' in H]]\right)$

% \item If $[[A is B1 --o B2]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
% \item $[[v]]$ can be $[[\x:B1.t]]$ (\TyTerm{Lam})
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : B1 --o B2 in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> B1 --o B2]]$ (by application of \TyHeap{Ctor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
% \end{itemize}
% So $[[P ; U ; G |- H | v : B1 --o B2]] \implies [[v is \x:B1.t]]$

% \item If $[[A is |B|]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[\x:B'.t]]$ or $[[Ur t]]$ (Inversion lemma).
% \item $[[v]]$ can be $[[l]]$ (\TyTerm{LabelAsDest}), in which case $[[l : A in P]]$.
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : |B| in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> |B|]]$ (by application of \TyHeap{Ctor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
% \end{itemize}
% So $[[P ; U ; G |- H | v : |B|]] \implies [[v is l]]$

% \item If $[[A is [B] ]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[\x:B'.t]]$, $[[Ur t]]$ or $[[l]]$ (Inversion lemma).
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : [B] in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> [B] ]]$ (by application of \TyHeap{Ctor}). There are two constructors matching this criterion: $[[(Nil)]]$~~and~~$[[(Cons)]]$. With the former, we should have $[[l .> Nil in H]]$, and with the latter, we should have $[[l .> l1 Cons l2 in H]]$ (still from \TyHeap{Ctor}).
% \end{itemize}
% So $[[P ; U ; G |- H | v : [B] ]] \implies [[v is °l]] ~~\land~~ \left([[l .> Nil in H]] ~~\lor~~[[l .> l1 Cons l2 in H]]\right)$

% \item If $[[A is !B ]]$:
% \begin{itemize}
% \item $[[v]]$ cannot be one of $[[()]]$, $[[\x:B'.t]]$ or $[[l]]$ (Inversion lemma).
% \item $[[v]]$ can be $[[Ur t]]$ (\TyTerm{Exp}).
% \item Let $[[v is °l]]$. Because $[[°l]]$ is not present in $[[t0]]$, it must have been produced by a reduction rule, that is to say either \SemMut{DerefVal} or \SemMut{DerefCtor}. In the former case, it means that $[[l' .> °l in H]]$, which can only be added to the heap $[[H]]$ via \SemMut{FillL}, so $[[°l]]$ would have been preexistant (produced by another mean). In the latter case, $[[l .> C lbar in H]]$ which means that the rule \TyHeap{Ctor} has been used at least once in the typing derivation of $[[H]]$. We need $[[l : [B] in P]]$ from \TyTerm{DerefVal}, so we need a heap constructor $[[C : Abar >> !B]]$ (by application of \TyHeap{Ctor}), but there is no such $[[C]]$. As a result, $[[v]]$ cannot be $[[°l]]$.
% \end{itemize}
% So $[[P ; U ; G |- H | v : !B ]] \implies [[v is Ur t]]$

% \end{itemize}
% \end{lem}

% \begin{lem}[Inversion of the typing relation]\phantom{nl}

% \begin{itemize}
% \item If $[[P ; U ; G |- x : A]]$, then either $[[G is {x : A}]]$ or $[[x : A in U]]~\land~[[G is empty]]$ (\TyTerm{Id} and \TyTerm{Id'})
% \item If $[[P ; U ; G |- () : A]]$, then $[[G is empty]]$~~and~~$[[A is 1]]$ (\TyTerm{Unit})
% \item If $[[P ; U ; G |- Ur t : A]]$ then $[[G is empty]]$ and there is some type $[[B]]$ such that $[[A is !B]]$~~and~~$[[P ; U ; empty |- t : B]]$ (\TyTerm{Exp})
% \item If $[[P ; U ; G |- l : A]]$ then $[[G is empty]]$ and there is some type $[[B]]$ such that $[[A is |B|]]$~~and~~$[[l : B in P]]$ (\TyTerm{LabelAsDest})
% \item If $[[P ; U ; G |- °l : A]]$ then $[[G is empty]]$~~and~~$[[l : A in P]]$ (\TyTerm{DerefVal})
% \item If $[[P ; U ; G |- *l : A]]$ then $[[G is empty]]$~~and~~$[[l : A in P]]$ (\TyTerm{Deref})
% \item If $[[P ; U ; G |- \x:B1.t:A]]$, then there is some type $[[B2]]$ such that $[[A is B1 --o B2]]$~~and~~$[[P ; U ; G µ {x:B1} |- t : B2]]$ (\TyTerm{Lam})
% \item If $[[P ; U ; G |- t u : A]]$, then there are some type $[[B]]$ and contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : B --o A]]$,~~~$[[P ; U ; D2 |- u : B]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{App})
% \item If $[[P ; U ; G |- t ; u : A]]$ then there are some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : 1]]$,~~~$[[P ; U ; D2 |- u : A]]$, and $[[G is D1 µ D2]]$ (\TyTerm{PatU})
% \item If $[[P ; U ; G |- case t of { <x1, x2> -> u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : B1 * B2]]$,~~~$[[P ; U ; D2 µ { x1 : B1, x2 : B2 } |- u : A]]$ and , and $[[G is D1 µ D2]]$ (\TyTerm{PatP})
% \item If $[[P ; U ; G |- case t of { 1.x1 -> u1, 2.x2 -> u2 } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : B1 + B2]]$,~~~$[[P ; U ; D2 µ { x1 : B1 } |- u1 : A]]$,~~~$[[P ; U ; D2 µ { x2 : B2 } |- u2 : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{PatS})
% \item If $[[P ; U ; G |- case t of { Nil -> u1, x1 Cons x2 -> u2 } : A]]$ then there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : [B] ]]$,~~~$[[P ; U ; D2 |- u1 : A]]$,~~~$[[P ; U ; D2 µ { x1 : B, x2 : [B] } |- u2 : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{PatL})
% \item If $[[P ; U ; G |- case t of { Ur x -> u } : A]]$ then there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : !B]]$,~~~$[[P ; U µ {x : B} ; D2 |- u : A]]$ and and $[[G is D1 µ D2]]$ (\TyTerm{PatE})
% \item If $[[P ; U ; G |- fillLeaf t u : A]]$ then $[[A is 1]]$ and there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B|]]$,~~~$[[P ; U ; D2 |- u : B]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{FillL})
% \item If $[[P ; U ; G |- fillLeft t d' { u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B1 + B2|]]$,~~~$[[P ; U ; D2 µ { d' : |B1| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{FillV1})
% \item If $[[P ; U ; G |- fillRight t d' { u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B1 + B2|]]$,~~~$[[P ; U ; D2 µ { d' : |B2| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{FillV2})
% \item If $[[P ; U ; G |- fillPair t d1 d2 { u } : A]]$ then there are some types $[[B1]]$, $[[B2]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |B1 * B2|]]$,~~~$[[P ; U ; D2 µ { d1 : |B1|, d2 : |B2| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{FillP})
% \item If $[[P ; U ; G |- fillNil t : A]]$ then $[[A is 1]]$ and there is some type $[[B]]$ such that $[[P ; U ; G |- t : |[B]| ]]$ (\TyTerm{FillNil})
% \item If $[[P ; U ; G |- fillCons t d1 d2 { u } : A]]$ then there are some type $[[B]]$ and some contexts $[[D1]]$, $[[D2]]$ such that $[[P ; U ; D1 |- t : |[B]|]]$,~~~$[[P ; U ; D2 µ { d1 : |B|, d2 : |[B]| } |- u : A]]$~~and~~$[[G is D1 µ D2]]$ (\TyTerm{FillP})

% \end{itemize}

% \bigskip

% \noindent\textit{Proof:}

% \smallskip

% Immediate from the definition of the typing relation.

% \end{lem}

% \bigskip
% \togglespaces

% \noindent\textbf{Example 1 :} implementation of $\ottkw{map}$ with $\ottkw{rolll}$

% \[\begin{array}{l}
% \ottkw{map} \defeq [[
% \uf: !(A --o B). \xs: [A]. \d0: |[B]|. (
% b s (rolll
% b ss case uf of { Ur f -> Ur (
% b sss \d: |[B]|. \x: A. (fillCons d d1 d2 { fillLeaf d1 (f x) ; d2 })
% b sse )}
% b ss d0
% b ss xs
% ) b fillNil se)
% ]]
% \end{array}\]
% }}


parsing
v_Lam <= t_Sub
t_PatU <= t_App
t_PatU <= t_FillL
judg_HeapIn <= s_V1
hcons_V1 <= terminals_v1
