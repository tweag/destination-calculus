% minimal + latex + comments

embed
{{ tex-preamble
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{lbcolor}{RGB}{186, 58, 7}
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathrm{\mathit{#1} } } }
\renewcommand{\ottkw}[1]{\mathsf{#1} }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\ottlb}[1]{\textcolor{lbcolor}{\mathit{\replacelell{#1} } } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle indent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\heaparrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyHeap}[1]{\textsc{TyHeap\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\itshape #1} }
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar metavariable, x, xs, y, uf, f, d ::=
  {{ tex \ottmv{[[metavariable]]} }}

grammar
term, t, u :: 't_' ::=                                               {{ com term }}
  | x                                       ::   :: Var      {{ com variable }}
  | v :: :: Val {{ com value }}
  | t u                                    ::   :: App      {{ com application }}
  | t ; u :: :: EffThen {{ com effect execution }}
  | case t of { () -> u }                   ::   :: PatU     {{ com pattern-matching on unit }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on exponentiated value }}
  | case t of { inl x1 -> u1 , inr x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
  | case t of { roll R x -> u } :: :: PatR {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{ \underset{[[R]] }{\ottkw{roll} }~[[x]] \mapsto [[u]] \} }} {{ com unroll for recursive types }}
  | alloc d A { t }                                   ::   :: Alloc    {{ com allocate data }} {{ tex \underset{\ottty{[[A]]} }{\ottkw{alloc}~[[d]]}\,\textbf{.}\,[[t]] }}
  | fillUnit t :: :: FillU {{ com fill destination with unit }} {{ tex [[t]]\,\triangleleft\,\ottcons{()} }}
  | fillLin t u                            ::   :: FillL    {{ com fill terminal-type destination }} {{ tex [[t]]\,\triangleleft\,[[u]] }}
  | fillUr t u :: :: FillE {{ com fill destination with exponential }} {{ tex [[t]]\,\triangleleft\,\ottcons{Ur}~[[u]] }}
  | fillLeft t d { u }                          ::   :: FillInl   {{ com fill sum-type destination with variant 1 }} {{ tex [[t]]\,\triangleleft\,\ottcons{inl} [[d]]\,\textbf{.}\,[[u]] }}
  | fillRight t d { u }                          ::   :: FillInr   {{ com fill sum-type destination with variant 2 }} {{ tex [[t]]\,\triangleleft\,\ottcons{inr} [[d]]\,\textbf{.}\,[[u]] }}
  | fillPair t d1 d2 { u }                              ::   :: FillP    {{ com fill product-type destination }} {{ tex [[t]]\,\triangleleft\,\langle [[d1]] , [[d2]] \rangle\,\textbf{.}\,[[u]] }}
  | fillRoll R t d { u } :: :: FillR {{ com fill destination with recursive type }} {{ tex [[t]]\,\triangleleft\,\underset{[[R]]}{\ottcons{roll} }~[[d]]\,\textbf{.}\,[[u]] }}
  | ( t )                                   :: S :: Paren
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ var_subs ]                             :: M :: Sub {{ tex [[t]]\left[ [[var_subs]]\right] }}

var_sub, vs :: 'vs_' ::= {{ com variable substitution }}
  | x := t :: :: VarSub {{ tex \nicefrac{[[t]]}{[[x]]} }}

var_subs :: 'vss_' ::= {{ com variable substitutions }}
  | vs :: :: Single
  | vs , var_subs :: :: Multiple

heap_val, h :: 'hv_' ::=
  | ()                                      ::   :: U
  | Ur l :: :: E
  | inl l :: :: Inl
  | inr l :: :: Inr
  | < l1 , l2 > :: :: P
  | roll R l :: :: R {{ tex \underset{[[R]] }{\ottkw{roll} }~[[l]] }}
  | C lbar :: M :: Generic {{ com generic for all the cases above }}

val, v :: 'v_' ::= {{ com unreducible value }}
  | o :: :: NoEff {{ com no-effect effect }}
  | | l |                                       :: :: LDest {{ com address of an allocated memory area }} {{ tex \ottlb{\lfloor[[l]]\rfloor} }}
  | \ x : A . t                                ::   :: Lam      {{ com lambda abstraction }} {{ tex \lambda\aunderbrace[l1r]{\,[[x]]{:}[[A]]\,}\textbf{.}\,[[t]] }}
  | h :: :: HeapVal {{ com heap value }}

label, l :: 'l_' ::= {{ com memory address }} {{ tex \ottlb{[[label]]} }}

labels :: 'll_' ::=
  | l :: :: Single
  | l , labels :: :: Multiple
  | l bar :: M :: SingleBar {{ tex \ottlb{\bar{[[l]]} } }}
  | l bar, labels :: M :: MultipleBar {{ tex \ottlb{\bar{[[l]]} }, [[labels]] }}

label_set, L :: 'ls_' ::= {{ com set of used labels }} {{ tex \ottlb{[[label_set]]} }}
  | empty :: :: Empty
  | { labels } :: :: Labels
  | L1 µ L2 :: :: Union
%  | ( L ) :: S :: Paren

heap_affect, ha :: 'ha_' ::= {{ com heap cell }}
  | l <| v :: :: Val
  | l bar <| vbar :: M :: Generic {{ tex \ottlb{\bar{[[l]]} } \heaparrow [[vbar]] }} {{ com generic for multiple occurences }}

heap_affects :: 'has_' ::= {{ com heap cells }}
  | ha :: :: Single
  | ha , heap_affects :: :: Multiple

heap_context, H {{ tex \mathbb{H} }} :: 'hc_' ::= {{ com heap contents }}
  | empty :: :: Empty
  | { heap_affects } :: :: Stmts
  | H1 µ H2 :: :: Union

type, A, B :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
  | _!_ :: :: Bottom {{ com bottom type }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
  | A * B :: :: Prod {{ com product type }} {{ tex \ottty{[[A]] \otimes [[B]]} }}
  | A + B :: :: Sum {{ com sum type }}
  | A --o B :: :: LinArr {{ com linear function type }}
  | | A | :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[A]] \rfloor} }}
  | ! A :: :: Exp {{ com exponential }} {{ tex \ottty{![[A]]} }}
  | ( A )  :: S :: Paren {{ tex \ottty{([[A]])} }}
  | W [ r := A ] :: M :: Sub {{ tex [[W]]\left[ \nicefrac{[[A]]}{\ottmv{r} } \right] }}

type_with_hole, W :: 'twh_' ::= {{ tex \ottty{[[type_with_hole]]} }}
  | r :: :: Hole {{ com type hole in recursive definition }} {{ tex \ottmv{r} }}
  | _!_ :: :: Bottom {{ com bottom type }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | R :: :: Rec {{ com recursive type bound to a name }}
  | W1 * W2 :: :: Prod {{ com product type }} {{ tex \ottty{[[W1]] \otimes [[W2]]} }}
  | W1 + W2 :: :: Sum {{ com sum type }}
  | W1 --o W2 :: :: LinArr {{ com linear function type }}
  | | W | :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[W]] \rfloor} }}
  | ! W :: :: Exp {{ com exponential }} {{ tex \ottty{![[W]]} }}
  | ( W )  :: S :: Paren {{ tex \ottty{([[W]])} }}

rec_type_bound, R :: 'rtb_' ::= {{ com recursive type bound to a name }} {{ tex \ottty{[[rec_type_bound]]} }}

rec_type_def :: 'rtd_' ::=
  | µ r . W :: :: Abs {{ tex \mu\,\ottmv{r}\,\textbf{.}\,[[W]] }}

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : A ::  :: Var {{ com var }}
  | l : A :: :: Label {{ com label }}
  | l bar : A bar :: :: GenericLabel {{ tex \ottlb{\bar{[[l]]} } : \ottty{\bar{[[A]]} } }} {{ com generic for multiple occurences }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, G {{ tex \Gamma }}, U {{ tex \mho }}, P {{ tex \Phi }}, Y {{ tex \Psi }}, Yh {{ tex \Psi^{\scriptscriptstyle \mathbb{H} } }}, Yt {{ tex \Psi^{\ottnt{t} } }} :: 'tc_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var
  | G1 µ G2    ::    :: Union

types, Abar {{ tex \ottty{\bar{A} } }} :: 'tys_' ::= {{ tex \ottty{[[types]]} }}
  | none :: :: None {{ tex \ottty{\cdot} }} {{ com empty type list }}
  | A :: :: Single
  | A types :: :: Multiple {{ tex [[A]]~~[[types]] }}

command :: 'com_' ::=
  | L | H | t :: :: Command {{ tex [[L]]\,|\,[[H]]\,|\,[[t]] }}

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

heap_constructor, C :: 'hcons_' ::= {{ tex \ottcons{[[heap_constructor]]} }}
  | { () } :: :: U {{ tex [[()]] }}
  | { Ur } :: :: E {{ tex [[Ur]] }}
  | { inl } :: :: Inl {{ tex [[inl]] }}
  | { inr } :: :: Inr {{ tex [[inr]] }}
  | { < , > } :: :: P {{ tex \langle{,}\rangle }}
  | { roll R } :: :: R {{ tex \ottcons{roll}~[[R]] }}

judg :: 'judg_' ::=
  | l in names ( P ) :: :: CtxLabelIn
  | l notin names ( P ) :: :: CtxLabelNotIn
  | type_affect in G :: :: CtxTypeAffIn
  | ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }}
  | ctxdisjoint3 G1 G2 G3 :: :: CtxDisjoint3 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G1]]) \cap [[names]]([[G3]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G2]]) \cap [[names]]([[G3]]) = \emptyset }}
  | names ( P ) µ names ( Y ) includedin L :: :: LabelSetDef2
  | names ( P ) µ names ( Yh ) µ names ( Yt ) includedin L :: :: LabelSetDef3
  | l in L :: :: LabelSetIn
  | l notin L :: :: LabelSetNotIn
  | heap_affect in H :: :: HeapAffIn
  | A is B :: :: EqType
  | t is u :: :: EqTerm
  | G is D :: :: EqContext
  | { l <| v' , lbar <| vbar } = deepCopy ( L , v ) :: :: DeepCopyTree {{ tex \{ [[l]] [[<|]] [[v']], [[lbar]] [[<|]] [[vbar]] \} = \mathsf{deepCopy}([[L]], \ottlb{\lfloor[[l]]\rfloor}, [[v]]) }}
  | R =fix rec_type_def :: :: TyRec
  | A is destFree :: :: TyDestFree {{ tex \text{$[[A]]$ is destination-free} }}
  | C : Abar >> A :: :: TyCtor
  | P ; Yh u Yt ; U ; G |- command : A :: :: TyCommand
  | P ; Y |- H :: :: TyHeap
  | P ; Y ; U ; G |- t : A ::  :: TyTerm
  | command !! command' :: :: SemOp

terminals :: 'terminals_' ::=
  | () :: :: unit {{ tex \ottcons{()} }}
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | + :: :: sum {{ tex \ottty{\oplus} }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | |- :: :: turnstile {{ tex \vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | empty :: :: empty {{ tex \emptyset }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | inl :: :: v1 {{ tex \ottcons{inl} }}
  | inr :: :: v2 {{ tex \ottcons{inr} }}
  | Ur :: :: ur {{ tex \ottcons{Ur}\, }}
  | <| :: :: pointsto {{ tex \heaparrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | >> :: :: consarrow {{ tex ~\ottty{\consarrow}~ }}
  | is :: :: is {{ tex = }}
  | !! :: :: downto {{ tex ~~\Downarrow~~ }}
  | =fix :: :: fix {{ tex \overset{\mathsf{fix} }{=} }}
  | _!_ :: :: bottom {{ tex \ottty{\bot} }}
  | o :: :: bullet {{ tex \bullet }}
  | includedin :: :: includedin {{ tex \subset }}
  | ';' :: :: sep {{ tex ~;\, }}
  | names :: :: names {{ tex \mathcal{N} }}
  | lbar :: :: lbar {{ tex \ottlb{\bar{l} } }}
  | vbar :: :: vbar {{ tex \ottnt{\bar{v} } }}

defns
Ctx :: '' ::=

defn
l in names ( P ) :: :: CtxLabelIn :: CtxLabelIn_ by

defn
l notin names ( P ) :: :: CtxLabelNotIn :: CtxLabelNotIn_ by

defn
type_affect in G :: :: CtxTypeAffIn :: CtxTypeAffIn_ by

defn
ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 :: CtxDisjoint2_ {{ com $[[G1]]$~~and~~$[[G2]]$ are disjoint typing contexts with no clashing variable names or labels }} {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }} by

defn
ctxdisjoint3 G1 G2 G3 :: :: CtxDisjoint3 :: CtxDisjoint3_ {{ com $[[G1]]$, $[[G2]]$ and $[[G3]]$ are fully disjoint typing contexts with no clashing variable names or labels }} {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G1]]) \cap [[names]]([[G3]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G2]]) \cap [[names]]([[G3]]) = \emptyset }} by

defns
LabelSet :: '' ::=

defn
names ( P ) µ names ( Y ) includedin L :: :: LabelSetDef2 :: LabelSetDef2_ by

defn
names ( P ) µ names ( Yh ) µ names ( Yt ) includedin L :: :: LabelSetDef3 :: LabelSetDef3_ by

defn
l in L :: :: LabelSetIn :: LabelSetIn_ by

defn
l notin L :: :: LabelSetNotIn :: LabelSetNotIn_ {{ tex [[l]] = \ottkw{fresh}([[L]]) }} by

defns
Heap :: '' ::=

defn
heap_affect in H :: :: HeapAffIn :: HeapAffIn_ by

defns
Eq :: '' ::=

defn
A is B :: :: EqType :: EqType_ by
defn
t is u :: :: EqTerm :: EqTerm_ by
defn
G is D :: :: EqContext :: EqContext_ by

defns
Copy :: '' ::=
defn
{ l <| v' , lbar <| vbar } = deepCopy ( L , v ) :: :: DeepCopyTree :: DeepCopyTree_ {{ com Deep-copy $[[v]]$ into the memory tree with root $[[l]]$ and fresh labels $[[lbar]]$ }} {{ tex \{ [[l]] [[<|]] [[v']], [[lbar]] [[<|]] [[vbar]] \} = \mathsf{deepCopy}([[L]], \ottlb{\lfloor[[l]]\rfloor}, [[v]]) }} by

defns
Ty :: '' ::=

defn
R =fix rec_type_def :: :: TyRec :: TyRec_ by

defn
A is destFree :: :: TyDestFree :: TyDestFree_ {{ tex \text{$[[A]]$ is destination-free} }} {{ com $[[A]]$ is destination-free}} by

defn
C : Abar >> A :: :: TyCtor :: TyCtor_ {{ com Heap constructor $[[C]]$ builds a value of type $[[A]]$ given arguments of type $[[Abar]]$ }} by

---------------- :: U
{ () } : none >> 1

-------------------  :: Inl
{ inl } : A >> A + B

----------------------- :: Inr
{ inr } : B >> A + B

--------------------------- :: P
{ <,> } : A B >> A * B

--------------- :: E
{ Ur } : A >> !A

R =fix µ r. W
---------------------- :: R
{ roll R } : W[r := R] >> R

%TODO: Structures de données qui contiennent un dest dest mais pas à la racine, peut on les mettre dans ur?

defn
P ; Yh u Yt ; U ; G |- command : A :: :: TyCommand :: TyCommand_ {{ tex [[P]]~;\,[[Yh]]\!\mathrel{\raisebox{1pt}{$\scriptscriptstyle\sqcup$} }\![[Yt]]~;\,[[U]]~;\,[[G]] [[|-]] [[command]] : [[A]] }} by

ctxdisjoint3 P Yh Yt
names(P) µ  names(Yh) µ names(Yt) includedin L
P ; Yh |- H
P ; Yt ; U ; G |- t : A
-------------------------------- :: Def
P ; Yh u Yt ; U ; G |- L | H | t : A

defn
P ; Y |- H :: :: TyHeap :: TyHeap_ by

------------------- :: Empty
empty ; empty |- empty

ctxdisjoint2 Y1 Y2
P ; Y1 |- H
P ; Y2 ; empty ; empty |- v : A
------------------- :: Val
P µ { l : A } ; Y1 µ Y2 |- H µ { l <| v }

defn
P ; Y ; U ; G |- t : A :: :: TyTerm :: TyTerm_ by

------------------------ :: NoEff
P ; empty ; U ; empty |- o : _!_

l notin names(P)
------------------------------------- :: LDest
P ; { l : A } ; U ; empty |- |l| : |A|

P ; Y ; U ; G µ { x : A } |- t : B
----------------------- :: Lam
P ; Y ; U ; G |- \x:A.t : A --o B

C : Abar >> A
------------------------------------ :: HeapVal
P µ { l bar : A bar } ; empty ; U ; empty |- C lbar : A

--------------- :: Id
P ; empty ; U ; { x : A } |- x : A

--------------- :: Id'
P ; empty ; U µ { x : A } ; empty |- x : A

P ; Y1 ; U ; G1 |- t : A --o B
P ; Y2 ; U ; G2 |- u : A
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
--------------------------------- :: App
P ; Y1 µ Y2 ; U ; G1 µ G2 |- t u : B

P ; Y1 ; U ; G1 |- t : _!_
P ; Y2 ; U ; G2 |- u : B
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
--------------------------------- :: EffThen
P ; Y1 µ Y2 ; U ; G1 µ G2 |- t ; u : B

P ; Y1 ; U ; G1 |- t : 1
P ; Y2 ; U ; G2 |- u : A
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
----------------------------------------- :: PatU
P ; Y1 µ Y2 ; U ; G1 µ G2 |- case t of { () -> u } : A

P ; Y1 ; U ; G1 |- t : !A
P ; Y2 ; U µ { x : A } ; G2 |- u: B
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
----------------------------------------- :: PatE 
P ; Y1 µ Y2 ; U ; G1 µ G2 |- case t of { Ur x -> u } : B

P ; Y1 ; U ; G1 |- t : A1 + A2
P ; Y2 ; U ; G2 µ { x1 : A1 } |- u1 : B
P ; Y2 ; U ; G2 µ { x2 : A2 } |- u2 : B
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
------------------------------------------------------- :: PatS
P ; Y1 µ Y2 ; U ; G1 µ G2 |- case t of { inl x1 -> u1 , inr x2 -> u2 } : B

P ; Y1 ; U ; G1 |- t : A1 * A2
P ; Y2 ; U ; G2 µ { x1 : A1 , x2 : A2 } |- u : B
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
------------------------------------------------------- :: PatP
P ; Y1 µ Y2 ; U ; G1 µ G2 |- case t of {<x1, x2> -> u} : B

R =fix µ r. W
P ; Y1 ; U ; G1 |- t : R
P ; Y2 ; U ; G2 µ { x : W[r := R] } |- u : B
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
----------------------------- :: PatR
P ; Y1 µ Y2 ; U ; G1 µ G2 |- case t of { roll R x -> u } : B

P ; Y ; U ; G µ { d : |A| } |- t : _!_
------------------------------ :: Alloc
P ; Y ; U ; G |- alloc d A { t } : A

P ; Y ; U ; G |- t : |1|
----------------------- :: FillU
P ; Y ; U ; G |- fillUnit t : _!_

P ; Y1 ; U ; G1 |- t : |A|
P ; Y2 ; U ; G2 |- u : A
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
----------------------------------- :: FillL
P ; Y1 µ Y2 ; U ; G1 µ G2 |- fillLin t u : _!_


% TODO: should I allow Y != empty?

A is destFree
P ; Y1 ; U ; G |- t : |!A|
P ; empty ; U ; empty |- u : A
----------------------------------- :: FillE
P ; Y1 ; U ; G |- fillUr t u : _!_

P ; Y1 ; U ; G1 |- t : |A1 + A2|
P ; Y2 ; U ; G2 µ { d' : |A1| } |- u : B
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
----------------------------------------- :: FillInl
P ; Y1 µ Y2 ; U ; G1 µ G2 |- fillLeft t d' { u } : B

P ; Y1 ; U ; G1 |- t : |A1 + A2|
P ; Y2 ; U ; G2 µ { d' : |A2| } |- u : B
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
----------------------------------------- :: FillInr
P ; Y1 µ Y2 ; U ; G |- fillRight t d' { u } : B

P ; Y1 ; U ; G1 |- t : |A1 * A2|
P ; Y2 ; U ; G2 µ { d1 : |A1| , d2 : |A2| } |- u : B
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
----------------------------------------------:: FillP
P ; Y1 µ Y2 ; U ; G1 µ G2 |- fillPair t d1 d2 { u } : B

R =fix µ r. W
P ; Y1 ; U ; G1 |- t : |R|
P ; Y2 ; U ; G2 µ { d : |W[r := R]| } |- u : B
ctxdisjoint2 G1 G2
ctxdisjoint2 Y1 Y2
---------------------------------------------------------------- :: FillR
P ; Y1 µ Y2 ; U ; G1 µ G2 |- fillRoll R t d { u } : B

defns
Sem :: '' ::=

defn
command !! command' :: :: Reduce :: SemOp_ by

------------------- :: NoEff {{ com \remark{(value)} }}
L | H | o !! L | H | o

------------------- :: LDest {{ com \remark{(value)} }}
L | H | |l| !! L | H | |l|

------------------- :: Lam {{ com \remark{(value)} }}
L | H | \x:A.t !! L | H | \x:A.t

-------------------- :: HeapVal {{ com \remark{(value)} }}
L | H | C lbar !! L | H | C lbar

L0 | H0 | t !! L1 | H1 | \x:A.t'
L1 | H1 | u !! L2 | H2 | v2
L2 | H2 | t'[x := v2] !! L3 | H3 | v3
---------------------------- :: App
L0 | H0 | t u !! L3 | H3 | v3

L0 | H0 | t !! L1 | H1 | ()
L1 | H1 | u !! L2 | H2 | v2
--------------------------------------------- :: PatU
L0 | H0 | case t of { () -> u } !! L2 | H2 | v2

L0 | H0 | t !! L1 | H1 µ { l <| v1 } | Ur l
L1 | H1 | u[x := v1] !! L2 | H2 | v2
----------------------------------------------------- :: PatE
L0 | H0 | case t of { Ur x -> u } !! L2 | H2 | v2

L0 | H0 | t !! L1 | H1 µ { l <| v1 } | inl l
L1 | H1 | u1[x1 := v1] !! L2 | H2 | v2
----------------------------------------- :: PatInl
L0 | H0 | case t of {inl x1 -> u1, inr x2 -> u2} !! L2 | H2 | v2

L0 | H0 | t !! L1 | H1 µ { l <| v1 } | inr l
L1 | H1 | u2[x2 := v1] !! L2 | H2 | v2
----------------------------------------- :: PatInr
L0 | H0 | case t of {inl x1 -> u1, inr x2 -> u2} !! L2 | H2 | v2

L0 | H0 | t !! L1 | H1 µ { l1 <| v11, l2 <| v12 } | <l1, l2>
L1 | H1 | u[x1 := v11, x2 := v12] !! L2 | H2 | v2
-------------------------------------------------------------------------------- :: PatP
L0 | H0 | case t of {<x1,x2> -> u} !! L2 | H2 | v2

L0 | H0 | t !! L1 | H1 µ { l <| v1 } | roll R l
L1 | H1 | u[x := v1] !! L2 | H2 | v2
------------------------------------------------------ :: PatR
L0 | H0 | case t of { roll R x -> u } !! L2 | H2 | v2

L0 | H0 | t !! L1 | H1 | o
L1 | H1 | u !! L2 | H2 | v2
------------------------------------------------------ :: EffThen
L0 | H0 | t ; u !! L2 | H2 | v2

l notin L0
L0µ{l} | H0 | t[d := |l|] !! L1 | H1 µ { l <| v1 } | o
--------------------------------------------------- :: Alloc
L0 | H0 | alloc d A { t } !! L1 | H1 | v1

L0 | H0 | t !! L1 | H1 | |l|
---------------------------- :: FillU
L0 | H0 | fillUnit t !! L1 | H1 µ { l <| () } | o

L0 | H0 | t !! L1 | H1 | |l|
L1 | H1 | u !! L2 | H2 | v2
{ l <| v3 , lbar <| vbar } = deepCopy(L2, v2)
------------------------------------------------------------ :: FillL
L0 | H0 | fillLin t u !! L2 µ { l bar } | H2 µ { l <| v3, l bar <| vbar } | o

L0 | H0 | t !! L1 | H1 | |l|
L1 | H1 | u !! L2 | H2 | v2
l' notin L2
{ l' <| v3 , lbar <| vbar } = deepCopy(L2 µ {l'}, v2)
--------------------------------------------------- :: FillE
L0 | H0 | fillUr t u !! L2 µ {l', l bar} | H2 µ { l <| Ur l', l' <| v3, l bar <| vbar } | o

l' notin L1
L0 | H0 | t !! L1 | H1 | |l|
L1µ{l'} | H1 | u[d := |l'|] !! L2 | H2 µ { l' <| v1 } | v2
------------------------------------------------------------ :: FillInl
L0 | H0 | fillLeft t d { u } !! L2 | H2 µ { l <| inl l', l' <| v1 } | v2

l' notin L1
L0 | H0 | t !! L1 | H1 | |l|
L1µ{l'} | H1 | u[d := |l'|] !! L2 | H2 µ { l' <| v1 } | v2
------------------------------------------------------------ :: FillInr
L0 | H0 | fillRight t d { u } !! L2 | H2 µ { l <| inr l', l' <| v1 } | v2

l1 notin L1
l2 notin L1 µ { l1 }
L0 | H0 | t !! L1 | H1 | |l|
L1µ{l1,l2} | H1 | u[d1 := |l1|, d2 := |l2|] !! L2 | H2 µ { l1 <| v11, l2 <| v12 } | v2
--------------------------------------------------------------- :: FillP
L0 | H0 | fillPair t d1 d2 { u } !! L2 | H2 µ { l <| <l1, l2>, l1 <| v11, l2 <| v12 } | v2

l' notin L1
L0 | H0 | t !! L1 | H1 | |l|
L1µ{l'} | H1 | u[d := |l'|] !! L2 | H2 µ { l' <| v1 } | v2
--------------------------------------------------- :: FillR
L0 | H0 | fillRoll R t d { u } !! L2 | H2 µ { l <| roll R l', l' <| v1 } | v2

parsing
v_Lam <= t_Sub
t_PatU <= t_App
t_PatU <= t_FillL
judg_HeapAffIn <= ha_Val
hcons_Inl <= terminals_v1
