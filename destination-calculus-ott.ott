% minimal + latex + comments

embed
{{ tex-preamble
\usepackage{stmaryrd}
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{bbold}
\DeclareSymbolFont{bbsymbol}{U}{bbold}{m}{n}
\DeclareMathSymbol{\bbsemicolon}{\mathbin}{bbsymbol}{"3B}
\DeclareMathSymbol{\bbcomma}{\mathbin}{bbsymbol}{"2C}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{lbcolor}{RGB}{186, 58, 7}
\definecolor{modecolor}{RGB}{200, 120, 211}
\definecolor{effcolor}{RGB}{186, 58, 7}
\definecolor{kwcolor}{RGB}{0, 0, 0}
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\textcolor{kwcolor}{\mathsf{#1} } }
\newcommand{\ottdefault}[1]{\textcolor{black}{\mathsf{#1} } }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\ottlb}[1]{\textcolor{lbcolor}{#1} }
\newcommand{\ottmod}[1]{\textcolor{modecolor}{\mathsf{#1} } }
\newcommand{\otteff}[1]{\textcolor{effcolor}{\mathsf{#1} } }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle destent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\storearrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyStore}[1]{\textsc{TyStore\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\small\itshape #1} }
\newcommand{\holearrowgen}[1]{\ottho{\text{#1}\!\!\!\rightharpoonup} } % 
\def\restriction#1#2{\mathchoice
              {\setbox1\hbox{${\displaystyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\textstyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptscriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} } }
\def\restrictionaux#1#2{ {#1\,\smash{\vrule height .8\ht1 depth .85\dp1} }_{\,#2} }
\usepackage[safe]{tipa}
\newcommand{\mpar}{\ottty{\text{\large\textramshorns} } }
\newcommand{\mparcomma}{ {\scriptstyle\odot} }
\newcommand{\expc}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{-.1ex}{\hspace{-0.4ex}\scriptsize c} } }\hspace{-0.7ex} }
\newcommand{\expw}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{0.05ex}{\hspace{-0.6ex}${\scriptscriptstyle\omega}$} } }\hspace{-0.7ex} }
\newcommand{\putarrow}[1]{\!\overset{#1}{\triangleleft}\!}
\newcommand{\lam}[3]{\ottcons{\lambda}\,#1\!:\!#2\,\textbf{.}\,#3}
\newcommand{\lamnt}[2]{\ottcons{\lambda}\,#1\,\textbf{.}\,#2}
\newcommand{\Lam}[2]{\ottcons{\Lambda}\,#1\,\textbf{.}\,#2}
\newcommand{\nuabs}[1]{\nu#1\textbf{.}\,}
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar termvar, x, y, d ::= {{ com Term-level variable }}
  {{ tex \ottmv{[[termvar]]} }}

% metavar idxvar, i ::=
%   {{ tex \ottmv{[[idxvar]]} }}

grammar

label, l :: 'Lbl_' ::= {{ tex \ottlb{[[label]]} }} {{ com Label }}

mode, m :: 'Mode_' ::= {{ tex \ottmod{[[mode]]} }} {{ com Mode }}
  | _ :: :: Placeholder {{ tex \ottmod{\_} }} {{ com Placeholder for any mode }}
  | _L :: :: Local {{ tex \ottmod{\scriptstyle L} }} {{ com Local }}
  | _F :: :: Foreign {{ tex \ottmod{\scriptstyle F} }} {{ com Foreign }}
  | _G :: :: Global {{ tex \ottmod{\scriptstyle G} }} {{ com Global }}
  | max_mode ( G ) :: :: MaxCtx {{ tex \ottmod{max\_mode(}[[G]]\ottmod{)} }}
  | if mode_cond then m3 else m4 :: :: If {{ tex \ottmod{if}~[[mode_cond]]~\ottmod{then}~[[m3]]~\ottmod{else}~[[m4]] }}

mode_cond :: 'ModeCond' ::= {{ com Mode statement }}
  | m1 = m2 :: :: Eq
  | m1 <= m2 :: :: Leq
  | m in suprmodes ( G ) :: :: Supr
  | exists m in suprmodes ( G ) :: :: ExistsSupr

type, A, B :: 'Ty_' ::= {{ com Type }} {{ tex \ottty{[[type]]} }}
  | 1 :: :: Unit {{ tex \ottty{1} }} {{ com Unit }}
  | A1 + A2 :: :: Sum {{ tex [[A1]]\ottty{\oplus}[[A2]] }} {{ com Sum }}
  | A1 * A2 :: :: Prod {{ tex [[A1]]\ottty{\otimes}[[A2]] }} {{ com Product }}
  | A1 ><| A2 :: :: Ampar {{ tex [[A1]]\,[[><|]]\,[[A2]] }} {{ com Ampar type (consuming $[[A1]]$ yields $[[A2]]$) }}
  | m1 A1 --o A2 :: :: Lambda {{ tex _{[[m1]]}[[A1]]\,[[--o]]\,[[A2]] }} {{ com Linear function }}
  | Dest A :: :: Dest {{ tex [[A]]\ottty{^\bot} }} {{ com Destination }}
  | ( A ) :: S :: Paren {{ tex \ottty{(}[[A]]\ottty{)} }}

dynamic_value, v :: 'DynVal_' ::= {{ com Dynamic value }}
  % | o :: :: Bottom
  % | W :: :: Witness {{ tex \Lam{[[s]]}{[[n]]} }} {{ com Unit-like representation for witnesses }}
  | l :: :: Hole {{ com Hole }}
  | @ l :: :: Dest {{ tex \ottlb{@}[[l]] }} {{ com Destination }}
  | () :: :: Unit {{ com Unit }}
  | Inl v :: :: Inl {{ com Left variant for sum }}
  | Inr v :: :: Inr {{ com Right variant for sum }}
  | < v1 , v2 > :: :: Prod {{ tex \ottcons{\langle}\,[[v1]]\,\ottcons{,}~[[v2]]\,\ottcons{\rangle} }} {{ com Product }}
  | < v1 ¤ v2 > :: :: Ampar {{ tex \ottcons{\langle}\,[[v1]]\,\ottcons{\bbcomma}~[[v2]]\,\ottcons{\rangle} }} {{ com Ampar ($[[v2]]$ is the root of the structure being built) }}
  | \ x -> t :: :: Lambda {{ tex \lamnt{[[x]]}{[[t]]} }} {{ com Linear function }}
  | ( v ) :: S :: Paren

term, t, u :: 'Term_' ::=                                               {{ com Term }}
  | v :: :: DynVal {{ com Dynamic value }}
  | x :: :: Var {{ com Variable }}
  | t u                                    ::   :: App      {{ com Application }}
  | t ; u                   ::   :: PatUnit {{ com Pattern-match on unit }}
  | case t of { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatSum     {{ com Pattern-match on sum }} {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{\,\ottcons{Inl}\,[[x1]]\,[[->]]\,[[u1]]\,,~\ottcons{Inr}\,[[x2]]\,[[->]]\,[[u2]]\,\} }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatProd     {{ com Pattern-match on product }} {{ tex \ottkw{case}~[[t]]~\ottkw{of}~\{\,\ottcons{\langle}\,[[x1]]\,\ottcons{,}~[[x2]]\,\ottcons{\rangle}\,[[->]]\,[[u]]\,\} }}
  | t <&> \ x -> u :: :: MapAmpar {{ com Map over the left side of the ampar }} {{ tex \ottkw{mapL}~[[t]]~\ottkw{with}~\{\,[[x]]\,[[->]]\,[[u]]\,\} }}

  % | toGlobal t :: :: ToGlobal {{ tex \ottkw{to}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion to ${\ottmod{\scriptstyle G} }$ }}
  % | fromGlobal t :: :: FromGlobal {{ tex \ottkw{from}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion from ${\ottmod{\scriptstyle G} }$ }}
  | toAmpar t :: :: ToAmpar {{ tex \ottkw{to}_{[[><|]]} }} {{ com Wrap $[[t]]$ into a trivial ampar }}
  | fromAmpar t :: :: FromAmpar {{ tex \ottkw{from}_{[[><|]]} }} {{ com Extract value from trivial ampar }}

  | alloc :: :: Alloc {{ com Return a fresh "identity" ampar object }}
  | t <| () :: :: FillUnit {{ com Fill destination with unit }}
  | t <| Inl                          ::   :: FillInl   {{ com Fill destination with left variant }}
  | t <| Inr                          ::   :: FillInr   {{ com Fill destination with right variant }}
  | t <| <,>                              ::   :: FillProd    {{ com Fill destination with product constructor }}
  | t <|. u :: :: FillComp {{ com Fill destination with root of ampar $[[u]]$ }}

  | ( t )                                   :: S :: Paren
  | t [ e ]                             :: M :: SubEff
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
  % | t b spe :: S :: BreakSpacing3

sub :: 'Sub_' ::= {{ com variable or label substitution }}
  | x -> v :: :: VarSub
  % | x := t :: :: VarSub

subs :: 'Subs_' ::= {{ com variable or  substitutions }}
  | sub :: :: Single
  | sub , subs :: :: Multiple

effect, e :: 'e_' ::= {{ tex \otteff{[[effect]]} }}
  | o :: :: NoEff {{ com empty effect }} {{ tex \otteff{\varepsilon} }}
  | subs :: :: Sub

% heap_affect, ha :: 'HeapAff_' ::=
%   | l = hv :: :: Aff {{ tex [[l]]\,=\,[hv]] }}

% heap_affects :: 'HeapAffs_' ::=
%   | ha :: :: Single
%   | ha , heap_affects :: :: Multiple

% heap, H :: 'Heap_' ::=
%   | empty :: :: Empty
%   | { heap_affects } :: :: Affs
%   | H1 µ H2 :: :: Disjoint

type_affect, ta :: 'TyAff_' ::= {{ com type affectation }}
%  | x : A :: :: LocalVar
  | x : m A :: :: Var {{ tex [[x]]:_{[[m]]}[[A]] }}
  | + l : A :: :: Hole {{ com Hole }} {{ tex \ottlb{+}[[l]]:[[A]] }}
  | - l : A :: :: Dest {{ com Destination }} {{ tex \ottlb{-}[[l]]:[[A]] }}

type_affects :: 'TyAffs_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, U {{ tex \mho }}, G {{ tex \Gamma }} :: 'TyCtx_' ::= {{ com typing context }}
  | {}    ::   :: Empty
  | { type_affects } ::    :: Affs
  | G1 µ G2    ::    :: Disjoint
  | G1 µ+ G2 :: :: DisjointInteract
  | G [ m1 -> m2 ] :: :: OverwriteMode

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=
% === Type syntax ===
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | ><| :: :: rtimes {{ tex \ottty{\rtimes} }}
  % | =fix :: :: fix {{ tex \overset{\mathsf{fix} }{=} }}

% === Term syntax ===
  | ->                                     ::   :: mapsto       {{ tex \mapsto }}
  | () :: :: unit {{ tex \ottcons{()} }}
  | Inl :: :: inl {{ tex \ottcons{Inl} }}
  | Inr :: :: inr {{ tex \ottcons{Inr} }}
  | <,> :: :: prod {{ tex \ottcons{\langle{,}\rangle} }}
  | ¤ :: :: mparcomma {{ tex \mparcomma }}
  | <| :: :: fill {{ tex \triangleleft }}
  | <|. :: :: fillcomp {{ tex \triangleleft\cdot\, }}
  | ';' :: :: sep {{ tex ~;\, }}
  % | <&> :: :: flipmap {{ tex \prec\!\!{\scriptstyle\ottkw{mapL} }\!\!\succ }}
  % | _!_ :: :: bottom {{ tex \ottty{\bot} }}

% === Contexts ===
  | µ :: :: dunion {{ tex \sqcup }}
  | µ+ :: :: sdunion {{ tex \,\text{\makebox[0pt][l]{$\sqcup$}\raisebox{.40ex}{\hspace{.15ex}$\scriptscriptstyle\pm$} } }}
  | '{}' :: :: empty {{ tex \{\} }}

% === Judgements ===
  | exists :: :: exists {{ tex \exists }}
  | != :: :: neq {{ tex \neq }}
  | <= :: :: leq {{ tex \leq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | includedin :: :: includedin {{ tex \subset }}
  | names :: :: names {{ tex \mathcal{N} }}

% === Typing ===
  | |- :: :: turnstile {{ tex \vdash }}

% === Semantics ===
  | --> :: :: rlocal {{ tex \longrightarrow }}
  | ~~> :: :: rglobal {{ tex \rightsquigarrow }}
  % | !! :: :: downto {{ tex \Downarrow }}

defns
Ctx :: '' ::=

defn
x in names ( G ) :: :: CtxVarIn :: CtxVarIn_ by

defn
l in names ( G ) :: :: CtxLblIn :: CtxLblIn_ by

defn
x notin names ( G ) :: :: CtxVarNotIn :: CtxVarNotIn_ by

defn
l notin names ( G ) :: :: CtxLblNotIn :: CtxLblNotIn_ by

defn
fresh x :: :: FreshVar :: FreshVar_ by

defn
fresh l :: :: FreshLbl :: FreshLbl_ by

defn
type_affect in G :: :: CtxTyAffIn :: CtxTyAffIn_ by

defn
mode_cond :: :: ModeCond :: ModeCond_ by

defns
Eq :: '' ::=

defn
A1 = A2 :: :: EqType :: EqType_ by
defn
A1 != A2 :: :: NeqType :: NeqType_ by
defn
t = u :: :: EqTerm :: EqTerm_ by
defn
t != u :: :: NeqTerm :: NeqTerm_ by
defn
G1 = G2 :: :: EqCtx :: EqCtx_ {{ tex [[G1]] = [[G2]] }} by
defn
G1 disjoint G2 :: :: DisjointCtx :: DisjointCtx_ {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }} by

defns
Ty :: '' ::=

% Une dest qui parait plus vieille qu'elle ne l'est réellement (donc qui aurait une date de naissance plus petite que la vraie) peut fuiter dans le scope parent en étant utilisée comme valeur stockée. C'est un problème immédiat, qui doit être étendu à tout conteneur qui contiendrait une telle dest => Date de naissance d'un truc = max de la date de naissance de ses composants

% Une dest qui parait plus jeune qu'elle ne l'est pourrait servir à faire fuiter une dest dans le scope parent, mais impossible tant que son type ne change pas -> aucun problème à prendre le max des dates de naissance.

defn
G |- t : A :: :: TyTerm :: TyTerm_ {{ tex [[G]][[|-]][[t]]\,:[[A]] }} by

% G |- t : _G A
% ----------------- :: WeakenLocal
% G |- fromGlobal t : m A

% _G = max_mode(G)
% G |- t : m A
% ----------------- :: WeakenForeign
% G |- toGlobal t : _G A

---------------- :: Hole
{ + l : A } |- l : A

% -l behaves as a global binding
---------------- :: Dest
{ - l : A } |- @l : Dest A

---------------- :: Unit
{} |- () : 1

% Dynamic values cannot contain variables in G as it isn't a value of form v

G |- v : A1
---------------- :: Inl
G |- Inl v : A1 + A2

G |- v : A2
---------------- :: Inr
G |- Inr v : A1 + A2

G1 |- v1 : A1
G2 |- v2 : A2
----------------- :: Prod
G1 µ G2 |- < v1, v2 > : A1 * A2

% left side isn't allowed to contain holes (nor variables of any type because of shape v); should we enforce that?
% right side can contain both holes and destinations
G1 |- v1 : A1
G2 |- v2 : A2
G3 = G1 µ+ G2
----------------- :: Ampar
G3 |- < v1 ¤ v2 > : A1 ><| A2

G µ { x : m1 A1 } |- t : A2
----------------- :: Lambda
G |- \x -> t : m1 A1 --o A2

G1 |- t : m1 A1 --o A2
G2 |- u : A1
m1 in suprmodes(G2)
----------------- :: App
G1 µ G2 |- t u : A2

G1 |- t : 1
G2 |- u : B
----------------- :: PatUnit
G1 µ G2 |- t ; u : B

G1 |- t : A1 + A2
exists m in suprmodes (G1)
G2 µ { x1 : m A1 } |- u1 : B
G2 µ { x2 : m A2 } |- u2 : B
----------------- :: PatSum
G1 µ G2 |- case t of { Inl x1 -> u1 , Inr x2 -> u2 } : B

G1 |- t : A1 * A2
exists m in suprmodes (G1)
G2 µ { x1 : m A1, x2 : m A2 } |- u : B
----------------- :: PatProd
G1 µ G2 |- case t of { < x1 , x2 > -> u } : B

G1 |- t : A1 ><| A2
% ensures that we cannot capture dests of different scopes (G2)
exists m' in suprmodes(G1 µ G2)
m = if _F in suprmodes(G1) then _F else _L
G2[ _L -> _F ] µ { x : m A1 } |- u : B
-------------------------------- :: MapAmpar
G1 µ G2 |- t <&> \ x -> u : B ><| A2

-------------------------------- :: Alloc
{} |- alloc : Dest A ><| A

G |- t : A
------------------------------- :: ToAmpar
G |- toAmpar t : 1 ><| A

G |- t : 1 ><| A
------------------------------- :: FromAmpar
G |- fromAmpar t : A

G |- t : Dest 1
------------------------------ :: FillUnit
G |- t <| () : 1

G |- t : Dest (A1 + A2)
------------------------------ :: FillInl
G |- t <| Inl : Dest A1

G |- t : Dest (A1 + A2)
------------------------------ :: FillInr
G |- t <| Inr : Dest A2

G |- t : Dest (A1 * A2)
------------------------------ :: FillProd
G |- t <| <,> : Dest A1 * Dest A2

G1 |- t : Dest A2
G2 |- u : A1 ><| A2
_L in suprmodes(G1)
_F in suprmodes(G2)
----------------------------- :: FillCompL
G1 µ G2 |- t <|. u : A1

G1 |- t : Dest A2
G2 |- u : A1 ><| A2
_F in suprmodes(G1)
_G in suprmodes(G2)
----------------------------- :: FillCompF
G1 µ G2 |- t <|. u : A1

parsing
Ty_Prod <= Ty_Dest
Ty_Sum <= Ty_Dest
Ty_Ampar <= Ty_Dest
