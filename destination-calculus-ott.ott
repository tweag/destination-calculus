% minimal + latex + comments

embed
{{ tex-preamble
\usepackage{stmaryrd}
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
%\usepackage{mathptmx}
\definecolor{mvcolor}{RGB}{119, 24, 201}
\definecolor{tycolor}{RGB}{26, 87, 186}
\definecolor{ntcolor}{RGB}{105, 105, 105}
\definecolor{spcolor}{RGB}{5, 115, 12}
\definecolor{multcolor}{RGB}{26, 87, 186}
\definecolor{holecolor}{RGB}{186, 58, 7}
\definecolor{effcolor}{RGB}{186, 58, 7}
\definecolor{eccolor}{RGB}{58, 120, 7}
\definecolor{kwcolor}{RGB}{0, 0, 0}
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\textcolor{kwcolor}{\mathsf{#1} } }
\newcommand{\ottdefault}[1]{\textcolor{black}{\mathsf{#1} } }
\newcommand{\ottcons}[1]{\mathsf{#1} }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathsf{#1} } }
\newcommand{\ottho}[1]{\textcolor{holecolor}{#1} }
\newcommand{\otteff}[1]{\textcolor{effcolor}{\mathsf{#1} } }
\newcommand{\ottec}[1]{\textcolor{eccolor}{#1} }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\ottmult}[1]{\textcolor{multcolor}{\mathit{#1} } }
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle destent \rangle} } }
\makeatletter
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\storearrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyStore}[1]{\textsc{TyStore\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\small\itshape #1} }
\newcommand{\holearrowgen}[1]{\ottho{\text{#1}\!\!\!\rightharpoonup} } % 
\def\restriction#1#2{\mathchoice
              {\setbox1\hbox{${\displaystyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\textstyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptscriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} } }
\def\restrictionaux#1#2{ {#1\,\smash{\vrule height .8\ht1 depth .85\dp1} }_{\,#2} }
\usepackage[safe]{tipa}
\newcommand{\mpar}{\ottty{\text{\large\textramshorns} } }
\newcommand{\mparcomma}{ {\scriptstyle\odot} }
\newcommand{\expc}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{-.1ex}{\hspace{-0.4ex}\scriptsize c} } }\hspace{-0.7ex} }
\newcommand{\expw}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{0.05ex}{\hspace{-0.6ex}${\scriptscriptstyle\omega}$} } }\hspace{-0.7ex} }
\newcommand{\putarrow}[1]{\!\overset{#1}{\triangleleft}\!}
\newcommand{\lam}[3]{\lambda\,#1\!:\!#2\,\textbf{.}\,#3}
\newcommand{\nuabs}[1]{\nu#1\textbf{.}\,}
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar metavariable, x, y ::=
  {{ tex \ottmv{[[metavariable]]} }}

grammar
% value, v :: 'v_' ::= {{ com value (unreducible term) }}
%   | o :: :: BotVal {{ com bottom ``unit'' }}
%   | d                                       ::   :: Data      {{ com data structure }}

data_value, d :: 'd_' ::=
  | | x | :: :: D {{ com destination }} {{ tex \ottmv{\lfloor[[x]]\rfloor} }}
  | x :: :: Var {{ com var or hole }}
  | * ::   :: U {{ com unit }}
  | \ x : D . t :: ::  Fn {{ com lambda abstraction }} {{ tex \lam{[[x]]}{[[D]]}{[[t]]} }}
  | Ur d :: :: E {{ com exponential }}
  | Inl d :: :: Inl {{ com sum variant 1 }}
  | Inr d :: :: Inr {{ com sum variant 2 }}
  % | @ R d :: :: R {{ com recursive data }}
  | < d1 , d2 > :: :: P {{ com product }}
  | nu V . d :: :: Nu {{ com name abstraction }}
  | C d :: :: C
  | < d1 ¤ d2 > :: :: M {{ com memory par }}
  | ( d ) :: S :: Paren

term, t, u :: 't_' ::=                                               {{ com term }}
  | d :: :: Val {{ com value }}
  | nu V . t :: :: Nu
  | C t :: :: C
  | < t1 ¤ t2 > :: :: Mpar
  | t u                                    ::   :: App      {{ com application }}
%  | t ; u :: :: EffSeq {{ com effect sequencing }} {{ tex [[t]] \,\fatsemi\, [[u]] }}
%  | case t of { C x -> u } :: :: PatC {{ com pattern-matching on linear complete value }}
  | case t of { * -> u }                   ::   :: PatU {{ com pattern-matching on unit }}
  | case t of { Ur x -> u } :: :: PatE {{ com pattern-matching on unrestricted complete value }}
  | case t of { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatS     {{ com pattern-matching on sum }}
  % | case t of { @ R x -> u } :: :: PatR {{ com pattern-matching on recursive data }}
  | case t of { < x1 , x2 > -> u }            ::   :: PatP     {{ com pattern-matching on product }}
  | extract t :: :: Ex {{ com remove $\ottcons{C}$ wrapper }}
  | flip t :: :: FlipM {{ com flip mpar sides }}
  | reassoc t :: :: ReassocM {{ com reassociated nested mpar }}
  | redL t :: :: RedLM {{ com get right value when left is bottom }}
  | mapL t with u :: :: MapLM {{ com map function on left side }}
  | fillLeaf p t u :: :: FillL {{ com move into destination }} {{ tex [[t]]~\putarrow{[[p]]}~[[u]] }}
  | fillUnit p t :: :: FillU {{ com fill destination with unit }} {{ tex [[t]]~\putarrow{[[p]]}~[[*]] }}
%  | fillFn p t { \ x : D . u } :: :: FillFn {{ com fill destination with function }} {{ tex [[t]]~\putarrow{[[p]]}~\lam{[[x]]}{[[D]]}{[[u]]} }}
  | fillUr p t :: :: FillE {{ com fill destination with exponential }} {{ tex [[t]]~\putarrow{[[p]]}~[[Ur]] }}
  | fillLeft p t                          ::   :: FillInl   {{ com fill destination with sum variant 1 }} {{ tex [[t]]~\putarrow{[[p]]}~[[Inl]] }}
  | fillRight p t                          ::   :: FillInr   {{ com fill destination with sum variant 2 }} {{ tex [[t]]~\putarrow{[[p]]}~[[Inr]] }}
  % | fillRoll p t R :: :: FillR {{ com fill destination with recursive type label }} {{ tex [[t]]~\putarrow{[[p]]}~\ottty{[[@]][[R]]} }}
  | fillPair p t                              ::   :: FillP    {{ com fill destination with product }} {{ tex [[t]]~\putarrow{[[p]]}~\ottcons{\langle,\rangle} }}
  | fillMpar p t :: :: FillM {{ com fill destination with data mpar }} {{ tex [[t]]~\putarrow{[[p]]}~\ottcons{\langle\mparcomma\rangle} }}
  | ( t )                                   :: S :: Paren
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
%  | t b spe :: S :: BreakSpacing3
  | t [ e ]                             :: M :: Sub
  | E [ t ] :: M :: Ec
  | F [ t ] :: M :: Fc
  | nu * V . t :: M :: NuMayEmpty {{ tex [[nu]]^\star [[V]][[.]][[t]] }}

% hole, h :: 'h_' ::= {{ com hole }} {{ tex \ottho{[[hole]]} }}

multiplicity, p, px {{ tex \ottmult{p_\mathsf{x} } }} :: 'mult_' ::= {{ com multiplicity }} {{ tex \ottmult{[[multiplicity]]} }}
  | l :: :: One {{ com for holes/destinations not under a $\ottcons{Ur}$ }} {{ tex \ottmult{1} }}
  | w :: :: Many {{ com for holes/destinations under a $\ottcons{Ur}$ }} {{ tex \ottmult{\omega} }}

effect, e :: 'e_' ::= {{ tex \otteff{[[effect]]} }}
  | o :: :: NoEff {{ com empty effect }} {{ tex \otteff{\varepsilon} }}
  | subs :: :: Sub
%  | e1 . e2 :: :: Concat {{ tex [[e1]] \cdot [[e2]] }}

sub :: 'sub_' ::= {{ com variable or hole substitution }}
  | x := d :: :: VarSub
  | x := d with nu V :: :: VarSubNu

name_set, V :: 'ns_' ::= {{ tex \ottmv{[[name_set]]} }}
  | empty :: :: Empty
  | { names } :: :: Single
  | V1 µ V2 :: :: Union

names :: 'names_' ::=
  | x :: :: Single
  | x , names :: :: Multiple

subs :: 'subs_' ::= {{ com variable or hole substitutions }}
  | sub :: :: Single
  | sub , subs :: :: Multiple

% type, A :: 'ty_' ::= {{ tex \ottty{[[type]]} }}
%   | _!_ :: :: Bottom {{ com bottom (effect) type }}
%   | D :: :: Data

data_type, D :: 'dty_' ::= {{ tex \ottty{[[data_type]]} }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
  | Z :: :: NoCData
%  | R :: :: Rec {{ com recursive type bound to a name }}
  | D1 * D2 :: :: Prod {{ com product type }} {{ tex \ottty{[[D1]]\!\otimes\![[D2]]} }}
  | D1 mpar D2 :: :: Mpar
  | D1 + D2 :: :: Sum {{ com sum type }} {{ tex \ottty{[[D1]]\!\oplus\![[D2]]} }}
  | D1 --o D2 :: :: LinArr {{ com linear function type }}
  | | Z | ^ p :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[Z]] \rfloor}^{[[p]]} }}
  | !w D :: :: Exp {{ com exponential }}
  | !c D :: :: Comp
  | ( D )  :: S :: Paren {{ tex \ottty{([[D]])} }}
%  | DV [ X := D ] :: M :: Sub {{ com unroll a recursive data type }} {{ tex [[DV]]\ottdefault{[} \ottty{X}~\ottdefault{[[:=]]}~\ottty{[[D]]} \ottdefault{]} }}

noc_data_type, Z, Zx {{ tex \ottty{Z_x} }} :: 'ncdty_' ::= {{ tex \ottty{[[noc_data_type]]} }} {{ com Data type with no $[[!c]]$ at top level }}
  | 1 :: :: One {{ com unit type }} {{ tex \ottty{[[1]]} }}
%  | R :: :: Rec {{ com recursive type bound to a name }}
  | D1 * D2 :: :: Prod {{ com product type }} {{ tex \ottty{[[D1]]\!\otimes\![[D2]]} }}
  | D1 mpar D2 :: :: Mpar
  | D1 + D2 :: :: Sum {{ com sum type }} {{ tex \ottty{[[D1]]\!\oplus\![[D2]]} }}
  | D1 --o D2 :: :: LinArr {{ com linear function type }}
  | | Z | ^ p :: :: Dest {{ com destination type }} {{ tex \ottty{\lfloor [[Z]] \rfloor}^{[[p]]} }}
  | !w D :: :: Exp {{ com exponential }}
  | ( Z )  :: S :: Paren {{ tex \ottty{([[Z]])} }}
%  | ZV [ X := D ] :: M :: Sub {{ com unroll a recursive data type }} {{ tex [[ZV]]\ottdefault{[} \ottty{X}~\ottdefault{[[:=]]}~\ottty{[[D]]} \ottdefault{]} }}

% nocdest_data_type, N :: 'ncddty_' ::= {{ tex \ottty{[[nocdest_data_type]]} }} {{ com Data type with no dest in its tree and no $[[!c]]$ at top level }}

% type_with_var, AV {{ tex \ottty{\underline{A} } }} :: 'tywv_' ::= {{ tex \ottty{[[type_with_var]]} }}
%   | _!_ :: :: Bottom
%   | DV :: :: Data

% data_type_with_var, DV {{ tex \ottty{\underline{D} } }} :: 'dtywv_' ::= {{ tex \ottty{[[data_type_with_var]]} }}
%   | X :: :: Var {{ tex \ottty{X} }}
%   | 1 :: :: One {{ tex \ottty{[[1]]} }}
%   | ZV :: :: NoCData
%   | R :: :: Rec
%   | DV1 * DV2 :: :: Prod {{ tex \ottty{[[DV1]] \otimes [[DV2]]} }}
%   | DV1 + DV2 :: :: Sum {{ tex \ottty{[[DV1]] \oplus [[DV2]]} }}
%   | DV1 --o DV2 :: :: LinArr {{ tex \ottty{[[DV1]] [[--o]] [[DV2]]} }}
%   | DV1 mpar DV2 :: :: Mpar {{ tex \ottty{[[DV1]] \mpar [[DV2]]} }}
%   | | ZV | ^ p :: :: Dest {{ tex \ottty{\lfloor [[ZV]] \rfloor}^{[[p]]} }}
%   | !w NV :: :: Exp
%   | !c DV :: :: Comp
%   | ( DV )  :: S :: Paren {{ tex \ottty{([[DV]])} }}

% noc_data_type_with_var, ZV {{ tex \ottty{\underline{Z} } }} :: 'ncdtwv_' ::= {{ tex \ottty{[[noc_data_type_with_var]]} }}

% nocdest_data_type_with_var, NV {{ tex \ottty{\underline{N} } }} :: 'ncddtwv_' ::= {{ tex \ottty{[[nocdest_data_type_with_var]]} }}

% rec_type_bound, R :: 'rtb_' ::= {{ com name for recursive type }} {{ tex \ottty{[[rec_type_bound]]} }}

% rec_type_def :: 'rtd_' ::= {{ com recursive type definition }}
%   | µ X . DV :: :: Abs {{ tex \mu\,\ottty{X}\,\textbf{.}\,[[DV]] }}

% sign, s :: 'sgn_' ::= {{ com sign }}
%   | + :: :: Plus
%   | - :: :: Minus

type_affect, ta :: 'ta_' ::= {{ com type affectation }}
  | x : D ::  :: Var {{ com variable }}
  | - x : ^ p Z ::  :: Hole {{ com hole }} {{ tex \ottmv{-}[[x]]:^{[[p]]} [[Z]] }}

type_affects :: 'tas_' ::= {{ com type affectations }}
  | ta :: :: Single
  | ta , type_affects :: :: Multiple

typing_context, U {{ tex \mho }}, G {{ tex \Gamma }}, Gn {{ tex \Gamma^- }} :: 'tc_' ::= {{ com typing context }}
  | empty    ::   :: Empty
  | { type_affects } ::    :: Var
  | unionall x in V G :: :: Union {{ tex \!\!\bigsqcup\limits_{[[x]] \in [[V]]} [[G]] }}
  | G1 µ G2    ::    :: Disjoint
  | G1 µ+ G2 :: :: SDisjoint
  | G1 µ~ G2 :: :: HDisjoint

E :: 'ec_' ::= {{ com evaluation context without nu }} {{ tex \ottec{[[E]]} }}
  | [ ] :: :: Window {{ tex \ottec{[~]} }}
  | C E :: :: C
  | < E ¤ t > :: :: Mpar1
  | < d ¤ E > :: :: Mpar2
  | E t :: :: App1
  | d E :: :: App2
  | case E of { * -> u }                   ::   :: PatU
  | case E of { Ur x -> u } :: :: PatE
  | case E of { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatS
  % | case E of { @ R x -> u } :: :: PatR
  | case E of { < x1 , x2 > -> u }            ::   :: PatP
  | extract E :: :: Ex
  | flip E :: :: FlipM
  | reassoc E :: :: ReassocM
  | redL E :: :: RedLM
  | mapL E with t :: :: MapLM1
  | mapL d with E :: :: MapLM2
  | fillLeaf p E t :: :: FillL1 {{ tex [[E]]~\putarrow{[[p]]}~[[t]] }}
  | fillLeaf p d E :: :: FillL2 {{ tex [[d]]~\putarrow{[[p]]}~[[E]] }}
  | fillUnit p E :: :: FillU {{ tex [[E]]~\putarrow{[[p]]}~[[*]] }}
%  | fillFn p E { \ x : D . u } :: :: FillFn {{ tex [[E]]~\putarrow{[[p]]}~\lam{[[x]]}{[[D]]}{[[u]]} }}
  | fillUr p E :: :: FillE {{ tex [[E]]~\putarrow{[[p]]}~[[Ur]] }}
  | fillLeft p E                          ::   :: FillInl   {{ tex [[E]]~\putarrow{[[p]]}~[[Inl]] }}
  | fillRight p E                          ::   :: FillInr   {{ tex [[E]]~\putarrow{[[p]]}~[[Inr]] }}
  % | fillRoll p E R :: :: FillR {{ tex [[E]]~\putarrow{[[p]]}~\ottty{[[@]][[R]]} }}
  | fillPair p E                              ::   :: FillP    {{ tex [[E]]~\putarrow{[[p]]}~\ottcons{\langle,\rangle} }}
  | fillMpar p E :: :: FillM {{ tex [[E]]~\putarrow{[[p]]}~\ottcons{\langle\mparcomma\rangle} }}

F :: 'fc_' ::= {{ com evaluation context }} {{ tex \ottec{[[F]]} }}
  | [ ] :: :: Window {{ tex \ottec{[~]} }}
  | nu V . F :: :: Nu
  | C F :: :: C
  | < F ¤ t > :: :: Mpar1
  | < d ¤ F > :: :: Mpar2
  | F t :: :: App1
  | d F :: :: App2
  | case F of { * -> u }                   ::   :: PatU
  | case F of { Ur x -> u } :: :: PatE
  | case F of { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatS
  % | case F of { @ R x -> u } :: :: PatR
  | case F of { < x1 , x2 > -> u }            ::   :: PatP
  | extract F :: :: Ex
  | flip F :: :: FlipM
  | reassoc F :: :: ReassocM
  | redL F :: :: RedLM
  | mapL F with t :: :: MapLM1
  | mapL d with F :: :: MapLM2
  | fillLeaf p F t :: :: FillL1 {{ tex [[F]]~\putarrow{[[p]]}~[[t]] }}
  | fillLeaf p d F :: :: FillL2 {{ tex [[d]]~\putarrow{[[p]]}~[[F]] }}
  | fillUnit p F :: :: FillU {{ tex [[F]]~\putarrow{[[p]]}~[[*]] }}
%  | fillFn p F { \ x : D . u } :: :: FillFn {{ tex [[F]]~\putarrow{[[p]]}~\lam{[[x]]}{[[D]]}{[[u]]} }}
  | fillUr p F :: :: FillE {{ tex [[F]]~\putarrow{[[p]]}~[[Ur]] }}
  | fillLeft p F                          ::   :: FillInl   {{ tex [[F]]~\putarrow{[[p]]}~[[Inl]] }}
  | fillRight p F                          ::   :: FillInr   {{ tex [[F]]~\putarrow{[[p]]}~[[Inr]] }}
  % | fillRoll p F R :: :: FillR {{ tex [[F]]~\putarrow{[[p]]}~\ottty{[[@]][[R]]} }}
  | fillPair p F                              ::   :: FillP    {{ tex [[F]]~\putarrow{[[p]]}~\ottcons{\langle,\rangle} }}
  | fillMpar p F :: :: FillM {{ tex [[F]]~\putarrow{[[p]]}~\ottcons{\langle\mparcomma\rangle} }}

% command :: 'com_' ::=
%   | S | t :: :: Command {{ tex [[S]]\,|\,[[t]] }}

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

% judg :: 'judg_' ::=
%   | type_affect in G :: :: CtxTypeAffIn
%   | % ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }}
%   | ctxdisjoint3 G1 G2 G3 :: :: CtxDisjoint3 {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G1]]) \cap [[names]]([[G3]]) = \emptyset~{\scriptstyle\land}~[[names]]([[G2]]) \cap [[names]]([[G3]]) = \emptyset }}
%   | l in L :: :: LabelSetIn
%   | l notin L :: :: LabelSetNotIn
%   | store_affect in S :: :: StoreAffIn
%   | D is D2 :: :: EqType
%   | t is u :: :: EqTerm
%   | G is D :: :: EqContext
%   | { l <| v' , lbar <| vbar } = deepCopy ( L , v ) :: :: DeepCopyTree {{ tex \{ [[l]] [[<|]] [[v']], [[lbar]] [[<|]] [[vbar]] \} = \mathsf{deepCopy}([[L]], \ottlb{\lfloor[[l]]\rfloor}, [[v]]) }}
%   | R =fix rec_type_def :: :: TyRec
%   | D is destFree :: :: TyDestFree {{ tex \text{$[[D]]$ is destination-free} }}
%   | C : Abar >> D :: :: TyCtor
%   | command !! command' :: :: SemOp

terminals :: 'terminals_' ::=
  | ->                                     ::   :: to       {{ tex \mapsto }}
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | := :: :: subwith {{ tex := }}
  | |- :: :: turnstile {{ tex \vdash }}
  | µ :: :: dunion {{ tex \sqcup }}
  | µ+ :: :: sdunion {{ tex \,\text{\makebox[0pt][l]{$\sqcup$}\raisebox{.3ex}{\hspace{.18ex}$\scriptscriptstyle+$} } }}
  | µ~ :: :: hdunion {{ tex \,\text{\makebox[0pt][l]{$\sqcup$}\raisebox{-.7ex}{\hspace{.18ex}\text{\textasciitilde}\!}~\,} }}
  | empty :: :: empty {{ tex \emptyset }}
  | != :: :: neq {{ tex \neq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | b :: :: linebreak {{ tex \mynewline }}
  | < :: :: langle {{ tex \ottcons{\langle} }}
  | > :: :: rangle {{ tex \ottcons{\rangle} }}
  | Inl :: :: v1 {{ tex \ottcons{Inl} }}
  | Inr :: :: v2 {{ tex \ottcons{Inr} }}
  | Ur :: :: ur {{ tex \ottcons{Ur} }}
  | C :: :: c {{ tex \ottcons{C} }}
  | !c :: :: expc {{ tex \expc{} }}
  | !w :: :: expw {{ tex \expw{} }}
  | mpar :: :: mpar {{ tex \mpar{} }}
  | Dest :: :: dest {{ tex \ottcons{Dest}\, }}
  | <| :: :: pointsto {{ tex \storearrow }}
  | '|' :: :: against {{ tex \,|\, }}
  | !! :: :: downto {{ tex \Downarrow }}
  | =fix :: :: fix {{ tex \overset{\mathsf{fix} }{=} }}
  | _!_ :: :: bottom {{ tex \ottty{\bot} }}
%  | o :: :: bullet {{ tex \bullet }}
  | includedin :: :: includedin {{ tex \subset }}
  | names :: :: names {{ tex \mathcal{N} }}
  | => :: :: implies {{ tex \implies }}
  | '@' :: :: at {{ tex \ottty{\textsf{@} } }}
  | and :: :: land {{ tex \land }}
  | ';' :: :: sep {{ tex ~{;}~ }}
  | * :: :: unit {{ tex \raisebox{.2ex}{\textbf{\footnotesize ()}\!\!~} }}
  | ¤ :: :: mparcomma {{ tex \mparcomma }}
  | --> :: :: rlocal {{ tex \longrightarrow }}
  | ~~> :: :: rglobal {{ tex \rightsquigarrow }}
  | with :: :: with {{ tex ~\textsf{with}~ }}
  | nu :: :: nu {{ tex \nu\! }}
  | \/ :: :: or {{ tex ~~\lor~~ }}

defns
Ctx :: '' ::=

defn
x != y :: :: CtxVarNe :: CtxVarNe_ by

defn
x in names ( G ) :: :: CtxVarIn :: CtxVarIn_ by

defn
x notin names ( G ) :: :: CtxVarNotIn :: CtxVarNotIn_ by

defn
x notin FV ( F ) :: :: CtxVarNotFvF :: CtxVarNotFvF_ by

defn
x notin FV ( E ) :: :: CtxVarNotFvE :: CtxVarNotFvE_ by

defn
x notin CV ( F ) :: :: CtxVarNotBvF :: CtxVarNotBvF_ by

defn
x notin CV ( E ) :: :: CtxVarNotBvE :: CtxVarNotBvE_ by

defn
E1 != E2 \/ V1 != V2 :: :: CtxENeq :: CtxENeq_ by

defn
x in V :: :: CtxNamesIn :: CtxNamesIn_ by

defn
x notin V :: :: CtxNamesNotIn :: CtxNamesNotIn_ by

defn
V disjoint CV ( F ) :: :: BvNamesDisjoint :: BvNamesDisjoint_ {{ tex [[V]] \cap \ottnt{CV}([[F]]) = \emptyset }} by

defn
V disjoint FV ( E ) :: :: FvNamesDisjoint :: FvNamesDisjoint_ {{ tex [[V]] \cap \ottnt{FV}([[E]]) = \emptyset }} by

defn
V1 disjoint V2 :: :: NamesDisjoint :: NamesDisjoint_ {{ tex [[V1]] \cap [[V2]] = \emptyset }} by

defn
type_affect in G :: :: CtxTypeAffIn :: CtxTypeAffIn_ by

defn
ctxdisjoint2 G1 G2 :: :: CtxDisjoint2 :: CtxDisjoint2_ {{ com $[[G1]]$~~and~~$[[G2]]$ are disjoint typing contexts with no clashing variable names or labels }} {{ tex [[names]]([[G1]]) \cap [[names]]([[G2]]) = \emptyset }} by

defn
p1 = p2 => G1 = G2 :: :: CtxMultiplicity :: CtxMultiplicity_ by

defn
p1 = p2 => ( G1 = G2 and G3 = G4 ) :: :: CtxMultiplicity2 :: CtxMultiplicity2_ by

defn
fresh x :: :: FreshVar :: FreshVar_ by

% defns
% Store :: '' ::=

% defn
% store_affect in S :: :: StoreAffIn :: StoreAffIn_ by

% defn
% x notin names ( S ) :: :: StoreVarNotIn :: StoreVarNotIn_ by

defns
Eq :: '' ::=

defn
A1 is A2 :: :: EqType :: EqType_ {{ tex [[A1]] = [[A2]] }} by
defn
A1 isnt A2 :: :: NeqType :: NeqType_ {{ tex [[A1]] \neq [[A2]] }} by
defn
t is u :: :: EqTerm :: EqTerm_ {{ tex [[t]] = [[u]] }} by
defn
G is D :: :: EqContext :: EqContext_ {{ tex [[G]] = [[D]] }} by

defns
Ty :: '' ::=

% defn
% R =fix rec_type_def :: :: TyRec :: TyRec_ by

defn
U ; G |- t : D :: :: TyTerm :: TyTerm_ by

% ------------------------ :: NoEff
% U ; empty |- o : _!_

--------------- :: U
U ; empty |- * : 1

U ; G µ~ { x : D1 } |- t : D2
------------------------------- :: Fn
U ; G |- \ x : D1 . t : D1 --o D2

U ; empty |- d : D
--------------------- :: E
U ; empty |- Ur d : !w D

U ; Gn µ unionall x in V { x : Zx, -x :^px Zx } |- t : D
--------------------- :: C
U ; Gn µ unionall x in V { x : Zx, -x :^px Zx } |- C t : !c D

U ; G |- d : D1
-------------------- :: Inl
U ; G |- Inl d : D1 + D2

U ; G |- d : D2
-------------------- :: Inr
U ; G |- Inr d : D1 + D2

% R =fix µX.DV
% empty ; G |- d : DV[X := R]
% --------------------------------- :: R
% U ; G |- @R d : R

U ; G1 |- d1 : D1
U ; G2 |- d2 : D2
----------------------- :: P
U ; G1 µ~ G2 |- <d1, d2> : D1 * D2

U ; G1 |- t1 : D1
U ; G2 |- t2 : D2
----------------------- :: M
U ; G1 µ G2 |- <t1 ¤ t2> : D1 mpar D2

U ; G µ unionall x in V { x : Zx, -x :^px Zx } |- t : D
---------------------------------- :: Nu
U ; G |- nu V . t : D

------------------------- :: D
U ; { - x :^p Z } |- |x| : |Z|^p

------------------------- :: Var
U ; { x : D } |- x : D

--------------- :: Var'
U µ { x : D } ; empty |- x : D

U ; G1 |- t : !c (D1 --o D2)
U ; G2 |- u : D1
--------------------------------- :: App
U ; G1 µ~ G2 |- t u : D2

U ; G1 |- t : !c 1
U ; G2 |- u : D
----------------------------------------- :: PatU
U ; G1 µ~ G2 |- case t of { * -> u } : D

U ; G1 |- t : !c (!w D)
U µ { x : !c D } ; G2 |- u : D
----------------------------------------- :: PatE
U ; G1 µ~ G2 |- case t of { Ur x -> u } : D

% x1 notin names(G1)
% x2 notin names(G2)
U ; G1 |- t : !c (D1 + D2)
U ; G2 µ~ { x1 : !c D1 } |- u1 : D
U ; G2 µ~ { x2 : !c D2 } |- u2 : D
------------------------------------------------------- :: PatS
U ; G1 µ~ G2 |- case t of { Inl x1 -> u1 , Inr x2 -> u2 } : D

% R =fix µ X. DV
% x notin names(G1)
% U ; G1 |- t : !c R
% U ; G2 µ~ { x : !c DV[X := R] } |- u : D
% ----------------------------- :: PatR
% U ; G1 µ~ G2 |- case t of { @R x -> u } : D

% x1 notin names(G1)
% x2 notin names(G2)
U ; G1 |- t : !c (D1 * D2)
U ; G2 µ~ { x1 : !c D1 , x2 : !c D2 } |- u : D
------------------------------------------------------- :: PatP
U ; G1 µ~ G2 |- case t of {<x1, x2> -> u} : D

U ; G |- t : !c D
--------------------- :: Ex
U ; G |- extract t : D

U ; G |- t : !c (D1 mpar D2)
---------------------------------- :: FlipM
U ; G |- flip t : !c (D2 mpar D1)

U ; G |- t : !c (D1 mpar !c (D2 mpar D3))
---------------------------------- :: ReassocM
U ; G |- reassoc t : !c (!c (D1 mpar D2) mpar D3)

U ; G |- t : !c (!c 1 mpar D)
------------------------------ :: RedLM
U ; G |- redL t : !c D

U ; G1 |- t : !c (D1 mpar D2)
U ; G2 |- u : !c (D1 --o D3)
--------------------------------- :: MapLM
U ; G1 µ~ G2 |- mapL t with u : !c (D3 mpar D2)

% U ; G µ { x : emptyH #- |Z|^l } |- t ; x bar : emptyH #- |Z bar| ^ p bar
% ------------------------------ :: Alloc
% U ; G |- alloc { x bar -> h bar } D x { t } : {h bar ^ p bar : D bar} #- D

% U ; G1 |- t : G1 µ { h ^p : D' } #- D
% U ; G2 |- u : G2 #- D'
% % ctxdisjoint2 G1 G2
% % ctxdisjoint2 G1 G2
% p = w => G2 = empty
% ------------------------ :: HComp
% U ; G1 µ G2 |- t with h := u : G1 µ G2 #- D

U ; G |- t : !c |1|^p
----------------------- :: FillU
U ; G |- fillUnit p t : !c 1

% x notin names(G1)
% U ; G1 |- t : !c |D1 --o D2|^p
% U ; G2 µ~ { x : D1 } |- u : D2
% p = w => G2 = empty
% ----------------------------- :: FillFn
% U ; G1 µ~ G2 |- fillFn p t { \ x : D1 . u } : !c 1

% TODO: linearity of D? should be ok because if Ur above, then u: N
% TODO: so dests are ruled out, and linear functions would capture something
U ; G1 |- t : !c |Z|^p
U ; G2 |- u : Z
p = w => G2 = empty
---------------------- :: FillL
U ; G1 µ~ G2 |- fillLeaf p t u : !c 1

U ; G |- t : !c |!w Z|^p
----------------------------------- :: FillE
U ; G |- fillUr p t : !c |Z|^w

U ; G |- t : !c |Z1 + Z2|^p
----------------------------------------- :: FillInl
U ; G |- fillLeft p t : !c |Z1|^p

U ; G |- t : !c |Z1 + Z2|^p
----------------------------------------- :: FillInr
U ; G |- fillRight p t : !c |Z2|^p

% R =fix µ X. ZV
% U ; G |- t : !c |R|^p
% ---------------------------------------------------------------- :: FillR
% U ; G |- fillRoll p t R : !c |ZV[X := R]|^p

U ; G |- t : !c |Z1 * Z2|^p
----------------------------------------------:: FillP
U ; G |- fillPair p t : !c (!c |Z1|^p mpar !c |Z2|^p)

U ; G |- t : !c |!c Z1 mpar !c Z2|^p
----------------------------------------------:: FillM
U ; G |- fillMpar p t : !c (!c |Z1|^p mpar !c |Z2|^p)

defns
Sem :: '' ::=

defn
t --> e | t' :: :: RLocal :: RLocal_ by

---------------------------- :: App
(C (\ x : D . t)) d --> o | t[x := d]

--------------------------------------------- :: PatU
case C * of { * -> t } --> o | t

----------------------------------------------------- :: PatE
case C (Ur d) of { Ur x -> t } --> o | t[x := C d]

----------------------------------------- :: PatInl
case C (Inl d) of {Inl x1 -> t1, Inr x2 -> t2} --> o | t1[x1 := C d]

----------------------------------------- :: PatInr
case C (Inr d) of {Inl x1 -> t1, Inr x2 -> t2} --> o | t2[x2 := C d]

% ------------------------------------------------------ :: PatR
% case C (@R d) of { @ R x -> t } --> o | t[x := C d]

-------------------------------------------- :: PatP
case C <d1, d2> of {<x1,x2> -> t} --> o | t[x1 := C d1, x2 := C d2]

-------------------------------------------- :: Ex
extract (C d) --> o | d

--------------------------------------------------- :: FlipM
flip (C <d1 ¤ d2>) --> o | C <d2 ¤ d1>

---------------------------------------- :: ReassocM
reassoc (C <d1 ¤ C <d2 ¤ d3>>) --> o | C <C <d1 ¤ d2> ¤ d3>

------------------------------ :: RedLM
redL (C <C * ¤ d>) --> o | C d

---------------------------- :: MapLM
mapL (C <d1 ¤ d2>) with (C (\x:D.t)) --> o | C < t[x := d1] ¤ d2>

---------------------------- :: FillU
fillUnit p (C |x|) --> x := * | C *

% -------------------------- :: FillFn
% fillFn p (C |x|) { \y:D. t } --> x := \y:D.t | C *

---------------------------- :: FillL
fillLeaf p (C |x|) d --> x := d | C *

fresh x'
--------------------------------------------------- :: FillE
fillUr p (C |x|) --> x := Ur x' with nu {x'} | C |x'|

fresh x'
------------------------------------------------------------ :: FillInl
fillLeft p (C |x|) --> x := Inl x' with nu {x'} | C |x'|

fresh x'
------------------------------------------------------------ :: FillInr
fillRight p (C |x|) --> x := Inr x' with nu {x'} | C |x'|

% fresh x'
% ------------------------------------------------------------ :: FillR
% fillRoll p (C |x|) R --> x := @R x' with nu {x'} | C |x'|

fresh x1
fresh x2
--------------------------------------------------------------- :: FillP
fillPair p (C |x|) --> x := <x1, x2> with nu {x1, x2} | C <C |x1| ¤ C |x2|>

fresh x1
fresh x2
--------------------------------------------------------------- :: FillM
fillMpar p (C |x|) --> x := <C x1 ¤ C x2> with nu {x1, x2} | C <C |x1| ¤ C |x2|>

% V1 disjoint V2
% ----------------------------- :: MergeNu
% nu V1. nu V2. t --> o | nu V1 µ V2. t

% -------------------- :: EmptyNuC
% t --> o | nu empty. t

% -------------------- :: EmptyNuD
% nu empty. t --> o | t

% y notin V
% t --> x := d with nu V | t'
% ---------------------------------- :: EffUp
% nu {y}. E[t] --> x := d with nu V | nu {y}. E[t']

% x notin FV(F)
% F[t] --> e | t'
% ---------------------- :: NuUp1
% F[nu {x}. t] --> e | nu {x}. t'

% x notin CV(F)
% ----------------------------- :: NuUp2
% F[nu {x}. t] --> o | nu {x}. F[t]

defn
t ~~> t' :: :: RGlobal :: RGlobal_ by

t --> o | t'
---------------------- :: NoEff
F[t] ~~> F[t']

V2 disjoint FV(E)
V1 disjoint V2
E != [] \/ V1 != empty
---------------------- :: NuUp
nu* V1. E[nu V2. t] ~~> nu V1 µ V2. E[t]

V2 disjoint FV(E)
V1 disjoint V2
t --> x := d with nu V2 | t'
------------------------------ :: Eff
nu V1µ{x}. E[t] ~~> nu V1µV2. (E[t'])[x := d]

% ------------------- :: Test1
% mapL (nu {x1, x2}. C < C |x1| ¤ C < C |x2| ¤ <x1, x2> > >) with C (\x1:D. fillUnit l x1) ~~> nu {x2}. C < C * ¤ C < C |x2| ¤ <*, x2> > >

% -------------------- :: Test2
% nu x. < nu x. C <C |x| ¤ x> ¤ mapL ( C <C |x| ¤ x>) with C (\x:D.x) > ~~> nu x. < nu x. C <C |x| ¤ x> ¤ C <C |x| ¤ x>>

parsing
t_PatU <= t_App
t_PatU <= t_FillL
dty_Sum <= dty_Comp
dty_Prod <= dty_Comp
dty_Mpar <= dty_Comp
% dtywv_Comp <= dty_Sub
t_Sub <= t_Paren
d_Nu <= t_Sub
