% minimal + latex + comments

embed
{{ tex-preamble
%\usepackage{stmaryrd}
\geometry{a4paper,left=0.75cm,right=0.75cm,top=1.25cm,bottom=2cm}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[dvipsnames]{xcolor}
\usepackage{abraces}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{bbold}
\DeclareSymbolFont{bbsymbol}{U}{bbold}{m}{n}
\DeclareMathSymbol{\bbcomma}{\mathbin}{bbsymbol}{"2C}
\DeclareMathAlphabet{\mathsfbf}{T1}{\sfdefault}{sbc}{n}
\definecolor{ntcolor}{RGB}{75, 75, 75}
\definecolor{kwcolor}{RGB}{0, 0, 0}
\definecolor{effcolor}{HTML}{F8980F} % yellow-orange, underlined
\definecolor{tycolor}{HTML}{176FC1} % blue, bold
\definecolor{spcolor}{HTML}{1C5737} % dark green, not official one
\definecolor{modecolor}{HTML}{00AAA0} % green-blue, tt
\definecolor{mvcolor}{HTML}{F35EB7} % pink, sf
\definecolor{holecolor}{HTML}{F14B2D} % red, itshape
\newlength{\deltaraise}
\setlength{\deltaraise}{1.5pt}
\newcommand{\nicefrac}[2]{\mathrel{\raisebox{\deltaraise}{$ #1 $} }\!\!/\!\!\mathrel{\raisebox{-\deltaraise}{$ #2 $} } }
\newcommand{\ottty}[1]{\textcolor{tycolor}{\mathsfbf{#1} } }
\renewcommand{\ottnt}[1]{\textcolor{ntcolor}{\mathsf{#1} } }
\newcommand{\ottextval}[1]{\textcolor{ntcolor}{\mathsf{\replacewv{\overline{#1} } } } }
\newcommand{\ottextterm}[1]{\textcolor{ntcolor}{\mathsf{\replacejt{\overline{#1} } } } }
\renewcommand{\ottmv}[1]{\textcolor{mvcolor}{\mathsf{#1} } }
\renewcommand{\ottkw}[1]{\textcolor{kwcolor}{\mathsfbf{#1} } }
\newcommand{\ottdefault}[1]{\textcolor{black}{#1} }
\newcommand{\ottcons}[1]{\textcolor{black}{\mathsf{#1} } }
\newcommand{\ottsp}[1]{\textcolor{spcolor}{\mathit{#1} } }
\newcommand{\otteff}[1]{\textcolor{effcolor}{\mathit{\replacelell{#1} } } }
\newcommand{\otthol}[1]{\textcolor{holecolor}{\mathit{#1} } }
\newcommand{\ottmod}[1]{\textcolor{modecolor}{\mathtt{#1} } }
\newcommand{\replacelell}[1]{%
  \begingroup%
  \mathcode`l=\ell%
  #1%
  \endgroup%
}
\newcommand{\replacejt}[1]{%
  \begingroup%
  \mathcode`j=\mathcode`t
  #1%
  \endgroup%
}
\newcommand{\replacewv}[1]{%
  \begingroup%
  \mathcode`w=\mathcode`v
  #1%
  \endgroup%
}
\newcommand{\defeq}{\overset{\mathsf{def} }{=} }
\def\mynewline{\ottsp{\backslash\!n} }
\def\myspace#1{\myrepeat{#1}{\ottsp{\langle destent \rangle} } }
\makeatletter
\newcommand{\shorteq}{%
  \settowidth{\@tempdima}{--}% Width of hyphen
  \resizebox{\@tempdima}{\height}{=}%
}
\newcommand{\coloneq}{\mathrel{%
  \!\raisebox{0.09ex}{$\mathop{:}$\hspace{-0.1ex}%
  }%
  \shorteq\hspace{-0.2ex}%
}%
}
\newcount\my@repeat@count
\newcommand{\myrepeat}[2]{%
  \begingroup
  \my@repeat@count=\z@
  \@whilenum\my@repeat@count<#1\do{#2\advance\my@repeat@count\@ne}%
  \endgroup
}
\newcommand{\ostar}{\mathbin{\mathpalette\make@circled{\!\!\star}\!\! } }
\newcommand{\make@circled}[2]{%
  \ooalign{$\m@th#1\smallbigcirc{#1}$\cr\hidewidth$\m@th#1#2$\hidewidth\cr}%
}
\newcommand{\smallbigcirc}[1]{%
  \vcenter{\hbox{\scalebox{0.7}{$\m@th#1\bigcirc$}
}
}%
}
\makeatother
\def\togglespaces{
\def\mynewline{\\}
\def\myspace##1{\myrepeat{##1}{\hspace{0.7cm} } }
}
\let\storearrow\triangleleft
\newcommand{\consarrow}{\overset{c}{\rightharpoonup} }
% deactivate underbrace
 \renewcommand{\aunderbrace}[2][]{#2}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}
\newtheorem{defi}{Definition}
\newcommand{\TyTerm}[1]{\textsc{TyTerm\_#1}%
}
\newcommand{\TyCommand}[1]{\textsc{TyCommand\_#1}%
}
\newcommand{\TyStore}[1]{\textsc{TyStore\_#1}%
}
\newcommand{\SemMut}[1]{\textsc{SemMut\_#1}%
}
\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\remark}[1]{~\textnormal{\small\itshape #1} }
\newcommand{\holearrowgen}[1]{\ottho{\text{#1}\!\!\!\rightharpoonup} } % 
\def\restriction#1#2{\mathchoice
              {\setbox1\hbox{${\displaystyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\textstyle #1}_{\scriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} }
              {\setbox1\hbox{${\scriptscriptstyle #1}_{\scriptscriptstyle #2}$}
              \restrictionaux{#1}{#2} } }
\def\restrictionaux#1#2{ {#1\,\smash{\vrule height .8\ht1 depth .85\dp1} }_{\,#2} }
\usepackage[safe]{tipa}
\newcommand{\mpar}{\ottty{\text{\large\textramshorns} } }
\newcommand{\mparcomma}{ {\scriptstyle\odot} }
\newcommand{\expc}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{-.1ex}{\hspace{-0.4ex}\scriptsize c} } }\hspace{-0.7ex} }
\newcommand{\expw}{\ottty{\,\text{\makebox[0pt][l]{\raisebox{.4ex}{\scriptsize !} }\raisebox{0.05ex}{\hspace{-0.6ex}${\scriptscriptstyle\omega}$} } }\hspace{-0.7ex} }
\newcommand{\putarrow}[1]{\!\overset{#1}{\triangleleft}\!}
\newcommand{\lam}[3]{\ottcons{\lambda}\,#1\!:\!#2\,\textbf{.}\,#3}
\newcommand{\lamnt}[2]{\ottcons{\lambda}#1\,\textbf{.}\,#2}
\newcommand{\Lam}[2]{\ottcons{\Lambda}\,#1\,\textbf{.}\,#2}
\newcommand{\nuabs}[1]{\nu#1\textbf{.}\,}
\newlength{\mylen}
\setbox1=\hbox{$\bullet$}\setbox2=\hbox{$\scriptscriptstyle\bullet$}
\setlength{\mylen}{\dimexpr0.5\ht1-0.5\ht2}
\def\mybullet{\raisebox{\mylen}{$\scriptscriptstyle\bullet$} }
}}

%TODO: replace lambda see https://tex.stackexchange.com/questions/200910/replace-a-few-math-symbols-in-the-newtxmath-font

metavar termvar, x, y, d ::= {{ com Term-level variable }}
  {{ tex \ottmv{[[termvar]]} }}

% metavar idxvar, i ::=
%   {{ tex \ottmv{[[idxvar]]} }}

grammar

% label, l :: 'Lbl_' ::= {{ tex \otteff{[[label]]} }} {{ com Label }}

hole, h :: 'Hole_' ::= {{ tex \otthol{[[hole]]} }} {{ com Hole }}

term_value, v :: 'TermVal_' ::= {{ com Term value }}
  | < v1 Â¤ w2 > H :: :: Ampar {{ com Ampar }} {{ tex \ottcons{\langle}[[v1]]\,\ottcons{\bbcomma}~[[w2]]\ottcons{\rangle}_{[[H]]} }}
  | @ h :: :: Dest {{ tex \otthol{@}[[h]] }} {{ com Destination }}
  | () :: :: Unit {{ com Unit }}
  | Inl v :: :: Inl {{ com Left variant for sum }}
  | Inr v :: :: Inr {{ com Right variant for sum }}
  | ( v1 , v2 ) :: :: Prod {{ tex \ottcons{(}[[v1]]\,\ottcons{,}~[[v2]]\ottcons{)} }} {{ com Product }}
  | \ x -> t :: :: Lambda {{ tex \lamnt{[[x]]}{[[t]]} }} {{ com Linear function }}
  | ( v ) :: S :: Paren

extended_value, w :: 'ExtVal_' ::= {{ com Store value }} {{ tex \ottextval{[[extended_value]]} }}
  | v :: :: TermVal {{ com Term value }}
  | h :: :: Hole {{ com Hole }}
  | Inl w :: :: Inl {{ com Left variant with val or hole }}
  | Inr w :: :: Inr {{ com Right variant with val or hole }}
  | ( w1 , w2 ) :: :: Prod {{ tex \ottcons{(}[[w1]]\,\ottcons{,}~[[w2]]\ottcons{)} }} {{ com Product with val or hole }}
  | ( w ) :: S :: Paren
  | w [ e ] :: M :: Effect

term, t, u :: 'Term_' ::=                                               {{ com Term }}
  | v :: :: TermVal {{ com Term value }}
  | x :: :: Var {{ com Variable }}
  | t u                                    ::   :: App      {{ com Application }}
  | t ; u                   ::   :: PatUnit {{ com Pattern-match on unit }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,[[()]]\![[->]]\,[[u]] }}
  | t & \case { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatSum     {{ com Pattern-match on sum }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\{\,\ottcons{Inl}\,[[x1]][[->]][[u1]]\,,~\ottcons{Inr}\,[[x2]][[->]][[u2]]\,\} }}
  | t & \case ( x1 , x2 ) -> u            ::   :: PatProd     {{ com Pattern-match on product }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\ottcons{(}[[x1]]\,\ottcons{,}~[[x2]]\ottcons{)}\![[->]]\,[[u]] }}
  | t <&> \ x -> u :: :: MapAmpar {{ com Map over the left side of the ampar }} {{ tex [[t]]~\succ\!\!\ottkw{mapL}\,[[x]]\![[->]]\,[[u]] }}

  % | toGlobal t :: :: ToGlobal {{ tex \ottkw{to}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion to ${\ottmod{\scriptstyle G} }$ }}
  % | fromGlobal t :: :: FromGlobal {{ tex \ottkw{from}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion from ${\ottmod{\scriptstyle G} }$ }}
  | toAmpar t :: :: ToAmpar {{ tex \ottkw{to}_{[[><|]]}\,[[t]] }} {{ com Wrap $[[t]]$ into a trivial ampar }}
  | fromAmpar t :: :: FromAmpar {{ tex \ottkw{from}_{[[><|]]}\,[[t]] }} {{ com Extract value from trivial ampar }}

  | alloc A :: :: Alloc {{ com Return a fresh "identity" ampar object }} {{ tex \ottkw{alloc}_{ [[A]]} }}
  | t <| () :: :: FillUnit {{ com Fill destination with unit }}
  | t <| Inl                          ::   :: FillInl   {{ com Fill destination with left variant }}
  | t <| Inr                          ::   :: FillInr   {{ com Fill destination with right variant }}
  | t <| (,)                              ::   :: FillProd    {{ com Fill destination with product constructor }}
  | t <|. u :: :: FillComp {{ com Fill destination with root of ampar $[[u]]$ }}

  | ( t )                                   :: S :: Paren
  | t [ sub ]                             :: M :: Sub
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpacing2
  % | t b spe :: S :: BreakSpacing3

extended_term, j :: 'ExtTerm_' ::= {{ com Extended term }} {{ tex \ottextterm{[[extended_term]]} }}
  | t :: :: Term
  | w :: :: ExtVal

sub :: 'Sub_' ::= {{ com Variable substitution }}
  | x := v :: :: Single
  | sub1 , sub2 :: :: Multiple
  | ( sub ) :: S :: Paren {{ tex [[sub]] }}

effect, e :: 'Eff_' ::= {{ com Effect }} {{ tex \otteff{[[effect]]} }}
  | o :: :: NoEff {{ tex \otteff{\varepsilon} }} {{ com No effect }}
  | h := w :: :: Single {{ tex [[h]]~\otteff{[[:=]]}~[[w]] }}
  | e1 . e2 :: :: Multiple {{ tex [[e1]]~\otteff{\cdot}~[[e2]] }}
  | ( e ) :: S :: Paren {{ tex [[e]] }}

type, A, B :: 'Ty_' ::= {{ com Type }} {{ tex \ottty{[[type]]} }}
  | 1 :: :: Unit {{ tex \ottty{1} }} {{ com Unit }}
  | A1 + A2 :: :: Sum {{ tex [[A1]]\ottty{\oplus}[[A2]] }} {{ com Sum }}
  | A1 * A2 :: :: Prod {{ tex [[A1]]\ottty{\otimes}[[A2]] }} {{ com Product }}
  | A1 ><| A2 :: :: Ampar {{ tex [[A1]]\,[[><|]]\,[[A2]] }} {{ com Ampar type (consuming $[[A1]]$ yields $[[A2]]$) }}
  | m1 A1 --o A2 :: :: Lambda {{ tex [[A1]]\,_{[[m1]]}\![[--o]]\,[[A2]] }} {{ com Linear function }}
  | Dest A :: :: Dest {{ tex [[A]]\ottty{^D} }} {{ com Destination }}
  | ( A ) :: S :: Paren {{ tex \ottty{(}[[A]]\ottty{)} }}

mode, m :: 'Mode_' ::= {{ tex \ottmod{[[mode]]} }} {{ com Mode }}
  % | _ :: :: Placeholder {{ tex \ottmod{\_} }} {{ com Placeholder for any mode }}
  | _L :: :: Local {{ tex \ottmod{\scriptstyle L} }} {{ com Local }}
  | _F :: :: Foreign {{ tex \ottmod{\scriptstyle F} }} {{ com Foreign }}
  | _G :: :: Global {{ tex \ottmod{\scriptstyle G} }} {{ com Global }}
  | max_mode ( G ) :: :: MaxCtx {{ tex \ottmod{max\_mode(}[[G]]\ottmod{)} }}
  | if mode_cond then m3 else m4 :: :: If

mode_cond :: 'ModeCond' ::= {{ com Mode statement }} {{ tex \ottmod{[[mode_cond]]} }}
  | m1 = m2 :: :: Eq
  % | m1 <= m2 :: :: Leq
  | m in upper_modes ( G ) :: :: Supr
  | exists m in upper_modes ( G ) :: :: ExistsSupr

typing_context, D {{ tex \Delta }} :: 'TyCtx_' ::= {{ com Typing context }}
  | G    ::   :: OnlyPos
  | H ::    :: OnlyNeg
  | G u H :: :: SepPosNeg {{ tex [[G]]\mathrel{\raisebox{1pt}{\scalebox{0.5}{$\sqcup$}\!\! } }[[H]] }}

pos_context, G {{ tex \Gamma }} :: 'PosCtx_' ::= {{ com Positive typing context }}
  | {}    ::   :: Empty
  | { pos_assigns } :: :: Assigns
  | G1 Âµ G2    ::    :: Disjoint
  | - H :: :: Minus
  | G [ m1 -> m2 ] :: :: OverwriteMode
  | ( G ) :: S :: Paren

pos_assign, pa :: 'PosAssign_' ::= {{ com Positive type assignment }}
%  | x : A :: :: LocalVar
  | x : m A :: :: Var {{ tex [[x]]:_{[[m]]}[[A]] }}
  | + h : A :: :: Dest {{ com Destination }} {{ tex \otthol{+}[[h]]:[[A]] }}
pos_assigns :: 'PosAssigns_' ::= {{ com Positive type assignments }}
  | pa :: :: Single
  | pa , pos_assigns :: :: Multiple

neg_assign, na :: 'NegAssign_' ::= {{ com Negative type assignment }}
  | - h : A :: :: Hole {{ com Hole }} {{ tex \otthol{-}[[h]]:[[A]] }}
neg_assigns :: 'NegAssigns_' ::= {{ com Negative type assignments }}
  | na :: :: Single
  | na , neg_assigns :: :: Multiple

neg_context, H :: 'NegCtx_' ::= {{ com Negative typing context }}
  | {}    ::   :: Empty
  | { neg_assigns } :: :: Assigns
  | H1 Âµ H2    ::    :: Disjoint
  | - G :: :: Minus
  | ( H ) :: S :: Paren

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=
% === Type syntax ===
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | ><| :: :: rtimes {{ tex \ottty{\rtimes} }}

% === Term syntax ===
  | ->                                     ::   :: mapsto       {{ tex \mapsto }}
  | () :: :: unit {{ tex \ottcons{()} }}
  | Inl :: :: inl {{ tex \ottcons{Inl} }}
  | Inr :: :: inr {{ tex \ottcons{Inr} }}
  | (,) :: :: prod {{ tex \ottcons{({,})} }}
  | <| :: :: fill {{ tex \triangleleft }}
  | <|. :: :: fillcomp {{ tex \triangleleft\!\mybullet\, }}
  | := :: :: assign {{ tex \coloneq }}

% === Contexts ===
  | Âµ :: :: dunion {{ tex \sqcup }}
  | Âµ+ :: :: sdunion {{ tex \,\text{\makebox[0pt][l]{$\sqcup$}\raisebox{.40ex}{\hspace{.15ex}$\scriptscriptstyle\pm$} } }}
  | '{}' :: :: empty {{ tex \{\} }}

% === Judgements ===
  | exists :: :: exists {{ tex \exists }}
  | != :: :: neq {{ tex \neq }}
  | <= :: :: leq {{ tex \leq }}
  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
  | includedin :: :: includedin {{ tex \subset }}
  | names :: :: names {{ tex \mathcal{N} }}

% === Typing ===
  | |- :: :: turnstile {{ tex \vdash }}

% === Semantics ===
  | '|' :: :: cmd {{ tex ~|~ }}
  | !! :: :: downto {{ tex \,\Downarrow\, }}

defns
Ctx :: '' ::=

defn
x in names ( D ) :: :: CtxVarIn :: CtxVarIn_ by

% defn
% l in names ( G ) :: :: CtxLblIn :: CtxLblIn_ by

defn
h in names ( D ) :: :: CtxHoleIn :: CtxHoleIn_ by

defn
x notin names ( D ) :: :: CtxVarNotIn :: CtxVarNotIn_ by

% defn
% l notin names ( G ) :: :: CtxLblNotIn :: CtxLblNotIn_ by

defn
h notin names ( D ) :: :: CtxHoleNotIn :: CtxHoleNotIn_ by

defn
fresh x :: :: FreshVar :: FreshVar_ by

% defn
% fresh l :: :: FreshLbl :: FreshLbl_ by

defn
fresh h :: :: FreshHole :: FreshHole_ by

defn
pos_assign in G :: :: PosCtxAssignIn :: PosCtxAssignIn_ by

defn
neg_assign in H :: :: NegCtxAssignIn :: NegCtxAssignIn_ by

defn
onlyPositive ( D ) :: :: CtxPos :: CtxPos_ by

defn
onlyNegative ( D ) :: :: CtxNeg :: CtxNeg_ by

defn
mode_cond :: :: ModeCond :: ModeCond_ by

defns
Eq :: '' ::=

defn
A1 = A2 :: :: EqType :: EqType_ by
defn
A1 != A2 :: :: NeqType :: NeqType_ by
defn
t = u :: :: EqTerm :: EqTerm_ by
defn
t != u :: :: NeqTerm :: NeqTerm_ by
defn
D1 = D2 :: :: EqCtx :: EqCtx_ by
defn
D1 disjoint D2 :: :: DisjointCtx :: DisjointCtx_ {{ tex [[names]]([[D1]]) \cap [[names]]([[D2]]) = \emptyset }} by

defns
Eff :: '' ::=
defn
e2 , w2 H2 = apply ( e1 , w1 H1 ) :: :: EffApply :: EffApply_ {{ tex [[e2]],~[[w2]]\,_{[[H2]]} = \ottkw{apply}([[e1]],~[[w1]]\,_{[[H1]]}) }} {{ com Apply effect }} by

defns
Ty :: '' ::=

defn
D |- j : A :: :: TyTermExt :: TyTermExt_ by

--------------------- :: Hole
{} u { - h : A } |- h : A

---------------- :: Dest
{ + h : A } u {} |- @h : Dest A

--------------------- :: Unit
{} u {} |- () : 1

G u H |- w : A1
--------------------- :: Inl
G u H |- Inl w : A1 + A2

G u H |- w : A2
--------------------- :: Inr
G u H |- Inr w : A1 + A2

G1 u H1 |- w1 : A1
G2 u H2 |- w2 : A2
G1 u H1 disjoint G2 u H2
------------------------- :: Prod
G1 Âµ G2 u H1 Âµ H2 |- (w1, w2) : A1 * A2

G1 Âµ -H u {} |- v1 : A1
G2 u H |- w2 : A2
G1 disjoint G2
---------------- :: Ampar
G1 Âµ G2 u {} |- <v1 Â¤ w2> H : A1 ><| A2

G Âµ { x : m1 A1 } u {} |- t : A2
----------------- :: Lambda
G u {} |- \x -> t : m1 A1 --o A2

G1 u {} |- t : m1 A1 --o A2
G2 u {} |- u : A1
m1 in upper_modes(G2)
G1 disjoint G2
----------------- :: App
G1 Âµ G2 u {} |- t u : A2

G1 u {} |- t : 1
G2 u {} |- u : B
G1 disjoint G2
----------------- :: PatUnit
G1 Âµ G2 u {} |- t ; u : B

G1 u {} |- t : A1 + A2
exists m in upper_modes (G1)
G2 Âµ { x1 : m A1 } u {} |- u1 : B
G2 Âµ { x2 : m A2 } u {} |- u2 : B
G1 disjoint G2
----------------- :: PatSum
G1 Âµ G2 u {} |- t & \case { Inl x1 -> u1 , Inr x2 -> u2 } : B

G1 u {} |- t : A1 * A2
exists m in upper_modes (G1)
G2 Âµ { x1 : m A1, x2 : m A2 } u {} |- u : B
G1 disjoint G2
----------------- :: PatProd
G1 Âµ G2 u {} |- t & \case ( x1 , x2 ) -> u : B

G1 u {} |- t : A1 ><| A2
% ensures that we cannot capture dests of different scopes (G2)
exists m' in upper_modes(G1 Âµ G2)
m = if _F in upper_modes(G1) then _F else _L
G2[ _L -> _F ] Âµ { x : m A1 } u {} |- u : B
G1 disjoint G2
-------------------------------- :: MapAmpar
G1 Âµ G2 u {} |- t <&> \ x -> u : B ><| A2

-------------------------------- :: Alloc
{} u {} |- alloc A : Dest A ><| A

G u {} |- t : A
------------------------------- :: ToAmpar
G u {} |- toAmpar t : 1 ><| A

G u {} |- t : 1 ><| A
------------------------------- :: FromAmpar
G u {} |- fromAmpar t : A

G u {} |- t : Dest 1
------------------------------ :: FillUnit
G u {} |- t <| () : 1

G u {} |- t : Dest (A1 + A2)
------------------------------ :: FillInl
G u {} |- t <| Inl : Dest A1

G u {} |- t : Dest (A1 + A2)
------------------------------ :: FillInr
G u {} |- t <| Inr : Dest A2

G u {} |- t : Dest (A1 * A2)
------------------------------ :: FillProd
G u {} |- t <| (,) : Dest A1 * Dest A2

G1 u {} |- t : Dest A2
G2 u {} |- u : A1 ><| A2
G1 disjoint G2
_L in upper_modes(G1)
_F in upper_modes(G2)
----------------------------- :: FillCompL
G1 Âµ G2 u {} |- t <|. u : A1

G1 u {} |- t : Dest A2
G2 u {} |- u : A1 ><| A2
G1 disjoint G2
_F in upper_modes(G1)
_G in upper_modes(G2)
----------------------------- :: FillCompF
G1 Âµ G2 u {} |- t <|. u : A1

defns
Sem :: '' ::=

defn
t !! t' | e :: :: BigStep :: BigStep_ by

------------------ :: Val
v !! v | o

t1 !! \x -> u | e1
t2 !! v2 | e2
u[x := v2] !! v3 | e3
------------------ :: App
t1 t2 !! v3 | (e1 . e2) . e3

t1 !! () | e1
t2 !! v2 | e2
----------------------- :: PatUnit
t1 ; t2 !! v2 | e1 . e2

t !! Inl v1 | e1
u1[x1 := v1] !! v2 | e2
----------------------- :: PatInl
t & \case { Inl x1 -> u1, Inr x2 -> u2 } !! v2 | e1 . e2

t !! Inr v1 | e1
u2[x2 := v1] !! v2 | e2
----------------------- :: PatInr
t & \case { Inl x1 -> u1, Inr x2 -> u2 } !! v2 | e1 . e2

t !! (v1,v2) | e1
u[x1 := v1, x2 := v2] !! v2 | e2
----------------------- :: PatProd
t & \case (x1,x2) -> u !! v2 | e1 . e2

% Can e1 have effect on the content of the ampar? I don't think so, but maybe
t !! < v1 Â¤ w2 > H | e1
u[x := v1] !! v3 | e2
e3, w4 H' = apply(e1 . e2, w2 H)
---------------------------------- :: MapAmpar
t <&> \ x -> u !! <v3 Â¤ w4> H' | e3

fresh h
-------------------------- :: Alloc
alloc A !! < @h Â¤ h > { -h : A } | o

t !! v | e
----------------------------------------- :: ToAmpar
toAmpar t !! < () Â¤ v > {} | e

t !! < () Â¤ v > {} | e
-------------------------------------- :: FromAmpar
fromAmpar t !! v | e

t !! @h | e
------------------------------------- :: FillUnit
t <| () !! () | e . h := ()

t !! @h | e
fresh h'
--------------------------------------- :: FillInl
t <| Inl !! @h' | e . h := Inl h'

t !! @h | e
--------------------------------------- :: FillInr
t <| Inr !! @h' | e . h := Inr h'

t !! @h | e
fresh h1
fresh h2
--------------------------------------- :: FillProd
t <| (,) !! (@h1, @h2) | e . h := (h1,h2)

t !! @h | e1
u !! <v1 Â¤ w2> H | e2
---------------------------------------- :: FillComp
t <|. u !! v1 | (e1 . e2) . h := w2

parsing
Ty_Prod <= Ty_Dest
Ty_Sum <= Ty_Dest
Ty_Ampar <= Ty_Dest
PosCtx_Disjoint <= PosCtx_Minus
NegCtx_Disjoint <= NegCtx_Minus

