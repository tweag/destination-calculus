defns
Ty :: '' ::=

defn
G ⫦ v : T :: :: TyR_val :: TyR_val_ {{ com Typing of values (raw) }} by

% We must track linearity precisely, but age for received value is arbitrary
--------------------- :: H
{ - h : T ¹a } ⫦ -h : T

{{ ctx_Compatible [[G]] [[+h : ¹ν ⌊T⌋n]] }}
---------------- :: D
G ⫦ +h : ⌊T⌋n

--------------------- :: U
{} ⫦ () :𝟏


% {{ mode_IsValid [[m]] }} : Probably we can relax that? Application will be impossible for such a function (as it would make the resulting context invalid), but it doesn't pose a problem per se
% {{ ctx_Disjoint [[G]] [[{ x : m T1 }]] }} : Redundant because ctx_DestOnly G => ctx_Disjoint G { x : m T1 }
% other rules don't need ctx_NoVar G as they cannot syntactically accept vars
{{ ctx_DestOnly [[G]] }} % Only says that we cannot have holes inside, as well as t cannot capture extra variables
G ⨄ { x : m T1 } ⊢ t : T2 [[:TYt]]
----------------- :: F
G ⫦ λᵛ x ⟼ t : T1 m → T2

G ⫦ v : T1 [[:TYRv]]
--------------------- :: L
G ⫦ Inl v : T1 ⨁ T2

G ⫦ v : T2 [[:TYRv]]
--------------------- :: R
G ⫦ Inr v : T1 ⨁ T2

G1 ⫦ v1 : T1 [[:TYRv1]]
G2 ⫦ v2 : T2 [[:TYRv2]]
------------------------- :: P
G1 ⨄ G2 ⫦ (v1, v2) : T1 ⨂ T2

% we should augment age of holes which are below an exponential
G ⫦ v : T [[:TYRv]]
% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
--------------------- :: E
m·G ⫦ ᴇ m v : ! m T

% We perform controls here on Ampar, and not on the other rules, because outside of the ampar, the hole/dests that are compensated will no longer be visible.
% ctx_DestOnly [[G2 ⨄ G3]] ensures that v2 is just made of dests, and with ctx_DestOnly [[G1]] in G1 ⨄ (-G3) ⫦ v1 : T1 we can conclude that v2 dests compensates at least all the holes from this ampar. This forbids <<(-h0, -h), +h>, +h0> which isn't constructible through alloc anyway.
% These more complex rules are made to allow this program, in which v2 is made of dests which are not exclusively from this ampar:
% alloc >map x0 |-> 
%     alloc >map x1 |->
%         let x2 = fromA (alloc >map xt |-> xt <| E ↑ <|. (toA x0)) in
%         fromA ( alloc >map xt |-> xt <| (,) >case (xt1, xt2) |->
%                     xt1 <|. (toA x1) ; xt2 <|. (toA x2)
%               )
% We would have x2 = E ↑ +h0, and res = < -h0, < -h1 , (+h1, E ↑ +h0) > >
% If such a program typechecks, then we need the extra context G2 to v2 for dests coming from outside of this ampar (with ctx_DestOnly G2)
% We need to make sure that an ampar will bind as many holes as possible (i.e that holes and matching dests cannot escape respectively in G1 and G2), that's why we have ctx_Disjoint [[G1]] [[G2]]
{{ ctx_Disjoint [[G1]] [[G2]] }}
{{ ctx_DestOnly [[G2 ⨄ G3]] }}
{{ ctx_DestOnly [[G1]] }}
G1 ⨄ (-G3) ⫦ v1 : T1 [[:TYRv1]]
G2 ⨄ G3 ⫦ v2 : T2 [[:TYRv2]]
---------------- :: A
G1 ⨄ G2 ⫦ hnames(-G3) ⟨v1 ❟ v2⟩ : T1 ⧔ T2

defn
G ⊢ j : T :: :: Ty_term :: Ty_term_ {{ com Typing of terms }} by

{{ ctx_NoHole [[G]] }} % Functionnally equivalent as ctx_DestOnly G as values cannot syntactically contains free variables
G ⫦ v : T
-------------------- :: Val
G ⊢ v : T

{{ ctx_Compatible [[G]] [[x : ¹ν T]] }}
-------------------- :: Var
G ⊢ x : T

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
G1 ⊢ t : T1 [[:TYt]]
G2 ⊢ u : T1 m → T2 [[:TYu]]
----------------- :: App
m·G1 ⨄ G2 ⊢ t ≻ u : T2

G1 ⊢ t :𝟏 [[:TYt]]
G2 ⊢ u : U [[:TYu]]
----------------- :: PatU
G1 ⨄ G2 ⊢ t ; u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G2]] [[{ x2 : m T2 }]] }}
G1 ⊢ t : T1 ⨁ T2 [[:TYt]]
G2 ⨄ { x1 : m T1 } ⊢ u1 : U [[:TYu1]]
G2 ⨄ { x2 : m T2 } ⊢ u2 : U [[:TYu2]]
----------------- :: PatS
m·G1 ⨄ G2 ⊢ t ≻case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }}
G1 ⊢ t : T1 ⨂ T2 [[:TYt]]
G2 ⨄ { x1 : m T1, x2 : m T2 } ⊢ u : U [[:TYu]]
----------------- :: PatP
m·G1 ⨄ G2 ⊢ t ≻case m (x1 , x2) ⟼ u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x : m·n T }]] }}
G1 ⊢ t : !n T [[:TYt]]
G2 ⨄ { x : m·n T } ⊢ u : U [[:TYu]]
----------------- :: PatE
m·G1 ⨄ G2 ⊢ t ≻case m ᴇ n x ⟼ u : U

{{ ctx_Disjoint [[G2]] [[{ x : ¹ν T2 }]] }}
G1 ⊢ t : T1 ⧔ T2 [[:TYt]]
¹↑·G2 ⨄ { x : ¹ν T2 } ⊢ u : U [[:TYu]]
-------------------------------- :: Map
G1 ⨄ G2 ⊢ t ≻map x ⟼ u : T1 ⧔ U

G ⊢ t : ⌊𝟏⌋n [[:TYt]]
------------------------------ :: FillU
G ⊢ t ⨞ () : 𝟏

{{ ctx_Disjoint [[G2]] [[{ x : m T1 }]] }}
G1 ⊢ t : ⌊T1 m → T2⌋n [[:TYt]]
G2 ⨄ { x : m T1 } ⊢ u : T2 [[:TYu]]
---------------------------------------- :: FillF
G1 ⨄ (¹↑·n)·G2 ⊢ t ⨞ λ x ⟼ u : 𝟏

G ⊢ t : ⌊T1 ⨁ T2⌋n [[:TYt]]
------------------------------ :: FillL
G ⊢ t ⨞ Inl : ⌊T1⌋n

G ⊢ t : ⌊T1 ⨁ T2⌋n [[:TYt]]
------------------------------ :: FillR
G ⊢ t ⨞ Inr : ⌊T2⌋n

G ⊢ t : ⌊T1 ⨂ T2⌋n [[:TYt]]
------------------------------ :: FillP
G ⊢ t ⨞ (,) : ⌊T1⌋n ⨂ ⌊T2⌋n

G ⊢ t : ⌊!m T⌋n [[:TYt]]
------------------------------ :: FillE
G ⊢ t ⨞ ᴇ m : ⌊T⌋m·n

G1 ⊢ t : ⌊T1⌋n [[:TYt]]
G2 ⊢ u : T1 ⧔ T2 [[:TYu]]
----------------------------- :: FillC
G1 ⨄ (¹↑·n)·G2 ⊢ t ⨞· u : T2

-------------------------------- :: Alloc
{} ⊢ alloc T : T ⧔ ⌊T⌋¹ν

G ⊢ t : T [[:TYt]]
------------------------------- :: ToA
G ⊢ to⧔ t : T ⧔ 𝟏

G ⊢ t : T ⧔ 𝟏 [[:TYt]]
------------------------------- :: FromA
G ⊢ from⧔ t : T

defn
G ⫦ C : T :: :: TyR_ectx :: TyR_ectx_ {{ com Typing of evaluation contexts }} by

% G2 contains dests that aren't present in G1, so must have been absorbed by holes of open ampars from C
% G3 contains dests that still appear in G1 so that aren't absorbed by holes of open ampars from C
% {{ ctx_SubsetEq [[G3]] [[G1]] }} Should be provable; redundant
{{ ctx_Disjoint [[G1]] [[G2]] }}
{{ ctx_Disjoint [[G2]] [[G3]] }}
{{ ctx_NoVar [[G2 ⨄ G3]] }} % Because t1 types as a term, it cannot contain holes, so this is equivalent to ctx_DestOnly G11 ⨄ G12
{{ ctx_NoVar [[G1]] }} % Same here
G2 ⨄ G3 ⊢ t : T1 [[:TYt]]
G1 ⊢ C[t] : T2 [[:TYj]]
--------------------- :: T
G1 ⨄ (-G2) ⫦ C : T1 ↣ T2

defns
Sem :: '' ::=

defn
j ⟶ j' :: :: Sem_eterm :: Sem_eterm_ {{ com Small-step evaluation of terms using evaluation contexts }} {{ tex [[j]]~\longrightarrow~[[j']] }} by

------------------ :: App
C[v ≻ (λᵛ x ⟼ t) ] ⟶ C[t[x ≔ v] ]

----------------------- :: PatU
C[() ; t2] ⟶ C[t2]

----------------------- :: PatL
C[(Inl v) ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u1[x ≔ v] ]

----------------------- :: PatR
C[(Inr v) ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u2[x ≔ v] ]

----------------------- :: PatP
C[(v1, v2) ≻case m (x1,x2) ⟼ u] ⟶ C[u[x1 ≔ v1][x2 ≔ v2] ]

----------------------- :: PatE
C[ᴇ n v ≻case m ᴇ n x ⟼ u] ⟶ C[u[x ≔ v] ]

{{ [[h']] = [[max(hnames(C))]] }}
---------------------------------- :: MapOpen
C[ H ⟨ v1 ❟ v2 ⟩ ≻map x ⟼ u] ⟶ (C ∘ (H⩲h' ᵒ⟨ v1⩲h' ❟ []))[ u[x ≔ v2⩲h'] ]

---------------------------------- :: MapClose
(C ∘ H ᵒ⟨ v1 ❟ [])[v2] ⟶ C[ H ⟨ v1 ❟ v2 ⟩ ]

-------------------------- :: Alloc
alloc T ⟶ {1} ⟨ +1 ❟ -1 ⟩

----------------------------------------- :: ToA
C[to⧔ v] ⟶ C[{} ⟨ v ❟ () ⟩]

-------------------------------------- :: FromA
C[from⧔ {} ⟨ v ❟ () ⟩] ⟶ v

------------------------------------- :: FillU
C[+h ⨞ ()] ⟶ C[h ≔ {} ()][()]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillL
C[+h ⨞ Inl] ⟶ C[h ≔ {h'+1} Inl -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillR
C[+h ⨞ Inr] ⟶ C[h ≔ {h'+1} Inr -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillE
C[+h ⨞ ᴇ m] ⟶ C[h ≔ {h'+1} ᴇ m -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillP
C[+h ⨞ (,)] ⟶ C[h ≔ {h'+1,h'+2} (-(h'+1),-(h'+2))][( +(h'+1), +(h'+2) )]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
---------------------------------------- :: FillC
C[+h ⨞· H ⟨ v1 ❟ v2 ⟩] ⟶ C[h ≔ (H⩲h') v1⩲h' ][v2⩲h' ]
