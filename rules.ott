defns
Ty :: '' ::=

defn
G ⫦ v : T :: :: TyR_val :: TyR_val_ {{ com Typing of values (raw) }} by

% We must track linearity precisely, but age for received value is arbitrary
--------------------- :: H
{ - h : T ¹ν } ⫦ -h : T

{{ ctx_Compatible [[G]] [[+h : ¹ν ⌊T⌋n]] }}
---------------- :: D
G ⫦ +h : ⌊T⌋n

--------------------- :: U
{} ⫦ () :𝟏


% {{ mode_IsValid [[m]] }} : Probably we can relax that? Application will be impossible for such a function (as it would make the resulting context invalid), but it doesn't pose a problem per se
% {{ ctx_Disjoint [[D]] [[{ x : m T1 }]] }} : Redundant because ctx_DestOnly D => ctx_Disjoint D { x : m T1 }
% other rules don't need ctx_NoVar D as they cannot syntactically accept vars
{{ ctx_DestOnly [[D]] }} % Only says that we cannot have holes inside, as well as t cannot capture extra variables
D ⨄ { x : m T1 } ⊢ t : T2 [[:TYt]]
----------------- :: F
D ⫦ λᵛ x m ⟼ t : T1 m → T2

G ⫦ v : T1 [[:TYRv]]
--------------------- :: L
G ⫦ Inl v : T1 ⨁ T2

G ⫦ v : T2 [[:TYRv]]
--------------------- :: R
G ⫦ Inr v : T1 ⨁ T2

G1 ⫦ v1 : T1 [[:TYRv1]]
G2 ⫦ v2 : T2 [[:TYRv2]]
------------------------- :: P
G1 ⨄ G2 ⫦ (v1, v2) : T1 ⨂ T2

% we should augment age of holes which are below an exponential
G ⫦ v : T [[:TYRv]]
% {{ mode_IsValid [[n]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
--------------------- :: E
n·G ⫦ ᴇ n v : ! n T

% We perform controls here on Ampar, and not on the other rules, because outside of the ampar, the hole/dests that are compensated will no longer be visible.
% ctx_DestOnly [[G2 ⨄ G3]] ensures that v2 is just made of dests, and with ctx_DestOnly [[G1]] in G1 ⨄ (-G3) ⫦ v1 : T1 we can conclude that v2 dests compensates at least all the holes from this ampar. This forbids <<(-h0, -h), +h>, +h0> which isn't constructible through alloc anyway.
% These more complex rules are made to allow this program, in which v2 is made of dests which are not exclusively from this ampar:
% alloc >map x0 |-> 
%     alloc >map x1 |->
%         let x2 = fromA (alloc >map xt |-> xt <| E ↑ <|. (toA x0)) in
%         fromA ( alloc >map xt |-> xt <| (,) >case (xt1, xt2) |->
%                     xt1 <|. (toA x1) ; xt2 <|. (toA x2)
%               )
% We would have x2 = E ↑ +h0, and res = < -h0, < -h1 , (+h1, E ↑ +h0) > >
% If such a program typechecks, then we need the extra context G2 to v2 for dests coming from outside of this ampar (with ctx_DestOnly G2)
% We need to make sure that an ampar will bind as many holes as possible (i.e that holes and matching dests cannot escape respectively in G1 and G2) -> ensured by {{ ctx_DestOnly [[G1]] }}, as G1 and G2 cannot interact. So we no longer need ctx_Disjoint [[G1]] [[G2]]
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_DestOnly [[D3]] }}
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_Disjoint [[D1]] [[D3]] }}
{{ ctx_Disjoint [[D2]] [[D3]] }}
D1 ⨄ (-D3) ⫦ v1 : T1 [[:TYRv1]]
D2 ⨄ D3 ⫦ v2 : T2 [[:TYRv2]]
---------------- :: A
D1 ⨄ D2 ⫦ hnames(-D3) ⟨v1 ❟ v2⟩ : T1 ⧔ T2

defn
P ⊢ t : T :: :: Ty_term :: Ty_term_ {{ com Typing of terms }} by

{{ ctx_DestOnly [[D]] }} % Functionnally equivalent as ctx_NoHole P as values cannot syntactically contains free variables
D ⫦ v : T
-------------------- :: Val
D ⊢ v : T

{{ ctx_Compatible [[P]] [[x : ¹ν T]] }}
-------------------- :: Var
P ⊢ x : T

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
P1 ⊢ t : T1 [[:TYt]]
P2 ⊢ u : T1 m → T2 [[:TYu]]
----------------- :: App
m·P1 ⨄ P2 ⊢ t ≻ u : T2

P1 ⊢ t :𝟏 [[:TYt]]
P2 ⊢ u : U [[:TYu]]
----------------- :: PatU
P1 ⨄ P2 ⊢ t ; u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[P2]] [[{ x2 : m T2 }]] }}
P1 ⊢ t : T1 ⨁ T2 [[:TYt]]
P2 ⨄ { x1 : m T1 } ⊢ u1 : U [[:TYu1]]
P2 ⨄ { x2 : m T2 } ⊢ u2 : U [[:TYu2]]
----------------- :: PatS
m·P1 ⨄ P2 ⊢ t ≻case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[P2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }}
P1 ⊢ t : T1 ⨂ T2 [[:TYt]]
P2 ⨄ { x1 : m T1, x2 : m T2 } ⊢ u : U [[:TYu]]
----------------- :: PatP
m·P1 ⨄ P2 ⊢ t ≻case m (x1 , x2) ⟼ u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x : m·n T }]] }}
P1 ⊢ t : !n T [[:TYt]]
P2 ⨄ { x : m·n T } ⊢ u : U [[:TYu]]
----------------- :: PatE
m·P1 ⨄ P2 ⊢ t ≻case m ᴇ n x ⟼ u : U

{{ ctx_Disjoint [[P2]] [[{ x : ¹ν T2 }]] }}
P1 ⊢ t : T1 ⧔ T2 [[:TYt]]
¹↑·P2 ⨄ { x : ¹ν T2 } ⊢ u : U [[:TYu]]
-------------------------------- :: Map
P1 ⨄ P2 ⊢ t ≻map x ⟼ u : T1 ⧔ U

P ⊢ t : T [[:TYt]]
------------------------------- :: ToA
P ⊢ to⧔ t : T ⧔ 𝟏

P ⊢ t : T ⧔ 𝟏 [[:TYt]]
------------------------------- :: FromA
P ⊢ from⧔ t : T

-------------------------------- :: Alloc
{} ⊢ alloc : T ⧔ ⌊T⌋¹ν

P ⊢ t : ⌊𝟏⌋n [[:TYt]]
------------------------------ :: FillU
P ⊢ t ⨞ () : 𝟏

{{ ctx_Disjoint [[P2]] [[{ x : m T1 }]] }}
P1 ⊢ t : ⌊T1 m → T2⌋n [[:TYt]]
P2 ⨄ { x : m T1 } ⊢ u : T2 [[:TYu]]
---------------------------------------- :: FillF
P1 ⨄ (¹↑·n)·P2 ⊢ t ⨞(λ x m ⟼ u) : 𝟏

P ⊢ t : ⌊T1 ⨁ T2⌋n [[:TYt]]
------------------------------ :: FillL
P ⊢ t ⨞ Inl : ⌊T1⌋n

P ⊢ t : ⌊T1 ⨁ T2⌋n [[:TYt]]
------------------------------ :: FillR
P ⊢ t ⨞ Inr : ⌊T2⌋n

P ⊢ t : ⌊T1 ⨂ T2⌋n [[:TYt]]
------------------------------ :: FillP
P ⊢ t ⨞ (,) : ⌊T1⌋n ⨂ ⌊T2⌋n

P ⊢ t : ⌊!n' T⌋n [[:TYt]]
------------------------------ :: FillE
P ⊢ t ⨞ ᴇ n' : ⌊T⌋n'·n

P1 ⊢ t : ⌊T1⌋n [[:TYt]]
P2 ⊢ u : T1 ⧔ T2 [[:TYu]]
----------------------------- :: FillC
P1 ⨄ (¹↑·n)·P2 ⊢ t ⨞· u : T2

defn
D ⊣ C : T1 ↣ T2 :: :: Ty_ectx :: TyR_ectx_ {{ com Typing of evaluation contexts }} {{ tex [[D]][[⊣]][[C]]:[[T1]]\ottstype{\rightarrowtail}[[T2]] }} by

% Idea : remove MultCond, but have a failable multiplication through good intercalation of ctx_minus and mult. This would work without fancy things with having dual modes for holes I think. Because ctx_minus will enforce linearity, so hole ctx multiplied by non-linear n could never be compensated (which is a good thing). But that would remove the ability to have 2 holes compensated by 1 omega dest.
% If we go with "product mode" solution then we cannot multiply by n blindly as it would contaminate  ; we need to ??

-------------------- :: Id
{} ⊣ [] : U0 ↣ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
%{{ ctx_Empty [[D1]] \/ mode_IsLin [[m]] }} != {} => m = ¹ν
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
m·D1 ⨄ D2 ⊣ C : T2 ↣ U0 [[:TYC]]
D2 ⊢ u : T1 m → T2 [[:TYu]]
----------------- :: App1
D1 ⊣ C ∘ ([] ≻ u) : T1 ↣ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
m·D1 ⨄ D2 ⊣ C : T2 ↣ U0 [[:TYC]]
D1 ⊢ v : T1 [[:TYv]]
----------------- :: App2
D2 ⊣ C ∘ (v ≻ []) : (T1 m → T2) ↣ U0

{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TYC]]
D2 ⊢ u : U [[:TYu]]
----------------- :: PatU
D1 ⊣ C ∘ ([] ; u) : 𝟏 ↣ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = ¹ν
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_Disjoint [[D2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[D2]] [[{ x2 : m T2 }]] }}
m·D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TYC]]
D2 ⨄ { x1 : m T1 } ⊢ u1 : U [[:TYu1]]
D2 ⨄ { x2 : m T2 } ⊢ u2 : U [[:TYu2]]
----------------- :: PatS
D1 ⊣ C ∘ ([] ≻case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 }) : (T1 ⨁ T2) ↣ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = ¹ν
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_Disjoint [[D2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[D2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }}
m·D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TYC]]
D2 ⨄ { x1 : m T1, x2 : m T2 } ⊢ u : U [[:TYu]]
----------------- :: PatP
D1 ⊣ C ∘ ([] ≻case m (x1 , x2) ⟼ u) : (T1 ⨂ T2) ↣ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = ¹ν
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_Disjoint [[D2]] [[{ x : m·m' T }]] }}
m·D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TYC]]
D2 ⨄ { x : m·m' T } ⊢ u : U [[:TYu]]
----------------- :: PatE
D1 ⊣ C ∘ ([] ≻case m ᴇ m' x ⟼ u) : ! m' T ↣ U0

{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_Disjoint [[¹↑·D2]] [[{ x : ¹ν T2 }]] }}
D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TYC]]
¹↑·D2 ⨄ { x : ¹ν T2 } ⊢ u : U [[:TYu]]
-------------------------------- :: Map
D1 ⊣ C ∘ ([] ≻map x ⟼ u) : (T1 ⧔ T2) ↣ U0

D ⊣ C : (T ⧔ 𝟏) ↣ U0 [[:TYC]]
------------------------------- :: ToA
D ⊣ C ∘ (to⧔ []) : T ↣ U0

D ⊣ C : T ↣ U0 [[:TYC]]
------------------------------- :: FromA
D ⊣ C ∘ (from⧔ []) : (T ⧔ 𝟏) ↣ U0

D ⊣ C : 𝟏 ↣ U0 [[:TYC]]
------------------------------ :: FillU
D ⊣ C ∘ ([] ⨞ ()) : ⌊𝟏⌋n ↣ U0

% Elements that can be compensated by u must be from an older scope
% Realistically dests are linear, so no dest from D2 can be stored in a non-linear function*
% D2 != {} => n = ¹ν
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_Disjoint [[D2]] [[{ x : m T1 }]] }}
D1 ⨄ (¹↑·n)·D2 ⊣ C : 𝟏 ↣ U0 [[:TYC]]
D2 ⨄ { x : m T1 } ⊢ u : T2 [[:TYu]]
---------------------------------------- :: FillF
D1 ⊣ C ∘ ([] ⨞(λ x m ⟼ u)) : ⌊T1 m → T2⌋n ↣ U0

D ⊣ C : ⌊T1⌋n ↣ U0 [[:TYC]]
------------------------------ :: FillL
D ⊣ C ∘ ([] ⨞ Inl) : ⌊T1 ⨁ T2⌋n ↣ U0

D ⊣ C : ⌊T2⌋n ↣ U0 [[:TYC]]
------------------------------ :: FillR
D ⊣ C ∘ ([] ⨞ Inr) : ⌊T1 ⨁ T2⌋n ↣ U0

D ⊣ C : (⌊T1⌋n ⨂ ⌊T2⌋n) ↣ U0 [[:TYC]]
------------------------------ :: FillP
D ⊣ C ∘ ([] ⨞ (,)) : ⌊T1 ⨂ T2⌋n ↣ U0

D ⊣ C : ⌊T⌋m·n ↣ U0  [[:TYC]]
------------------------------ :: FillE
D ⊣ C ∘ ([] ⨞ ᴇ m) : ⌊!m T⌋n ↣ U0

{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
D1 ⨄ (¹↑·n)·D2 ⊣ C : T2 ↣ U0 [[:TYC]]
D2 ⊢ u : T1 ⧔ T2 [[:TYu]]
----------------------------- :: FillC1
D1 ⊣ C ∘ ([] ⨞· u) : ⌊T1⌋n ↣ U0

{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
D1 ⨄ (¹↑·n)·D2 ⊣ C : T2 ↣ U0 [[:TYC]]
D1 ⊢ v : ⌊T1⌋n [[:TYu]]
----------------------------- :: FillC2
D2 ⊣ C ∘ (v ⨞· []) : T1 ⧔ T2 ↣ U0

% -D2: Some holes of C compensated by dests from v1
% D1 : remaining holes/dests from C
% D1 : external dests from v1 (not bound by this ampar)
% -D3 : holes from v1 (bound by this ampar)
% We want D2 to be maximal, so D1 must be disjoint from D1
% We do not want to holes from v1 to be compensated by dests from C. That would mean having {positive part of D1} and -D3 to interact.
% {{ ctx_IsValid [[-(n·D2)]] }} % TODO: check that ctx_minus enforces linearity+now

{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_Disjoint [[D1]] [[D3]] }}
{{ hdns_Disjoint [[hnames(C)]] [[hnames(-D3)]] }} % No shadowing for hole bindings, even already compensated ones (which wouldn't be assured by ctx_Disjoint D2 D3). In particular, that predicate implies ctx_Disjoint D2 D3
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_DestOnly [[D3]] }}
D1 ⨄ D2 ⊣ C : (T1 ⧔ U) ↣ U0 [[:TYC]]
D1 ⨄ -D3 ⫦ v1 : T1 [[:TYRv1]]
---------------- :: AOpen
¹↑·D2 ⨄ D3 ⊣ C ∘ (hnames(-D3) ᵒᵖ⟨v1 ❟ []) : U ↣ U0

defn
⊢ C [ t ] : T :: :: Ty_eterm :: Ty_eterm_ {{ com Typing of extended terms (pair of evaluation context and term) }} by

G ⊣ C : T ↣ U0 [[:TYRC]]
G ⊢ t : T [[:TYt]]
--------------------- :: ClosedEterm
⊢ C[t] : U0

defns
Sem :: '' ::=

% TODO: add explicit focusing rules (stack way)

defn
C [ t ] ⟶ C' [ t' ] :: :: Sem_eterm :: Sem_eterm_ {{ com Small-step evaluation of terms using evaluation contexts }} by

------------------ :: App
C[v ≻ (λᵛ x m ⟼ t) ] ⟶ C[t[x ≔ v] ]

----------------------- :: PatU
C[() ; t2] ⟶ C[t2]

----------------------- :: PatL
C[(Inl v) ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u1[x ≔ v] ]

----------------------- :: PatR
C[(Inr v) ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u2[x ≔ v] ]

----------------------- :: PatP
C[(v1, v2) ≻case m (x1,x2) ⟼ u] ⟶ C[u[x1 ≔ v1][x2 ≔ v2] ]

----------------------- :: PatE
C[ᴇ n v ≻case m ᴇ n x ⟼ u] ⟶ C[u[x ≔ v] ]

{{ [[h']] = [[max(hnames(C))]] }}
---------------------------------- :: MapOpen
C[ H ⟨ v1 ❟ v2 ⟩ ≻map x ⟼ u] ⟶ (C ∘ (H⩲h' ᵒᵖ⟨ v1⩲h' ❟ []))[ u[x ≔ v2⩲h'] ]

---------------------------------- :: MapClose
(C ∘ H ᵒᵖ⟨ v1 ❟ [])[v2] ⟶ C[ H ⟨ v1 ❟ v2 ⟩ ]

-------------------------- :: Alloc
C[alloc] ⟶ C[{1} ⟨ +1 ❟ -1 ⟩]

----------------------------------------- :: ToA
C[to⧔ v] ⟶ C[{} ⟨ v ❟ () ⟩]

-------------------------------------- :: FromA
C[from⧔ {} ⟨ v ❟ () ⟩] ⟶ C[v]

------------------------------------- :: FillU
C[+h ⨞ ()] ⟶ C[h ≔ {} ()][()]

------------------------------------- :: FillF
C[+h ⨞ (λ x m ⟼ u)] ⟶ C[h ≔ {} λᵛ x m ⟼ u][()]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillL
C[+h ⨞ Inl] ⟶ C[h ≔ {h'+1} Inl -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillR
C[+h ⨞ Inr] ⟶ C[h ≔ {h'+1} Inr -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillE
C[+h ⨞ ᴇ m] ⟶ C[h ≔ {h'+1} ᴇ m -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillP
C[+h ⨞ (,)] ⟶ C[h ≔ {h'+1,h'+2} (-(h'+1),-(h'+2))][( +(h'+1), +(h'+2) )]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
---------------------------------------- :: FillC
C[+h ⨞· H ⟨ v1 ❟ v2 ⟩] ⟶ C[h ≔ (H⩲h') v1⩲h' ][v2⩲h' ]
