defns
Ty :: '' ::=

defn
G ‚´¶ v : T :: :: TyR_val :: TyR_val_ {{ com Typing of values (raw) }} by

% We must track linearity precisely, but age for received value is arbitrary
--------------------- :: H
{ -h : T ¬πŒΩ } ‚´¶ -h : T

{{ ctx_CompatibleDH [[G]] [[h]] [[‚Çä ¬πŒΩ ‚åäT‚åãn]] }} [[:CompatGh]]
---------------- :: D
G ‚´¶ +h : ‚åäT‚åãn

--------------------- :: U
{} ‚´¶ () :ùüè


% {{ mode_IsValid [[m]] }} [[:Validm]] : Probably we can relax that? Application will be impossible for such a function (as it would make the resulting context invalid), but it doesn't pose a problem per se
% {{ ctx_Disjoint [[D]] [[{ x : m T1 }]] }} : Redundant because ctx_DestOnly D => ctx_Disjoint D { x : m T1 }
% other rules don't need ctx_NoVar D as they cannot syntactically accept vars
{{ ctx_DestOnly [[D]] }} [[:DestOnlyD]] [[:DestOnlyD]] % Only says that we cannot have holes inside, as well as t cannot capture extra variables 
D ‚®Ñ { x : m T } ‚ä¢ u : U [[:Tyu]]
----------------- :: F
D ‚´¶ Œª·µõ x m ‚üº u : T m ‚Üí U

G ‚´¶ v1 : T1 [[:TyRv1]]
--------------------- :: L
G ‚´¶ Inl v1 : T1 ‚®Å T2

G ‚´¶ v2 : T2 [[:TyRv2]]
--------------------- :: R
G ‚´¶ Inr v2 : T1 ‚®Å T2

G1 ‚´¶ v1 : T1 [[:TyRv1]]
G2 ‚´¶ v2 : T2 [[:TyRv2]]
------------------------- :: P
G1 ‚®Ñ G2 ‚´¶ (v1, v2) : T1 ‚®Ç T2

% we should augment age of holes which are below an exponential
G ‚´¶ v' : T [[:TyRvp]]
% {{ mode_IsValid [[n]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
--------------------- :: E
n¬∑G ‚´¶ ·¥á n v' : ! n T

% We perform controls here on Ampar, and not on the other rules, because outside of the ampar, the hole/dests that are compensated will no longer be visible.
% ctx_DestOnly [[G2 ‚®Ñ G3]] ensures that v2 is just made of dests, and with ctx_DestOnly [[G1]] in G1 ‚®Ñ (-G3) ‚´¶ v1 : T1 we can conclude that v2 dests compensates at least all the holes from this ampar. This forbids <<(-h0, -h), +h>, +h0> which isn't constructible through alloc anyway.
% These more complex rules are made to allow this program, in which v2 is made of dests which are not exclusively from this ampar:
% alloc >map x0 |-> 
%     alloc >map x1 |->
%         let x2 = fromA (alloc >map xt |-> xt <| E ‚Üë <|. (toA x0)) in
%         fromA ( alloc >map xt |-> xt <| (,) >case (xt1, xt2) |->
%                     xt1 <|. (toA x1) ; xt2 <|. (toA x2)
%               )
% We would have x2 = E ‚Üë +h0, and res = < -h0, < -h1 , (+h1, E ‚Üë +h0) > >
% If such a program typechecks, then we need the extra context G2 to v2 for dests coming from outside of this ampar (with ctx_DestOnly G2)
% We need to make sure that an ampar will bind as many holes as possible (i.e that holes and matching dests cannot escape respectively in G1 and G2) -> ensured by {{ ctx_DestOnly [[G1]] }}, as G1 and G2 cannot interact. So we no longer need ctx_Disjoint [[G1]] [[G2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_DestOnly [[D3]] }} [[:DestOnlyD3]]
{{ ctx_LinOnly [[D3]] }} [[:LinOnlyD3]]
{{ ctx_ValidOnly [[D3]] }} [[:ValidOnlyD3]]
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_Disjoint [[D1]] [[D3]] }} [[:DisjointD1D3]]
{{ ctx_Disjoint [[D2]] [[D3]] }} [[:DisjointD2D3]]
D1 ‚®Ñ D3 ‚´¶ v1 : T [[:TyRv1]]
D2 ‚®Ñ (-D3) ‚´¶ v2 : U [[:TyRv2]]
---------------- :: A
D1 ‚®Ñ D2 ‚´¶ hnames(-D3) ‚ü®v2 ‚ùü v1‚ü© : U ‚ßî T

defn
P ‚ä¢ t : T :: :: Ty_term :: Ty_term_ {{ com Typing of terms }} by

{{ ctx_DestOnly [[D]] }} [[:DestOnlyD]] % Functionnally equivalent as ctx_NoHole P as values cannot syntactically contains free variables
D ‚´¶ v : T [[:TyRv]]
-------------------- :: Val
D ‚ä¢ v : T

{{ ctx_CompatibleVar [[P]] [[x]] [[‚Çì ¬πŒΩ T]] }} [[:CompatPx]]
-------------------- :: Var
P ‚ä¢ x : T

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
P1 ‚ä¢ t : T [[:Tyt]]
P2 ‚ä¢ t' : T m ‚Üí U [[:Tytp]]
----------------- :: App
m¬∑P1 ‚®Ñ P2 ‚ä¢ t ‚âª t' : U

P1 ‚ä¢ t : ùüè [[:Tyt]]
P2 ‚ä¢ u : U [[:Tyu]]
----------------- :: PatU
P1 ‚®Ñ P2 ‚ä¢ t ; u : U

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x1 : m T1 }]] }} [[:DisjointP2x1]]
{{ ctx_Disjoint [[P2]] [[{ x2 : m T2 }]] }} [[:DisjointP2x2]]
P1 ‚ä¢ t : T1 ‚®Å T2 [[:Tyt]]
P2 ‚®Ñ { x1 : m T1 } ‚ä¢ u1 : U [[:Tyu1]]
P2 ‚®Ñ { x2 : m T2 } ‚ä¢ u2 : U [[:Tyu2]]
----------------- :: PatS
m¬∑P1 ‚®Ñ P2 ‚ä¢ t ‚âªcase m { Inl x1 ‚üº u1 , Inr x2 ‚üº u2 } : U

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x1 : m T1 }]] }} [[:DisjointP2x1]]
{{ ctx_Disjoint [[P2]] [[{ x2 : m T2 }]] }} [[:DisjointP2x2]]
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }} [[:Disjointx1x2]]
P1 ‚ä¢ t : T1 ‚®Ç T2 [[:Tyt]]
P2 ‚®Ñ { x1 : m T1 } ‚®Ñ { x2 : m T2 } ‚ä¢ u : U [[:Tyu]]
----------------- :: PatP
m¬∑P1 ‚®Ñ P2 ‚ä¢ t ‚âªcase m (x1 , x2) ‚üº u : U

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x : m¬∑n T }]] }} [[:DisjointP2x]]
P1 ‚ä¢ t : !n T [[:Tyt]]
P2 ‚®Ñ { x : m¬∑n T } ‚ä¢ u : U [[:Tyu]]
----------------- :: PatE
m¬∑P1 ‚®Ñ P2 ‚ä¢ t ‚âªcase m ·¥á n x ‚üº u : U

{{ ctx_Disjoint [[P2]] [[{ x : ¬πŒΩ T }]] }} [[:DisjointP2x]]
P1 ‚ä¢ t : U ‚ßî T [[:Tyt]]
¬π‚Üë¬∑P2 ‚®Ñ { x : ¬πŒΩ T } ‚ä¢ t' : T' [[:Tytp]]
-------------------------------- :: Map
P1 ‚®Ñ P2 ‚ä¢ t ‚âªmap x ‚üº t' : U ‚ßî T'

P ‚ä¢ u : U [[:Tyu]]
------------------------------- :: ToA
P ‚ä¢ to‚ßî u : U ‚ßî ùüè

P ‚ä¢ t : U ‚ßî ùüè [[:Tyt]]
------------------------------- :: FromA
P ‚ä¢ from‚ßî t : U

-------------------------------- :: Alloc
{} ‚ä¢ alloc : U ‚ßî ‚åäU‚åã¬πŒΩ

P ‚ä¢ t : ‚åäùüè‚åãn [[:Tyt]]
------------------------------ :: FillU
P ‚ä¢ t ‚®û () : ùüè

P ‚ä¢ t : ‚åäT1 ‚®Å T2‚åãn [[:Tyt]]
------------------------------ :: FillL
P ‚ä¢ t ‚®û Inl : ‚åäT1‚åãn

P ‚ä¢ t : ‚åäT1 ‚®Å T2‚åãn [[:Tyt]]
------------------------------ :: FillR
P ‚ä¢ t ‚®û Inr : ‚åäT2‚åãn

P ‚ä¢ t : ‚åäT1 ‚®Ç T2‚åãn [[:Tyt]]
------------------------------ :: FillP
P ‚ä¢ t ‚®û (,) : ‚åäT1‚åãn ‚®Ç ‚åäT2‚åãn

P ‚ä¢ t : ‚åä!n' T‚åãn [[:Tyt]]
------------------------------ :: FillE
P ‚ä¢ t ‚®û ·¥á n' : ‚åäT‚åãn'¬∑n

{{ ctx_Disjoint [[P2]] [[{ x : m T }]] }} [[:DisjointP2x]]
P1 ‚ä¢ t : ‚åäT m ‚Üí U‚åãn [[:Tyt]]
P2 ‚®Ñ { x : m T } ‚ä¢ u : U [[:Tyu]]
---------------------------------------- :: FillF
P1 ‚®Ñ (¬π‚Üë¬∑n)¬∑P2 ‚ä¢ t ‚®û(Œª x m ‚üº u) : ùüè

P1 ‚ä¢ t : ‚åäU‚åãn [[:Tyt]]
P2 ‚ä¢ t' : U ‚ßî T [[:Tytp]]
----------------------------- :: FillC
P1 ‚®Ñ (¬π‚Üë¬∑n)¬∑P2 ‚ä¢ t ‚®û¬∑ t' : T

defn
D ‚ä£ C : T ‚Ü£ U0 :: :: Ty_ectxs :: Ty_ectxs_ {{ com Typing of evaluation contexts }} {{ tex [[D]][[‚ä£]][[C]]:[[T]]\ottstype{\rightarrowtail}[[U0]] }} by

% Idea : remove MultCond, but have a failable multiplication through good intercalation of ctx_minus and mult. This would work without fancy things with having dual modes for holes I think. Because ctx_minus will enforce linearity, so hole ctx multiplied by non-linear n could never be compensated (which is a good thing). But that would remove the ability to have 2 holes compensated by 1 omega dest.
% If we go with "product mode" solution then we cannot multiply by n blindly as it would contaminate  ; we need to ??

-------------------- :: Id
{} ‚ä£ ‚¨ú : U0 ‚Ü£ U0

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
%{{ ctx_Empty [[D1]] \/ mode_IsLin [[m]] }} != {} => m = ¬πŒΩ
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ mode_IsValid [[m]] }} [[:Validm]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m¬∑D1 ‚®Ñ D2 ‚ä£ C : U ‚Ü£ U0 [[:TyC]]
D2 ‚ä¢ t' : T m ‚Üí U [[:Tytp]]
----------------- :: AppFoc1
D1 ‚ä£ C ‚àò (‚¨ú ‚âª t') : T ‚Ü£ U0

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[m¬∑D1]] }} [[:ValidmD1]]
m¬∑D1 ‚®Ñ D2 ‚ä£ C : U ‚Ü£ U0 [[:TyC]]
D1 ‚ä¢ v : T [[:Tyv]]
----------------- :: AppFoc2
D2 ‚ä£ C ‚àò (v ‚âª ‚¨ú) : (T m ‚Üí U) ‚Ü£ U0

{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
D1 ‚®Ñ D2 ‚ä£ C : U ‚Ü£ U0 [[:TyC]]
D2 ‚ä¢ u : U [[:Tyu]]
----------------- :: PatUFoc
D1 ‚ä£ C ‚àò (‚¨ú ; u) : ùüè ‚Ü£ U0

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = ¬πŒΩ
% {{ ctx_Disjoint [[D2]] [[{ x1 : m T1 }]] }} useless with DestOnly
% {{ ctx_Disjoint [[D2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ mode_IsValid [[m]] }} [[:Validm]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m¬∑D1 ‚®Ñ D2 ‚ä£ C : U ‚Ü£ U0 [[:TyC]]
D2 ‚®Ñ { x1 : m T1 } ‚ä¢ u1 : U [[:Tyu1]]
D2 ‚®Ñ { x2 : m T2 } ‚ä¢ u2 : U [[:Tyu2]]
----------------- :: PatSFoc
D1 ‚ä£ C ‚àò (‚¨ú ‚âªcase m { Inl x1 ‚üº u1 , Inr x2 ‚üº u2 }) : (T1 ‚®Å T2) ‚Ü£ U0

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = ¬πŒΩ
% {{ ctx_Disjoint [[D2]] [[{ x1 : m T1 }]] }} useless with DestOnly
% {{ ctx_Disjoint [[D2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }} [[:Disjointx1x2]]
{{ mode_IsValid [[m]] }} [[:Validm]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m¬∑D1 ‚®Ñ D2 ‚ä£ C : U ‚Ü£ U0 [[:TyC]]
D2 ‚®Ñ { x1 : m T1 } ‚®Ñ { x2 : m T2 } ‚ä¢ u : U [[:Tyu]]
----------------- :: PatPFoc
D1 ‚ä£ C ‚àò (‚¨ú ‚âªcase m (x1 , x2) ‚üº u) : (T1 ‚®Ç T2) ‚Ü£ U0

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = ¬πŒΩ
% {{ ctx_Disjoint [[D2]] [[{ x : m¬∑m' T }]] }} useless with DestOnly
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ mode_IsValid [[m]] }} [[:Validm]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m¬∑D1 ‚®Ñ D2 ‚ä£ C : U ‚Ü£ U0 [[:TyC]]
D2 ‚®Ñ { x : m¬∑m' T } ‚ä¢ u : U [[:Tyu]]
----------------- :: PatEFoc
D1 ‚ä£ C ‚àò (‚¨ú ‚âªcase m ·¥á m' x ‚üº u) : ! m' T ‚Ü£ U0

% {{ ctx_Disjoint [[¬π‚Üë¬∑D2]] [[{ x : ¬πŒΩ T2 }]] }} useless with DestOnly
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
D1 ‚®Ñ D2 ‚ä£ C : U ‚ßî T' ‚Ü£ U0 [[:TyC]]
¬π‚Üë¬∑D2 ‚®Ñ { x : ¬πŒΩ T } ‚ä¢ t' : T' [[:Tytp]]
-------------------------------- :: MapFoc
D1 ‚ä£ C ‚àò (‚¨ú ‚âªmap x ‚üº t') : (U ‚ßî T) ‚Ü£ U0

D ‚ä£ C : (U ‚ßî ùüè) ‚Ü£ U0 [[:TyC]]
------------------------------- :: ToAFoc
D ‚ä£ C ‚àò (to‚ßî ‚¨ú) : U ‚Ü£ U0

D ‚ä£ C : U ‚Ü£ U0 [[:TyC]]
------------------------------- :: FromAFoc
D ‚ä£ C ‚àò (from‚ßî ‚¨ú) : (U ‚ßî ùüè) ‚Ü£ U0

D ‚ä£ C : ùüè ‚Ü£ U0 [[:TyC]]
------------------------------ :: FillUFoc
D ‚ä£ C ‚àò (‚¨ú ‚®û ()) : ‚åäùüè‚åãn ‚Ü£ U0

D ‚ä£ C : ‚åäT1‚åãn ‚Ü£ U0 [[:TyC]]
------------------------------ :: FillLFoc
D ‚ä£ C ‚àò (‚¨ú ‚®û Inl) : ‚åäT1 ‚®Å T2‚åãn ‚Ü£ U0

D ‚ä£ C : ‚åäT2‚åãn ‚Ü£ U0 [[:TyC]]
------------------------------ :: FillRFoc
D ‚ä£ C ‚àò (‚¨ú ‚®û Inr) : ‚åäT1 ‚®Å T2‚åãn ‚Ü£ U0

D ‚ä£ C : (‚åäT1‚åãn ‚®Ç ‚åäT2‚åãn) ‚Ü£ U0 [[:TyC]]
------------------------------ :: FillPFoc
D ‚ä£ C ‚àò (‚¨ú ‚®û (,)) : ‚åäT1 ‚®Ç T2‚åãn ‚Ü£ U0

D ‚ä£ C : ‚åäT‚åãm¬∑n ‚Ü£ U0 [[:TyC]]
------------------------------ :: FillEFoc
D ‚ä£ C ‚àò (‚¨ú ‚®û ·¥á m) : ‚åä!m T‚åãn ‚Ü£ U0

% Elements that can be compensated by u must be from an older scope
% Realistically dests are linear, so no dest from D2 can be stored in a non-linear function*
% D2 != {} => n = ¬πŒΩ
% {{ ctx_Disjoint [[D2]] [[{ x : m T1 }]] }} useless with DestOnly
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[(¬π‚Üë¬∑n)¬∑D2]] }} [[:ValidsnD2]]
D1 ‚®Ñ (¬π‚Üë¬∑n)¬∑D2 ‚ä£ C : ùüè ‚Ü£ U0 [[:TyC]]
D2 ‚®Ñ { x : m T } ‚ä¢ u : U [[:Tyu]]
---------------------------------------- :: FillFFoc
D1 ‚ä£ C ‚àò (‚¨ú ‚®û(Œª x m ‚üº u)) : ‚åäT m ‚Üí U‚åãn ‚Ü£ U0

{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[(¬π‚Üë¬∑n)¬∑D2]] }} [[:ValidsnD2]]
D1 ‚®Ñ (¬π‚Üë¬∑n)¬∑D2 ‚ä£ C : T ‚Ü£ U0 [[:TyC]]
D2 ‚ä¢ t' : U ‚ßî T [[:Tytp]]
----------------------------- :: FillCFoc1
D1 ‚ä£ C ‚àò (‚¨ú ‚®û¬∑ t') : ‚åäU‚åãn ‚Ü£ U0

{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[D1]] }} [[:ValidsnD1]]
{{ mode_IsValid [[(¬π‚Üë¬∑n)]] }} [[:Validsn]]
D1 ‚®Ñ (¬π‚Üë¬∑n)¬∑D2 ‚ä£ C : T ‚Ü£ U0 [[:TyC]]
D1 ‚ä¢ v : ‚åäU‚åãn [[:Tyt]]
----------------------------- :: FillCFoc2
D2 ‚ä£ C ‚àò (v ‚®û¬∑ ‚¨ú) : U ‚ßî T ‚Ü£ U0

% TODO: check that ctx_minus enforces linearity+now

{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjoinD1D2]]
{{ ctx_Disjoint [[D1]] [[D3]] }} [[:DisjoinD1D3]]
{{ hdns_Disjoint [[hnames(C)]] [[hnames(-D3)]] }} [[:HDisjointCD3]] % No shadowing for hole bindings, even already compensated ones (which wouldn't be assured by ctx_Disjoint D2 D3). In particular, that predicate implies ctx_Disjoint D2 D3
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_DestOnly [[D3]] }} [[:DestOnlyD3]]
{{ ctx_LinOnly [[D3]] }} [[:LinOnlyD3]]
{{ ctx_ValidOnly [[D1]] }} [[:ValidOnlyD1]]
D1 ‚®Ñ D2 ‚ä£ C : (U ‚ßî T') ‚Ü£ U0 [[:TyC]]
D2 ‚®Ñ -D3 ‚´¶ v2 : U [[:TyRv2]]
---------------- :: AOpenFoc
¬π‚Üë¬∑D1 ‚®Ñ D3 ‚ä£ C ‚àò (hnames(-D3) ·µí·µñ‚ü®v2 ‚ùü ‚¨ú) : T' ‚Ü£ U0

defn
‚ä¢ C [ t ] : T :: :: Ty_eterm :: Ty_eterm_ {{ com Typing of extended terms (pair of evaluation context and term) }} by

{{ ctx_ValidOnly [[D]] }} [[:ValidOnlyD]]
{{ ctx_DestOnly [[D]] }} [[:DestOnlyD]]
D ‚ä£ C : T ‚Ü£ U0 [[:TyC]]
D ‚ä¢ t : T [[:Tyt]]
--------------------- :: ClosedEterm
‚ä¢ C[t] : U0

defns
Sem :: '' ::=

% If ectx composition is not a meta instruction but a syntactic rule for context formation, then all unfoc rules can be merged as a single "pop & reform term" instruction ?
% Not really for AOpenUnfoc because it is transformed back to a closed ampar instead of just being ectx substitution.

% We want theorem that C[t] -->* C[v] where englobing context doesn't change?

defn
C [ t ] ‚ü∂ C' [ t' ] :: :: Sem_eterm :: Sem_eterm_ {{ com Small-step evaluation of terms using evaluation contexts }} by

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------------- :: AppFoc1
C[t ‚âª t'] ‚ü∂ (C ‚àò (‚¨ú ‚âª t'))[t]

----------------------------- :: AppUnfoc1
(C ‚àò (‚¨ú ‚âª t'))[v] ‚ü∂ C[v ‚âª t']

{{ term_NotVal [[t']] }} [[:NotValtp]]
----------------------------- :: AppFoc2
C[v ‚âª t'] ‚ü∂ (C ‚àò (v ‚âª ‚¨ú))[t']

----------------------------- :: AppUnfoc2
(C ‚àò (v ‚âª ‚¨ú))[v'] ‚ü∂ C[v ‚âª v']

------------------ :: AppRed
C[v ‚âª (Œª·µõ x m ‚üº u) ] ‚ü∂ C[u[x ‚âî v] ]

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatUFoc
C[t ; u] ‚ü∂ (C ‚àò (‚¨ú ; u))[t]

----------------------- :: PatUUnfoc
(C ‚àò (‚¨ú ; u))[v] ‚ü∂ C[v ; u]

----------------------- :: PatURed
C[() ; u] ‚ü∂ C[u]

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatSFoc
C[t ‚âªcase m { Inl x1 ‚üº u1, Inr x2 ‚üº u2 }] ‚ü∂ (C ‚àò (‚¨ú ‚âªcase m { Inl x1 ‚üº u1, Inr x2 ‚üº u2 }))[t]

----------------------- :: PatSUnfoc
(C ‚àò (‚¨ú ‚âªcase m { Inl x1 ‚üº u1, Inr x2 ‚üº u2 }))[v] ‚ü∂ C[v ‚âªcase m { Inl x1 ‚üº u1, Inr x2 ‚üº u2 }]

----------------------- :: PatLRed
C[(Inl v1) ‚âªcase m { Inl x1 ‚üº u1, Inr x2 ‚üº u2 }] ‚ü∂ C[u1[x1 ‚âî v1] ]

----------------------- :: PatRRed
C[(Inr v2) ‚âªcase m { Inl x1 ‚üº u1, Inr x2 ‚üº u2 }] ‚ü∂ C[u2[x2 ‚âî v2] ]

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatPFoc
C[t ‚âªcase m (x1,x2) ‚üº u] ‚ü∂ (C ‚àò (‚¨ú ‚âªcase m (x1,x2) ‚üº u))[t]

----------------------- :: PatPUnfoc
(C ‚àò (‚¨ú ‚âªcase m (x1,x2) ‚üº u))[v] ‚ü∂ C[v ‚âªcase m (x1,x2) ‚üº u]

----------------------- :: PatPRed
C[(v1, v2) ‚âªcase m (x1,x2) ‚üº u] ‚ü∂ C[u[x1 ‚âî v1][x2 ‚âî v2] ]

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatEFoc
C[t ‚âªcase m ·¥á n x ‚üº u] ‚ü∂ (C ‚àò (‚¨ú ‚âªcase m ·¥á n x ‚üº u))[t]

----------------------- :: PatEUnfoc
(C ‚àò (‚¨ú ‚âªcase m ·¥á n x ‚üº u))[v] ‚ü∂ C[v ‚âªcase m ·¥á n x ‚üº u]

----------------------- :: PatERed
C[·¥á n v' ‚âªcase m ·¥á n x ‚üº u] ‚ü∂ C[u[x ‚âî v'] ]

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------- :: MapFoc
C[t ‚âªmap x ‚üº t'] ‚ü∂ (C ‚àò (‚¨ú ‚âªmap x ‚üº t'))[t]

----------------------- :: MapUnfoc
(C ‚àò (‚¨ú ‚âªmap x ‚üº t'))[v] ‚ü∂ C[v ‚âªmap x ‚üº t']

{{ [[h']] = [[max(hnames(C))]] }} [[:hpMaxC]]
---------------------------------- :: MapRedAOpenFoc
C[ H ‚ü® v2 ‚ùü v1 ‚ü© ‚âªmap x ‚üº t'] ‚ü∂ (C ‚àò (H‚©≤h' ·µí·µñ‚ü® v2‚©≤h' ‚ùü ‚¨ú))[ t'[x ‚âî v1‚©≤h'] ]

---------------------------------- :: AOpenUnfoc
(C ‚àò H ·µí·µñ‚ü® v2 ‚ùü ‚¨ú)[v1] ‚ü∂ C[ H ‚ü® v2 ‚ùü v1 ‚ü© ]

-------------------------- :: AllocRed
C[alloc] ‚ü∂ C[{1} ‚ü® +1 ‚ùü -1 ‚ü©]

{{ term_NotVal [[u]] }} [[:NotValu]]
-------------------------- :: ToAFoc
C[to‚ßî u] ‚ü∂ (C ‚àò (to‚ßî ‚¨ú))[u]

% No shape control here, so could be totally merged with ToARed
-------------------------- :: ToAUnfoc
(C ‚àò (to‚ßî ‚¨ú))[v2] ‚ü∂ C[to‚ßî v2]

----------------------------------------- :: ToARed
C[to‚ßî v2] ‚ü∂ C[{} ‚ü® v2 ‚ùü () ‚ü©]

{{ term_NotVal [[t]] }} [[:NotValt]]
-------------------------- :: FromAFoc
C[from‚ßî t] ‚ü∂ (C ‚àò (from‚ßî ‚¨ú))[t]

-------------------------- :: FromAUnfoc
(C ‚àò (from‚ßî ‚¨ú))[v] ‚ü∂ C[from‚ßî v]

-------------------------------------- :: FromARed
C[from‚ßî {} ‚ü® v2 ‚ùü () ‚ü©] ‚ü∂ C[v2]

{{ term_NotVal [[t]] }} [[:NotValt]]
-------------------------- :: FillUFoc
C[t ‚®û ()] ‚ü∂ (C ‚àò (‚¨ú ‚®û () ))[t]

-------------------------- :: FillUUnfoc
(C ‚àò (‚¨ú ‚®û () ))[v] ‚ü∂ C[v ‚®û ()]

------------------------------------- :: FillURed
C[+h ‚®û ()] ‚ü∂ C[h ‚âî {} ()][()]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillLFoc
C[t ‚®û Inl] ‚ü∂ (C ‚àò (‚¨ú ‚®û Inl))[t]

------------------------------------- :: FillLUnfoc
(C ‚àò (‚¨ú ‚®û Inl))[v] ‚ü∂ C[v ‚®û Inl]

{{ [[h']] = [[max(hnames(C) ‚à™ {h})]] }} [[:hpMaxCh]]
--------------------------------------- :: FillLRed
C[+h ‚®û Inl] ‚ü∂ C[h ‚âî {h'+1} Inl -(h'+1)][+(h'+1)]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillRFoc
C[t ‚®û Inr] ‚ü∂ (C ‚àò (‚¨ú ‚®û Inr))[t]

------------------------------------- :: FillRUnfoc
(C ‚àò (‚¨ú ‚®û Inr))[v] ‚ü∂ C[v ‚®û Inr]

{{ [[h']] = [[max(hnames(C) ‚à™ {h})]] }} [[:hpMaxCh]]
--------------------------------------- :: FillRRed
C[+h ‚®û Inr] ‚ü∂ C[h ‚âî {h'+1} Inr -(h'+1)][+(h'+1)]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillEFoc
C[t ‚®û ·¥á m] ‚ü∂ (C ‚àò (‚¨ú ‚®û ·¥á m))[t]

------------------------------------- :: FillEUnfoc
(C ‚àò (‚¨ú ‚®û ·¥á m))[v] ‚ü∂ C[v ‚®û ·¥á m]

{{ [[h']] = [[max(hnames(C) ‚à™ {h})]] }} [[:hpMaxCh]]
--------------------------------------- :: FillERed
C[+h ‚®û ·¥á m] ‚ü∂ C[h ‚âî {h'+1} ·¥á m -(h'+1)][+(h'+1)]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillPFoc
C[t ‚®û (,)] ‚ü∂ (C ‚àò (‚¨ú ‚®û (,)))[t]

------------------------------------- :: FillPUnfoc
(C ‚àò (‚¨ú ‚®û (,)))[v] ‚ü∂ C[v ‚®û (,)]

{{ [[h']] = [[max(hnames(C) ‚à™ {h})]] }} [[:hpMaxCh]]
--------------------------------------- :: FillPRed
C[+h ‚®û (,)] ‚ü∂ C[h ‚âî {h'+1,h'+2} (-(h'+1),-(h'+2))][( +(h'+1), +(h'+2) )]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillFFoc
C[t ‚®û(Œª x m ‚üº u)] ‚ü∂ (C ‚àò (‚¨ú ‚®û(Œª x m ‚üº u)))[t]

------------------------------------- :: FillFUnfoc
(C ‚àò (‚¨ú ‚®û(Œª x m ‚üº u)))[v] ‚ü∂ C[v ‚®û(Œª x m ‚üº u)]

------------------------------------- :: FillFRed
C[+h ‚®û (Œª x m ‚üº u)] ‚ü∂ C[h ‚âî {} Œª·µõ x m ‚üº u][()]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillCFoc1
C[t ‚®û¬∑ t'] ‚ü∂ (C ‚àò (‚¨ú ‚®û¬∑ t'))[t]

------------------------------------- :: FillCUnfoc1
(C ‚àò (‚¨ú ‚®û¬∑ t'))[v] ‚ü∂ C[v ‚®û¬∑ t']

{{ term_NotVal [[t']] }} [[:NotValtp]]
------------------------------------- :: FillCFoc2
C[v ‚®û¬∑ t'] ‚ü∂ (C ‚àò (v ‚®û¬∑ ‚¨ú))[t']

------------------------------------- :: FillCUnfoc2
(C ‚àò (v ‚®û¬∑ ‚¨ú))[v'] ‚ü∂ C[v ‚®û¬∑ v']

{{ [[h']] = [[max(hnames(C) ‚à™ {h})]] }} [[:hpMaxCh]]
---------------------------------------- :: FillCRed
C[+h ‚®û¬∑ H ‚ü® v2 ‚ùü v1 ‚ü©] ‚ü∂ C[h ‚âî (H‚©≤h') v2‚©≤h' ][v1‚©≤h' ]
