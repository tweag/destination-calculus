defns
Ty :: '' ::=

defn
G ⫦ v : T :: :: Ty_val :: Ty_val_ {{ com Typing judgment for values }} by

% We must track linearity precisely, but age for received value is arbitrary
--------------------- :: Hole
{ +h : T ¹ν } ⫦ +h : T

---------------- :: Dest
{ -h : ¹ν ⌊T⌋n } ⫦ -h : ⌊T⌋n

--------------------- :: Unit
{} ⫦ () :①

{{ IsValid [[m]] }} [[:Validm]]
% {{ [[D]] # [[{ x : m T }]] }} : _Redundant because DestOnly D => D # { x : m T1 }
% other rules don't need NoVar D as they cannot syntactically accept vars
{{ DestOnly [[D]] }} [[:DestOnlyD]] % Only says that we cannot have holes inside, as well as t cannot capture extra variables 
D + { x : m T } ⊢ u : U [[:Tyu]]
----------------- :: Fun
D ⫦ ᵛλ x m ⟼ u : T m → U

G ⫦ v1 : T1 [[:Tyv1]]
--------------------- :: Left
G ⫦ Inl v1 : T1 ⨁ T2

G ⫦ v2 : T2 [[:Tyv2]]
--------------------- :: Right
G ⫦ Inr v2 : T1 ⨁ T2

G1 ⫦ v1 : T1 [[:Tyv1]]
G2 ⫦ v2 : T2 [[:Tyv2]]
------------------------- :: Prod
G1 + G2 ⫦ (v1, v2) : T1 ⨂ T2

% we should augment age of holes which are below an exponential
G ⫦ v' : T [[:Tyvp]]
{{ IsValid [[n]] }} [[:Validn]]
--------------------- :: Exp
n·G ⫦ ᴇ n v' : ! n T

% We perform controls here on Ampar, and not on the other rules, because outside of the ampar, the hole/dests that are compensated will no longer be visible.
% DestOnly [[G2 + G3]] ensures that v2 is just made of dests, and with DestOnly [[G1]] in G1 + (-⁻¹G3) ⫦ v1 : T1 we can conclude that v2 dests compensates at least all the holes from this ampar. This forbids <<(+h0, +h), -h>, -h0> which isn't constructible through alloc anyway.
% These more complex rules are made to allow this program, in which v2 is made of dests which are not exclusively from this ampar:
% alloc >map x0 |-> 
%     alloc >map x1 |->
%         let x2 = fromA (alloc >map xt |-> xt <| E ↑ <|. (toA x0)) in
%         fromA ( alloc >map xt |-> xt <| (,) >case (xt1, xt2) |->
%                     xt1 <|. (toA x1) ; xt2 <|. (toA x2)
%               )
% We would have x2 = E ↑ -h0, and res = < +h0, < +h1 , (-h1, E ↑ -h0) > >
% If such a program typechecks, then we need the extra context G2 to v2 for dests coming from outside of this ampar (with DestOnly G2)
% We need to make sure that an ampar will bind as many holes as possible (i.e that holes and matching dests cannot escape respectively in G1 and G2) -> ensured by {{ DestOnly [[G1]] }}, as G1 and G2 cannot interact. So we no longer need [[G1]] # [[G2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ DestOnly [[D3]] }} [[:DestOnlyD3]]
{{ LinOnly [[D3]] }} [[:LinOnlyD3]]
{{ FinAgeOnly [[D3]] }} [[:FinAgeOnlyD3]]
{{ ValidOnly [[D3]] }} [[:ValidOnlyD3]]
{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ [[D1]] # [[D3]] }} [[:DisjointD1D3]]
{{ [[D2]] # [[D3]] }} [[:DisjointD2D3]]
¹↑·D1 + D3 ⫦ v1 : T [[:Tyv1]]
D2 + (-⁻¹D3) ⫦ v2 : U [[:Tyv2]]
---------------- :: Ampar
D1 + D2 ⫦ hvars(-⁻¹D3) ⟨v2 ❟ v1⟩ : U ⧔ T

defn
P ⊢ t : T :: :: Ty_term :: Ty_term_ {{ com Typing judgment for terms }} by

{{ DestOnly [[D]] }} [[:DestOnlyD]] % Functionnally equivalent as ctx_NoHole P as values cannot syntactically contains free variables
{{ DisposableOnly [[P]] }} [[:DisposP]]
% {{ [[D]] # [[P]] }} for free
D ⫦ v : T [[:Tyv]]
-------------------- :: Val
P + D ⊢ v : T

{{ DisposableOnly [[P]] }} [[:DisposP]]
{{ [[P]] # [[{ x : m T }]] }} [[:DisjointPx]]
{{ [[¹ν]] <: [[m]] }} [[:Subtypem]]
-------------------- :: Var
P + { x : m T } ⊢ x : T

{{ IsValid [[m]] }} [[:Validm]]
P1 ⊢ t : T [[:Tyt]]
P2 ⊢ t' : T m → U [[:Tytp]]
----------------- :: App
m·P1 + P2 ⊢ t  t' : U

P1 ⊢ t : ① [[:Tyt]]
P2 ⊢ u : U [[:Tyu]]
----------------- :: PatU
P1 + P2 ⊢ t ; u : U

{{ IsValid [[m]] }} [[:Validm]]
{{ [[P2]] # [[{ x1 : m T1 }]] }} [[:DisjointP2x1]]
{{ [[P2]] # [[{ x2 : m T2 }]] }} [[:DisjointP2x2]]
P1 ⊢ t : T1 ⨁ T2 [[:Tyt]]
P2 + { x1 : m T1 } ⊢ u1 : U [[:Tyu1]]
P2 + { x2 : m T2 } ⊢ u2 : U [[:Tyu2]]
----------------- :: PatS
m·P1 + P2 ⊢ t case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } : U

{{ IsValid [[m]] }} [[:Validm]]
{{ [[P2]] # [[{ x1 : m T1 }]] }} [[:DisjointP2x1]]
{{ [[P2]] # [[{ x2 : m T2 }]] }} [[:DisjointP2x2]]
{{ [[{ x1 : m T1 }]] # [[{ x2 : m T2 }]] }} [[:Disjointx1x2]]
P1 ⊢ t : T1 ⨂ T2 [[:Tyt]]
P2 + { x1 : m T1 } + { x2 : m T2 } ⊢ u : U [[:Tyu]]
----------------- :: PatP
m·P1 + P2 ⊢ t case m (x1 , x2) ⟼ u : U

{{ IsValid [[m]] }} [[:Validm]]
{{ IsValid [[n]] }} [[:Validn]]
{{ [[P2]] # [[{ x : m·n T }]] }} [[:DisjointP2x]]
P1 ⊢ t : !n T [[:Tyt]]
P2 + { x : m·n T } ⊢ u : U [[:Tyu]]
----------------- :: PatE
m·P1 + P2 ⊢ t case m ᴇ n x ⟼ u : U

{{ [[P2]] # [[{ x : ¹ν T }]] }} [[:DisjointP2x]]
P1 ⊢ t : U ⧔ T [[:Tyt]]
¹↑·P2 + { x : ¹ν T } ⊢ t' : T' [[:Tytp]]
-------------------------------- :: Map
P1 + P2 ⊢ t map x ⟼ t' : U ⧔ T'

P ⊢ u : U [[:Tyu]]
------------------------------- :: ToA
P ⊢ to⧔ u : U ⧔ ①

P ⊢ t : U ⧔ (! ¹∞ T) [[:Tyt]]
------------------------------- :: FromA
P ⊢ from⧔ t : U ⨂ (! ¹∞ T)

% -------------------------------- :: Alloc
% {} ⊢ alloc : U ⧔ ⌊U⌋¹ν

P ⊢ t : ⌊①⌋n [[:Tyt]]
------------------------------ :: FillU
P ⊢ t ⨞ () : ①

P ⊢ t : ⌊T1 ⨁ T2⌋n [[:Tyt]]
------------------------------ :: FillL
P ⊢ t ⨞ Inl : ⌊T1⌋n

P ⊢ t : ⌊T1 ⨁ T2⌋n [[:Tyt]]
------------------------------ :: FillR
P ⊢ t ⨞ Inr : ⌊T2⌋n

P ⊢ t : ⌊T1 ⨂ T2⌋n [[:Tyt]]
------------------------------ :: FillP
P ⊢ t ⨞ (,) : ⌊T1⌋n ⨂ ⌊T2⌋n

{{ IsValid [[n]] }} [[:Validn]]
P ⊢ t : ⌊!n' T⌋n [[:Tyt]]
------------------------------ :: FillE
P ⊢ t ⨞ ᴇ n' : ⌊T⌋n'·n

{{ IsValid [[m]] }} [[:Validm]]
{{ IsValid [[n]] }} [[:Validn]]
{{ [[P2]] # [[{ x : m T }]] }} [[:DisjointP2x]]
P1 ⊢ t : ⌊T m → U⌋n [[:Tyt]]
P2 + { x : m T } ⊢ u : U [[:Tyu]]
---------------------------------------- :: FillF
P1 + (¹↑·n)·P2 ⊢ t ⨞(λ x m ⟼ u) : ①

{{ IsValid [[n]] }} [[:Validn]]
P1 ⊢ t : ⌊U⌋n [[:Tyt]]
P2 ⊢ t' : U ⧔ T [[:Tytp]]
----------------------------- :: FillComp
P1 + (¹↑·n)·P2 ⊢ t ⨞· t' : T

defn
P ˢ⊢ t : T :: :: Ty_sterm :: Ty_sterm_ {{ com Derived typing judgment for syntactic sugar forms }} by

{{ DisposableOnly [[P]] }} [[:DisposP]]
-------------------- :: Alloc
P ˢ⊢ alloc : T ⧔ (⌊ T ⌋ ¹ν)

P ⊢ t : T ⧔ ① [[:Tyt]]
---------------- :: FromA'
P ˢ⊢ from⧔' t : T

{{ IsValid [[n]] }} [[:Validn]]
P1 ⊢ t : ⌊T⌋n [[:Tyt]]
P2 ⊢ t' : T [[:Tytp]]
----------------------------- :: FillLeaf
P1 + (¹↑·n)·P2 ˢ⊢ t ˢ⨞ t' : ①

{{ UserDefined [[P2]] }} [[:UserDefinedP2]]
{{ IsValid [[m]] }} [[:Validm]]
{{ [[P2]] # [[{ x : m T }]] }} [[:DisjointP2x]]
P2 + { x : m T } ⊢ u : U [[:Tyu]]
---------------------------------------- :: Fun
P2 ˢ⊢ ˢλ x m ⟼ u : T m → U

{{ UserDefined [[P2]] }} [[:UserDefinedP2]]
P2 ⊢ t : T1
------------------------------ :: Left
P2 ˢ⊢ ˢInl t : T1 ⨁ T2

{{ UserDefined [[P2]] }} [[:UserDefinedP2]]
P2 ⊢ t : T2
------------------------------ :: Right
P2 ˢ⊢ ˢInr t : T1 ⨁ T2

{{ UserDefined [[P2]] }} [[:UserDefinedP2]]
{{ IsValid [[m]] }} [[:Validm]]
P2 ⊢ t : T
----------------------------------- :: Exp
m·P2 ˢ⊢ ˢᴇ m t : ! m T

{{ UserDefined [[P21]] }} [[:UserDefinedP21]]
{{ UserDefined [[P22]] }} [[:UserDefinedP22]]
P21 ⊢ t1 : T1
P22 ⊢ t2 : T2
----------------------------------- :: Prod
P21 + P22 ˢ⊢ ˢ(t1, t2) : T1 ⨂ T2

defn
D ⊣ C : T ↣ U0 :: :: Ty_ectxs :: Ty_ectxs_ {{ com Typing judgment for evaluation contexts }} {{ tex [[D]][[⊣]][[C]]:[[T]]\ottstype{\rightarrowtail}[[U0]] }} by

% Idea : remove MultCond, but have a failable multiplication through good intercalation of hminus_inv and mult. This would work without fancy things with having dual modes for holes I think. Because hminus_inv will enforce linearity, so hole ctx multiplied by non-linear n could never be compensated (which is a good thing). But that would remove the ability to have 2 holes compensated by 1 omega dest.
% If we go with "product mode" solution then we cannot multiply by n blindly as it would contaminate  ; we need to ??

-------------------- :: Id
{} ⊣ ⬜ : U0 ↣ U0

{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ IsValid [[m]] }} [[:Validm]]
{{ ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m·D1 + D2 ⊣ C : U ↣ U0 [[:TyC]]
D2 ⊢ t' : T m → U [[:Tytp]]
----------------- :: App_Foc1
D1 ⊣ C ∘ (⬜  t') : T ↣ U0

{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ IsValid [[m]] }} [[:Validm]]
{{ ValidOnly [[D1]] }} [[:ValidOnlyD1]]
m·D1 + D2 ⊣ C : U ↣ U0 [[:TyC]]
D1 ⊢ v : T [[:Tyv]]
----------------- :: App_Foc2
D2 ⊣ C ∘ (v  ⬜) : (T m → U) ↣ U0

{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ValidOnly [[D2]] }} [[:ValidOnlyD2]]
D1 + D2 ⊣ C : U ↣ U0 [[:TyC]]
D2 ⊢ u : U [[:Tyu]]
----------------- :: PatU_Foc
D1 ⊣ C ∘ (⬜ ; u) : ① ↣ U0

% {{ [[D2]] # [[{ x1 : m T1 }]] }} useless with DestOnly
% {{ [[D2]] # [[{ x2 : m T2 }]] }} useless with DestOnly
{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ IsValid [[m]] }} [[:Validm]]
{{ ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m·D1 + D2 ⊣ C : U ↣ U0 [[:TyC]]
D2 + { x1 : m T1 } ⊢ u1 : U [[:Tyu1]]
D2 + { x2 : m T2 } ⊢ u2 : U [[:Tyu2]]
----------------- :: PatS_Foc
D1 ⊣ C ∘ (⬜ case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 }) : (T1 ⨁ T2) ↣ U0

% {{ [[D2]] # [[{ x1 : m T1 }]] }} useless with DestOnly
% {{ [[D2]] # [[{ x2 : m T2 }]] }} useless with DestOnly
{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ [[{ x1 : m T1 }]] # [[{ x2 : m T2 }]] }} [[:Disjointx1x2]]
{{ IsValid [[m]] }} [[:Validm]]
{{ ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m·D1 + D2 ⊣ C : U ↣ U0 [[:TyC]]
D2 + { x1 : m T1 } + { x2 : m T2 } ⊢ u : U [[:Tyu]]
----------------- :: PatP_Foc
D1 ⊣ C ∘ (⬜ case m (x1 , x2) ⟼ u) : (T1 ⨂ T2) ↣ U0

% {{ [[D2]] # [[{ x : m·m' T }]] }} useless with DestOnly
{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ IsValid [[m]] }} [[:Validm]]
{{ IsValid [[m']] }} [[:Validmp]]
{{ ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m·D1 + D2 ⊣ C : U ↣ U0 [[:TyC]]
D2 + { x : m·m' T } ⊢ u : U [[:Tyu]]
----------------- :: PatE_Foc
D1 ⊣ C ∘ (⬜ case m ᴇ m' x ⟼ u) : ! m' T ↣ U0

% {{ [[D2]] # [[{ x : ¹ν T }]] }} useless with DestOnly
{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ValidOnly [[D2]] }} [[:ValidOnlyD2]]
D1 + D2 ⊣ C : U ⧔ T' ↣ U0 [[:TyC]]
¹↑·D2 + { x : ¹ν T } ⊢ t' : T' [[:Tytp]]
-------------------------------- :: Map_Foc
D1 ⊣ C ∘ (⬜ map x ⟼ t') : (U ⧔ T) ↣ U0

D ⊣ C : (U ⧔ ①) ↣ U0 [[:TyC]]
------------------------------- :: ToA_Foc
D ⊣ C ∘ (to⧔ ⬜) : U ↣ U0

D ⊣ C : (U ⨂ (! ¹∞ T)) ↣ U0 [[:TyC]]
------------------------------- :: FromA_Foc
D ⊣ C ∘ (from⧔ ⬜) : (U ⧔ (! ¹∞ T)) ↣ U0

D ⊣ C : ① ↣ U0 [[:TyC]]
------------------------------ :: FillU_Foc
D ⊣ C ∘ (⬜ ⨞ ()) : ⌊①⌋n ↣ U0

D ⊣ C : ⌊T1⌋n ↣ U0 [[:TyC]]
------------------------------ :: FillL_Foc
D ⊣ C ∘ (⬜ ⨞ Inl) : ⌊T1 ⨁ T2⌋n ↣ U0

D ⊣ C : ⌊T2⌋n ↣ U0 [[:TyC]]
------------------------------ :: FillR_Foc
D ⊣ C ∘ (⬜ ⨞ Inr) : ⌊T1 ⨁ T2⌋n ↣ U0

D ⊣ C : (⌊T1⌋n ⨂ ⌊T2⌋n) ↣ U0 [[:TyC]]
------------------------------ :: FillP_Foc
D ⊣ C ∘ (⬜ ⨞ (,)) : ⌊T1 ⨂ T2⌋n ↣ U0

{{ IsValid [[m]] }} [[:Validm]]
D ⊣ C : ⌊T⌋m·n ↣ U0 [[:TyC]]
------------------------------ :: FillE_Foc
D ⊣ C ∘ (⬜ ⨞ ᴇ m) : ⌊!m T⌋n ↣ U0

% {{ [[D2]] # [[{ x : m T }]] }} useless with DestOnly
{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ValidOnly [[D2]] }} [[:ValidOnlyD2]]
{{ IsValid [[m]] }} [[:Validm]]
{{ IsValid [[n]] }} [[:Validn]]
D1 + (¹↑·n)·D2 ⊣ C : ① ↣ U0 [[:TyC]]
D2 + { x : m T } ⊢ u : U [[:Tyu]]
---------------------------------------- :: FillF_Foc
D1 ⊣ C ∘ (⬜ ⨞(λ x m ⟼ u)) : ⌊T m → U⌋n ↣ U0

{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ValidOnly [[D2]] }} [[:ValidOnlyD2]]
{{ IsValid [[n]] }} [[:Validn]]
D1 + (¹↑·n)·D2 ⊣ C : T ↣ U0 [[:TyC]]
D2 ⊢ t' : U ⧔ T [[:Tytp]]
----------------------------- :: FillComp_Foc1
D1 ⊣ C ∘ (⬜ ⨞· t') : ⌊U⌋n ↣ U0

{{ [[D1]] # [[D2]] }} [[:DisjointD1D2]]
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ValidOnly [[D1]] }} [[:ValidOnlyD1]]
{{ IsValid [[n]] }} [[:Validn]]
D1 + (¹↑·n)·D2 ⊣ C : T ↣ U0 [[:TyC]]
D1 ⊢ v : ⌊U⌋n [[:Tyt]]
----------------------------- :: FillComp_Foc2
D2 ⊣ C ∘ (v ⨞· ⬜) : U ⧔ T ↣ U0

% TODO: check that hminus_inv enforces linearity+now

{{ [[D1]] # [[D2]] }} [[:Disjoint1D2]]
{{ [[D1]] # [[D3]] }} [[:Disjoint1D3]]
{{ [[D2]] # [[D3]] }} [[:Disjoint2D3]]
{{ [[hvars(C)]] ## [[hvars(-⁻¹D3)]] }} [[:HDisjointCD3]] % No shadowing for hole bindings, even already compensated ones (which wouldn't be assured by D2 # D3). In particular, that predicate implies D2 # D3
{{ DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ DestOnly [[D3]] }} [[:DestOnlyD3]]
{{ LinOnly [[D3]] }} [[:LinOnlyD3]]
{{ FinAgeOnly [[D3]] }} [[:FinAgeOnlyD3]]
{{ ValidOnly [[D3]] }} [[:ValidOnlyD3]]
D1 + D2 ⊣ C : (U ⧔ T') ↣ U0 [[:TyC]]
D2 + -⁻¹D3 ⫦ v2 : U [[:Tyv2]]
---------------- :: OpenAmpar_Foc
¹↑·D1 + D3 ⊣ C ∘ (hvars(-⁻¹D3) ᵒᵖ⟨v2 ❟ ⬜⟩) : T' ↣ U0

defn
⊢ C [ t ] : T :: :: Ty :: Ty_ {{ com Typing judgment for commands }} by

{{ ValidOnly [[D]] }} [[:ValidOnlyD]]
{{ DestOnly [[D]] }} [[:DestOnlyD]]
D ⊣ C : T ↣ U0 [[:TyC]]
D ⊢ t : T [[:Tyt]]
--------------------- :: cmd
⊢ C[t] : U0

defns
Sem :: '' ::=

% If ectx composition is not a meta instruction but a syntactic rule for context formation, then all unfoc rules can be merged as a single "pop & reform term" instruction ?
% Not really for OpenAmpar_Unfoc because it is transformed back to a closed ampar instead of just being ectx substitution.

% We want theorem that C[t] -->* C[v] where englobing context doesn't change?

defn
C [ t ] ⟶ C' [ t' ] :: :: Sem :: Sem_ {{ com Small-step evaluation of commands }} by

{{ NotVal [[t]] }} [[:NotValt]]
----------------------------- :: App_Foc1
C[t  t'] ⟶ (C ∘ (⬜  t'))[t]

----------------------------- :: App_Unfoc1
(C ∘ (⬜  t'))[v] ⟶ C[v  t']

{{ NotVal [[t']] }} [[:NotValtp]]
----------------------------- :: App_Foc2
C[v  t'] ⟶ (C ∘ (v  ⬜))[t']

----------------------------- :: App_Unfoc2
(C ∘ (v  ⬜))[v'] ⟶ C[v  v']

------------------ :: App_Red
C[v  (ᵛλ x m ⟼ u) ] ⟶ C[u[x ≔ v] ]

{{ NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatU_Foc
C[t ; u] ⟶ (C ∘ (⬜ ; u))[t]

----------------------- :: PatU_Unfoc
(C ∘ (⬜ ; u))[v] ⟶ C[v ; u]

----------------------- :: PatU_Red
C[() ; u] ⟶ C[u]

{{ NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatS_Foc
C[t case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ (C ∘ (⬜ case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }))[t]

----------------------- :: PatS_Unfoc
(C ∘ (⬜ case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }))[v] ⟶ C[v case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }]

----------------------- :: PatL_Red
C[(Inl v1) case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u1[x1 ≔ v1] ]

----------------------- :: PatR_Red
C[(Inr v2) case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u2[x2 ≔ v2] ]

{{ NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatP_Foc
C[t case m (x1,x2) ⟼ u] ⟶ (C ∘ (⬜ case m (x1,x2) ⟼ u))[t]

----------------------- :: PatP_Unfoc
(C ∘ (⬜ case m (x1,x2) ⟼ u))[v] ⟶ C[v case m (x1,x2) ⟼ u]

----------------------- :: PatP_Red
C[(v1, v2) case m (x1,x2) ⟼ u] ⟶ C[u[x1 ≔ v1][x2 ≔ v2] ]

{{ NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatE_Foc
C[t case m ᴇ n x ⟼ u] ⟶ (C ∘ (⬜ case m ᴇ n x ⟼ u))[t]

----------------------- :: PatE_Unfoc
(C ∘ (⬜ case m ᴇ n x ⟼ u))[v] ⟶ C[v case m ᴇ n x ⟼ u]

----------------------- :: PatE_Red
C[ᴇ n v' case m ᴇ n x ⟼ u] ⟶ C[u[x ≔ v'] ]

{{ NotVal [[t]] }} [[:NotValt]]
----------------------- :: Map_Foc
C[t map x ⟼ t'] ⟶ (C ∘ (⬜ map x ⟼ t'))[t]

----------------------- :: Map_Unfoc
(C ∘ (⬜ map x ⟼ t'))[v] ⟶ C[v map x ⟼ t']

{{ [[h']] = [[max(hvars(C)) + 1]] }} [[:hpMaxC]]
---------------------------------- :: Map_Red_OpenAmpar_Foc
C[ H ⟨ v2 ❟ v1 ⟩ map x ⟼ t'] ⟶ (C ∘ (H⩲h' ᵒᵖ⟨ v2[H⩲h'] ❟ ⬜⟩))[ t'[x ≔ v1[H⩲h'] ] ]

---------------------------------- :: OpenAmpar_Unfoc
(C ∘ H ᵒᵖ⟨ v2 ❟ ⬜⟩)[v1] ⟶ C[ H ⟨ v2 ❟ v1 ⟩ ]

% -------------------------- :: Alloc_Red
% C[alloc] ⟶ C[{1} ⟨ +1 ❟ -1 ⟩]

{{ NotVal [[u]] }} [[:NotValu]]
-------------------------- :: ToA_Foc
C[to⧔ u] ⟶ (C ∘ (to⧔ ⬜))[u]

% No shape control here, so could be totally merged with ToA_Red
-------------------------- :: ToA_Unfoc
(C ∘ (to⧔ ⬜))[v2] ⟶ C[to⧔ v2]

----------------------------------------- :: ToA_Red
C[to⧔ v2] ⟶ C[{} ⟨ v2 ❟ () ⟩]

{{ NotVal [[t]] }} [[:NotValt]]
-------------------------- :: FromA_Foc
C[from⧔ t] ⟶ (C ∘ (from⧔ ⬜))[t]

-------------------------- :: FromA_Unfoc
(C ∘ (from⧔ ⬜))[v] ⟶ C[from⧔ v]

-------------------------------------- :: FromA_Red
C[from⧔ {} ⟨ v2 ❟ ᴇ ¹∞ v1 ⟩] ⟶ C[(v2, ᴇ ¹∞ v1)]

{{ NotVal [[t]] }} [[:NotValt]]
-------------------------- :: FillU_Foc
C[t ⨞ ()] ⟶ (C ∘ (⬜ ⨞ () ))[t]

-------------------------- :: FillU_Unfoc
(C ∘ (⬜ ⨞ () ))[v] ⟶ C[v ⨞ ()]

------------------------------------- :: FillU_Red
C[-h ⨞ ()] ⟶ C[h ≔ {} ()][()]

{{ NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillL_Foc
C[t ⨞ Inl] ⟶ (C ∘ (⬜ ⨞ Inl))[t]

------------------------------------- :: FillL_Unfoc
(C ∘ (⬜ ⨞ Inl))[v] ⟶ C[v ⨞ Inl]

{{ [[h']] = [[max(hvars(C) ∪ {h}) + 1]] }} [[:hpMaxCh]]
--------------------------------------- :: FillL_Red
C[-h ⨞ Inl] ⟶ C[h ≔ {h'+1} Inl  +(h'+1)][-(h'+1)]

{{ NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillR_Foc
C[t ⨞ Inr] ⟶ (C ∘ (⬜ ⨞ Inr))[t]

------------------------------------- :: FillR_Unfoc
(C ∘ (⬜ ⨞ Inr))[v] ⟶ C[v ⨞ Inr]

{{ [[h']] = [[max(hvars(C) ∪ {h}) + 1]] }} [[:hpMaxCh]]
--------------------------------------- :: FillR_Red
C[-h ⨞ Inr] ⟶ C[h ≔ {h'+1} Inr  +(h'+1)][-(h'+1)]

{{ NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillE_Foc
C[t ⨞ ᴇ m] ⟶ (C ∘ (⬜ ⨞ ᴇ m))[t]

------------------------------------- :: FillE_Unfoc
(C ∘ (⬜ ⨞ ᴇ m))[v] ⟶ C[v ⨞ ᴇ m]

{{ [[h']] = [[max(hvars(C) ∪ {h}) + 1]] }} [[:hpMaxCh]]
--------------------------------------- :: FillE_Red
C[-h ⨞ ᴇ m] ⟶ C[h ≔ {h'+1} ᴇ m  +(h'+1)][-(h'+1)]

{{ NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillP_Foc
C[t ⨞ (,)] ⟶ (C ∘ (⬜ ⨞ (,)))[t]

------------------------------------- :: FillP_Unfoc
(C ∘ (⬜ ⨞ (,)))[v] ⟶ C[v ⨞ (,)]

{{ [[h']] = [[max(hvars(C) ∪ {h}) + 1]] }} [[:hpMaxCh]]
--------------------------------------- :: FillP_Red
C[-h ⨞ (,)] ⟶ C[h ≔ {h'+1,h'+2} ( +(h'+1), +(h'+2))][( -(h'+1), -(h'+2) )]

{{ NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillF_Foc
C[t ⨞(λ x m ⟼ u)] ⟶ (C ∘ (⬜ ⨞(λ x m ⟼ u)))[t]

------------------------------------- :: FillF_Unfoc
(C ∘ (⬜ ⨞(λ x m ⟼ u)))[v] ⟶ C[v ⨞(λ x m ⟼ u)]

------------------------------------- :: FillF_Red
C[-h ⨞ (λ x m ⟼ u)] ⟶ C[h ≔ {} ᵛλ x m ⟼ u][()]

{{ NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillComp_Foc1
C[t ⨞· t'] ⟶ (C ∘ (⬜ ⨞· t'))[t]

------------------------------------- :: FillComp_Unfoc1
(C ∘ (⬜ ⨞· t'))[v] ⟶ C[v ⨞· t']

{{ NotVal [[t']] }} [[:NotValtp]]
------------------------------------- :: FillComp_Foc2
C[v ⨞· t'] ⟶ (C ∘ (v ⨞· ⬜))[t']

------------------------------------- :: FillComp_Unfoc2
(C ∘ (v ⨞· ⬜))[v'] ⟶ C[v ⨞· v']

{{ [[h']] = [[max(hvars(C) ∪ {h}) + 1]] }} [[:hpMaxCh]]
---------------------------------------- :: FillComp_Red
C[-h ⨞· H ⟨ v2 ❟ v1 ⟩] ⟶ C[h ≔ (H⩲h') v2[H⩲h'] ][v1[H⩲h'] ]
