defns
Ty :: '' ::=

defn
G â«¦ v : T :: :: TyR_val :: TyR_val_ {{ com Typing of values (raw) }} by

% We must track linearity precisely, but age for received value is arbitrary
--------------------- :: H
{ - h : T Â¹Î½ } â«¦ -h : T

{{ ctx_Compatible [[G]] [[+h : Â¹Î½ âŒŠTâŒ‹n]] }}
---------------- :: D
G â«¦ +h : âŒŠTâŒ‹n

--------------------- :: U
{} â«¦ () :ğŸ


% {{ mode_IsValid [[m]] }} : Probably we can relax that? Application will be impossible for such a function (as it would make the resulting context invalid), but it doesn't pose a problem per se
% {{ ctx_Disjoint [[D]] [[{ x : m T1 }]] }} : Redundant because ctx_DestOnly D => ctx_Disjoint D { x : m T1 }
% other rules don't need ctx_NoVar D as they cannot syntactically accept vars
{{ ctx_DestOnly [[D]] }} % Only says that we cannot have holes inside, as well as t cannot capture extra variables
D â¨„ { x : m T1 } âŠ¢ t : T2 [[:TYt]]
----------------- :: F
D â«¦ Î»áµ› x m âŸ¼ t : T1 m â†’ T2

G â«¦ v : T1 [[:TYRv]]
--------------------- :: L
G â«¦ Inl v : T1 â¨ T2

G â«¦ v : T2 [[:TYRv]]
--------------------- :: R
G â«¦ Inr v : T1 â¨ T2

G1 â«¦ v1 : T1 [[:TYRv1]]
G2 â«¦ v2 : T2 [[:TYRv2]]
------------------------- :: P
G1 â¨„ G2 â«¦ (v1, v2) : T1 â¨‚ T2

% we should augment age of holes which are below an exponential
G â«¦ v : T [[:TYRv]]
% {{ mode_IsValid [[n]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
--------------------- :: E
nÂ·G â«¦ á´‡ n v : ! n T

% We perform controls here on Ampar, and not on the other rules, because outside of the ampar, the hole/dests that are compensated will no longer be visible.
% ctx_DestOnly [[G2 â¨„ G3]] ensures that v2 is just made of dests, and with ctx_DestOnly [[G1]] in G1 â¨„ (-G3) â«¦ v1 : T1 we can conclude that v2 dests compensates at least all the holes from this ampar. This forbids <<(-h0, -h), +h>, +h0> which isn't constructible through alloc anyway.
% These more complex rules are made to allow this program, in which v2 is made of dests which are not exclusively from this ampar:
% alloc >map x0 |-> 
%     alloc >map x1 |->
%         let x2 = fromA (alloc >map xt |-> xt <| E â†‘ <|. (toA x0)) in
%         fromA ( alloc >map xt |-> xt <| (,) >case (xt1, xt2) |->
%                     xt1 <|. (toA x1) ; xt2 <|. (toA x2)
%               )
% We would have x2 = E â†‘ +h0, and res = < -h0, < -h1 , (+h1, E â†‘ +h0) > >
% If such a program typechecks, then we need the extra context G2 to v2 for dests coming from outside of this ampar (with ctx_DestOnly G2)
% We need to make sure that an ampar will bind as many holes as possible (i.e that holes and matching dests cannot escape respectively in G1 and G2) -> ensured by {{ ctx_DestOnly [[G1]] }}, as G1 and G2 cannot interact. So we no longer need ctx_Disjoint [[G1]] [[G2]]
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_DestOnly [[D3]] }}
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_Disjoint [[D1]] [[D3]] }}
{{ ctx_Disjoint [[D2]] [[D3]] }}
D1 â¨„ (-D3) â«¦ v1 : T1 [[:TYRv1]]
D2 â¨„ D3 â«¦ v2 : T2 [[:TYRv2]]
---------------- :: A
D1 â¨„ D2 â«¦ hnames(-D3) âŸ¨v1 âŸ v2âŸ© : T1 â§” T2

defn
P âŠ¢ t : T :: :: Ty_term :: Ty_term_ {{ com Typing of terms }} by

{{ ctx_DestOnly [[D]] }} % Functionnally equivalent as ctx_NoHole P as values cannot syntactically contains free variables
D â«¦ v : T
-------------------- :: Val
D âŠ¢ v : T

{{ ctx_Compatible [[P]] [[x : Â¹Î½ T]] }}
-------------------- :: Var
P âŠ¢ x : T

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
P1 âŠ¢ t : T1 [[:TYt]]
P2 âŠ¢ u : T1 m â†’ T2 [[:TYu]]
----------------- :: App
mÂ·P1 â¨„ P2 âŠ¢ t â‰» u : T2

P1 âŠ¢ t :ğŸ [[:TYt]]
P2 âŠ¢ u : U [[:TYu]]
----------------- :: PatU
P1 â¨„ P2 âŠ¢ t ; u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[P2]] [[{ x2 : m T2 }]] }}
P1 âŠ¢ t : T1 â¨ T2 [[:TYt]]
P2 â¨„ { x1 : m T1 } âŠ¢ u1 : U [[:TYu1]]
P2 â¨„ { x2 : m T2 } âŠ¢ u2 : U [[:TYu2]]
----------------- :: PatS
mÂ·P1 â¨„ P2 âŠ¢ t â‰»case m { Inl x1 âŸ¼ u1 , Inr x2 âŸ¼ u2 } : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[P2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }}
P1 âŠ¢ t : T1 â¨‚ T2 [[:TYt]]
P2 â¨„ { x1 : m T1, x2 : m T2 } âŠ¢ u : U [[:TYu]]
----------------- :: PatP
mÂ·P1 â¨„ P2 âŠ¢ t â‰»case m (x1 , x2) âŸ¼ u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x : mÂ·n T }]] }}
P1 âŠ¢ t : !n T [[:TYt]]
P2 â¨„ { x : mÂ·n T } âŠ¢ u : U [[:TYu]]
----------------- :: PatE
mÂ·P1 â¨„ P2 âŠ¢ t â‰»case m á´‡ n x âŸ¼ u : U

{{ ctx_Disjoint [[P2]] [[{ x : Â¹Î½ T2 }]] }}
P1 âŠ¢ t : T1 â§” T2 [[:TYt]]
Â¹â†‘Â·P2 â¨„ { x : Â¹Î½ T2 } âŠ¢ u : U [[:TYu]]
-------------------------------- :: Map
P1 â¨„ P2 âŠ¢ t â‰»map x âŸ¼ u : T1 â§” U

P âŠ¢ t : T [[:TYt]]
------------------------------- :: ToA
P âŠ¢ toâ§” t : T â§” ğŸ

P âŠ¢ t : T â§” ğŸ [[:TYt]]
------------------------------- :: FromA
P âŠ¢ fromâ§” t : T

-------------------------------- :: Alloc
{} âŠ¢ alloc : T â§” âŒŠTâŒ‹Â¹Î½

P âŠ¢ t : âŒŠğŸâŒ‹n [[:TYt]]
------------------------------ :: FillU
P âŠ¢ t â¨ () : ğŸ

{{ ctx_Disjoint [[P2]] [[{ x : m T1 }]] }}
P1 âŠ¢ t : âŒŠT1 m â†’ T2âŒ‹n [[:TYt]]
P2 â¨„ { x : m T1 } âŠ¢ u : T2 [[:TYu]]
---------------------------------------- :: FillF
P1 â¨„ (Â¹â†‘Â·n)Â·P2 âŠ¢ t â¨(Î» x m âŸ¼ u) : ğŸ

P âŠ¢ t : âŒŠT1 â¨ T2âŒ‹n [[:TYt]]
------------------------------ :: FillL
P âŠ¢ t â¨ Inl : âŒŠT1âŒ‹n

P âŠ¢ t : âŒŠT1 â¨ T2âŒ‹n [[:TYt]]
------------------------------ :: FillR
P âŠ¢ t â¨ Inr : âŒŠT2âŒ‹n

P âŠ¢ t : âŒŠT1 â¨‚ T2âŒ‹n [[:TYt]]
------------------------------ :: FillP
P âŠ¢ t â¨ (,) : âŒŠT1âŒ‹n â¨‚ âŒŠT2âŒ‹n

P âŠ¢ t : âŒŠ!n' TâŒ‹n [[:TYt]]
------------------------------ :: FillE
P âŠ¢ t â¨ á´‡ n' : âŒŠTâŒ‹n'Â·n

P1 âŠ¢ t : âŒŠT1âŒ‹n [[:TYt]]
P2 âŠ¢ u : T1 â§” T2 [[:TYu]]
----------------------------- :: FillC
P1 â¨„ (Â¹â†‘Â·n)Â·P2 âŠ¢ t â¨Â· u : T2

defn
D âŠ£ C : T1 â†£ T2 :: :: Ty_ectx :: TyR_ectx_ {{ com Typing of evaluation contexts }} {{ tex [[D]][[âŠ£]][[C]]:[[T1]]\ottstype{\rightarrowtail}[[T2]] }} by

% Idea : remove MultCond, but have a failable multiplication through good intercalation of ctx_minus and mult. This would work without fancy things with having dual modes for holes I think. Because ctx_minus will enforce linearity, so hole ctx multiplied by non-linear n could never be compensated (which is a good thing). But that would remove the ability to have 2 holes compensated by 1 omega dest.
% If we go with "product mode" solution then we cannot multiply by n blindly as it would contaminate  ; we need to ??

-------------------- :: Id
{} âŠ£ [] : U0 â†£ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
%{{ ctx_Empty [[D1]] \/ mode_IsLin [[m]] }} != {} => m = Â¹Î½
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
mÂ·D1 â¨„ D2 âŠ£ C : T2 â†£ U0 [[:TYC]]
D2 âŠ¢ u : T1 m â†’ T2 [[:TYu]]
----------------- :: App1
D1 âŠ£ C âˆ˜ ([] â‰» u) : T1 â†£ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
mÂ·D1 â¨„ D2 âŠ£ C : T2 â†£ U0 [[:TYC]]
D1 âŠ¢ v : T1 [[:TYv]]
----------------- :: App2
D2 âŠ£ C âˆ˜ (v â‰» []) : (T1 m â†’ T2) â†£ U0

{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
D1 â¨„ D2 âŠ£ C : U â†£ U0 [[:TYC]]
D2 âŠ¢ u : U [[:TYu]]
----------------- :: PatU
D1 âŠ£ C âˆ˜ ([] ; u) : ğŸ â†£ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = Â¹Î½
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_Disjoint [[D2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[D2]] [[{ x2 : m T2 }]] }}
mÂ·D1 â¨„ D2 âŠ£ C : U â†£ U0 [[:TYC]]
D2 â¨„ { x1 : m T1 } âŠ¢ u1 : U [[:TYu1]]
D2 â¨„ { x2 : m T2 } âŠ¢ u2 : U [[:TYu2]]
----------------- :: PatS
D1 âŠ£ C âˆ˜ ([] â‰»case m { Inl x1 âŸ¼ u1 , Inr x2 âŸ¼ u2 }) : (T1 â¨ T2) â†£ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = Â¹Î½
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_Disjoint [[D2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[D2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }}
mÂ·D1 â¨„ D2 âŠ£ C : U â†£ U0 [[:TYC]]
D2 â¨„ { x1 : m T1, x2 : m T2 } âŠ¢ u : U [[:TYu]]
----------------- :: PatP
D1 âŠ£ C âˆ˜ ([] â‰»case m (x1 , x2) âŸ¼ u) : (T1 â¨‚ T2) â†£ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = Â¹Î½
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_Disjoint [[D2]] [[{ x : mÂ·m' T }]] }}
mÂ·D1 â¨„ D2 âŠ£ C : U â†£ U0 [[:TYC]]
D2 â¨„ { x : mÂ·m' T } âŠ¢ u : U [[:TYu]]
----------------- :: PatE
D1 âŠ£ C âˆ˜ ([] â‰»case m á´‡ m' x âŸ¼ u) : ! m' T â†£ U0

{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_Disjoint [[Â¹â†‘Â·D2]] [[{ x : Â¹Î½ T2 }]] }}
D1 â¨„ D2 âŠ£ C : U â†£ U0 [[:TYC]]
Â¹â†‘Â·D2 â¨„ { x : Â¹Î½ T2 } âŠ¢ u : U [[:TYu]]
-------------------------------- :: Map
D1 âŠ£ C âˆ˜ ([] â‰»map x âŸ¼ u) : (T1 â§” T2) â†£ U0

D âŠ£ C : (T â§” ğŸ) â†£ U0 [[:TYC]]
------------------------------- :: ToA
D âŠ£ C âˆ˜ (toâ§” []) : T â†£ U0

D âŠ£ C : T â†£ U0 [[:TYC]]
------------------------------- :: FromA
D âŠ£ C âˆ˜ (fromâ§” []) : (T â§” ğŸ) â†£ U0

D âŠ£ C : ğŸ â†£ U0 [[:TYC]]
------------------------------ :: FillU
D âŠ£ C âˆ˜ ([] â¨ ()) : âŒŠğŸâŒ‹n â†£ U0

% Elements that can be compensated by u must be from an older scope
% Realistically dests are linear, so no dest from D2 can be stored in a non-linear function*
% D2 != {} => n = Â¹Î½
{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_Disjoint [[D2]] [[{ x : m T1 }]] }}
D1 â¨„ (Â¹â†‘Â·n)Â·D2 âŠ£ C : ğŸ â†£ U0 [[:TYC]]
D2 â¨„ { x : m T1 } âŠ¢ u : T2 [[:TYu]]
---------------------------------------- :: FillF
D1 âŠ£ C âˆ˜ ([] â¨(Î» x m âŸ¼ u)) : âŒŠT1 m â†’ T2âŒ‹n â†£ U0

D âŠ£ C : âŒŠT1âŒ‹n â†£ U0 [[:TYC]]
------------------------------ :: FillL
D âŠ£ C âˆ˜ ([] â¨ Inl) : âŒŠT1 â¨ T2âŒ‹n â†£ U0

D âŠ£ C : âŒŠT2âŒ‹n â†£ U0 [[:TYC]]
------------------------------ :: FillR
D âŠ£ C âˆ˜ ([] â¨ Inr) : âŒŠT1 â¨ T2âŒ‹n â†£ U0

D âŠ£ C : (âŒŠT1âŒ‹n â¨‚ âŒŠT2âŒ‹n) â†£ U0 [[:TYC]]
------------------------------ :: FillP
D âŠ£ C âˆ˜ ([] â¨ (,)) : âŒŠT1 â¨‚ T2âŒ‹n â†£ U0

D âŠ£ C : âŒŠTâŒ‹mÂ·n â†£ U0  [[:TYC]]
------------------------------ :: FillE
D âŠ£ C âˆ˜ ([] â¨ á´‡ m) : âŒŠ!m TâŒ‹n â†£ U0

{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
D1 â¨„ (Â¹â†‘Â·n)Â·D2 âŠ£ C : T2 â†£ U0 [[:TYC]]
D2 âŠ¢ u : T1 â§” T2 [[:TYu]]
----------------------------- :: FillC1
D1 âŠ£ C âˆ˜ ([] â¨Â· u) : âŒŠT1âŒ‹n â†£ U0

{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
D1 â¨„ (Â¹â†‘Â·n)Â·D2 âŠ£ C : T2 â†£ U0 [[:TYC]]
D1 âŠ¢ v : âŒŠT1âŒ‹n [[:TYu]]
----------------------------- :: FillC2
D2 âŠ£ C âˆ˜ (v â¨Â· []) : T1 â§” T2 â†£ U0

% -D2: Some holes of C compensated by dests from v1
% D1 : remaining holes/dests from C
% D1 : external dests from v1 (not bound by this ampar)
% -D3 : holes from v1 (bound by this ampar)
% We want D2 to be maximal, so D1 must be disjoint from D1
% We do not want to holes from v1 to be compensated by dests from C. That would mean having {positive part of D1} and -D3 to interact.
% {{ ctx_IsValid [[-(nÂ·D2)]] }} % TODO: check that ctx_minus enforces linearity+now

{{ ctx_Disjoint [[D1]] [[D2]] }}
{{ ctx_Disjoint [[D1]] [[D3]] }}
{{ hdns_Disjoint [[hnames(C)]] [[hnames(-D3)]] }} % No shadowing for hole bindings, even already compensated ones (which wouldn't be assured by ctx_Disjoint D2 D3). In particular, that predicate implies ctx_Disjoint D2 D3
{{ ctx_DestOnly [[D1]] }}
{{ ctx_DestOnly [[D2]] }}
{{ ctx_DestOnly [[D3]] }}
D1 â¨„ D2 âŠ£ C : (T1 â§” U) â†£ U0 [[:TYC]]
D1 â¨„ -D3 â«¦ v1 : T1 [[:TYRv1]]
---------------- :: AOpen
Â¹â†‘Â·D2 â¨„ D3 âŠ£ C âˆ˜ (hnames(-D3) áµ’áµ–âŸ¨v1 âŸ []) : U â†£ U0

defn
âŠ¢ C [ t ] : T :: :: Ty_eterm :: Ty_eterm_ {{ com Typing of extended terms (pair of evaluation context and term) }} by

G âŠ£ C : T â†£ U0 [[:TYRC]]
G âŠ¢ t : T [[:TYt]]
--------------------- :: ClosedEterm
âŠ¢ C[t] : U0

defns
Sem :: '' ::=

% TODO: add explicit focusing rules (stack way)

defn
C [ t ] âŸ¶ C' [ t' ] :: :: Sem_eterm :: Sem_eterm_ {{ com Small-step evaluation of terms using evaluation contexts }} by

------------------ :: App
C[v â‰» (Î»áµ› x m âŸ¼ t) ] âŸ¶ C[t[x â‰” v] ]

----------------------- :: PatU
C[() ; t2] âŸ¶ C[t2]

----------------------- :: PatL
C[(Inl v) â‰»case m { Inl x1 âŸ¼ u1, Inr x2 âŸ¼ u2 }] âŸ¶ C[u1[x â‰” v] ]

----------------------- :: PatR
C[(Inr v) â‰»case m { Inl x1 âŸ¼ u1, Inr x2 âŸ¼ u2 }] âŸ¶ C[u2[x â‰” v] ]

----------------------- :: PatP
C[(v1, v2) â‰»case m (x1,x2) âŸ¼ u] âŸ¶ C[u[x1 â‰” v1][x2 â‰” v2] ]

----------------------- :: PatE
C[á´‡ n v â‰»case m á´‡ n x âŸ¼ u] âŸ¶ C[u[x â‰” v] ]

{{ [[h']] = [[max(hnames(C))]] }}
---------------------------------- :: MapOpen
C[ H âŸ¨ v1 âŸ v2 âŸ© â‰»map x âŸ¼ u] âŸ¶ (C âˆ˜ (Hâ©²h' áµ’áµ–âŸ¨ v1â©²h' âŸ []))[ u[x â‰” v2â©²h'] ]

---------------------------------- :: MapClose
(C âˆ˜ H áµ’áµ–âŸ¨ v1 âŸ [])[v2] âŸ¶ C[ H âŸ¨ v1 âŸ v2 âŸ© ]

-------------------------- :: Alloc
C[alloc] âŸ¶ C[{1} âŸ¨ +1 âŸ -1 âŸ©]

----------------------------------------- :: ToA
C[toâ§” v] âŸ¶ C[{} âŸ¨ v âŸ () âŸ©]

-------------------------------------- :: FromA
C[fromâ§” {} âŸ¨ v âŸ () âŸ©] âŸ¶ C[v]

------------------------------------- :: FillU
C[+h â¨ ()] âŸ¶ C[h â‰” {} ()][()]

------------------------------------- :: FillF
C[+h â¨ (Î» x m âŸ¼ u)] âŸ¶ C[h â‰” {} Î»áµ› x m âŸ¼ u][()]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillL
C[+h â¨ Inl] âŸ¶ C[h â‰” {h'+1} Inl -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillR
C[+h â¨ Inr] âŸ¶ C[h â‰” {h'+1} Inr -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillE
C[+h â¨ á´‡ m] âŸ¶ C[h â‰” {h'+1} á´‡ m -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillP
C[+h â¨ (,)] âŸ¶ C[h â‰” {h'+1,h'+2} (-(h'+1),-(h'+2))][( +(h'+1), +(h'+2) )]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
---------------------------------------- :: FillC
C[+h â¨Â· H âŸ¨ v1 âŸ v2 âŸ©] âŸ¶ C[h â‰” (Hâ©²h') v1â©²h' ][v2â©²h' ]
