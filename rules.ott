defns
Ty :: '' ::=

defn
G â«¦ v : T :: :: TyR_val :: TyR_val_ {{ com Typing of values (raw) }} by

% We must track linearity precisely, but age for received value is arbitrary
--------------------- :: H
{ - h : T Â¹Î½ } â«¦ -h : T

{{ ctx_Compatible [[G]] [[+h : Â¹Î½ âŒŠTâŒ‹n]] }}
---------------- :: D
G â«¦ +h : âŒŠTâŒ‹n

--------------------- :: U
{} â«¦ () :ğŸ


% {{ mode_IsValid [[m]] }} : Probably we can relax that? Application will be impossible for such a function (as it would make the resulting context invalid), but it doesn't pose a problem per se
% {{ ctx_Disjoint [[G]] [[{ x : m T1 }]] }} : Redundant because ctx_DestOnly G => ctx_Disjoint G { x : m T1 }
% other rules don't need ctx_NoVar G as they cannot syntactically accept vars
{{ ctx_DestOnly [[G]] }} % Only says that we cannot have holes inside, as well as t cannot capture extra variables
G â¨„ { x : m T1 } âŠ¢ t : T2 [[:TYt]]
----------------- :: F
G â«¦ Î»áµ› x m âŸ¼ t : T1 m â†’ T2

G â«¦ v : T1 [[:TYRv]]
--------------------- :: L
G â«¦ Inl v : T1 â¨ T2

G â«¦ v : T2 [[:TYRv]]
--------------------- :: R
G â«¦ Inr v : T1 â¨ T2

G1 â«¦ v1 : T1 [[:TYRv1]]
G2 â«¦ v2 : T2 [[:TYRv2]]
------------------------- :: P
G1 â¨„ G2 â«¦ (v1, v2) : T1 â¨‚ T2

% we should augment age of holes which are below an exponential
G â«¦ v : T [[:TYRv]]
% {{ mode_IsValid [[n]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
--------------------- :: E
nÂ·G â«¦ á´‡ n v : ! n T

% We perform controls here on Ampar, and not on the other rules, because outside of the ampar, the hole/dests that are compensated will no longer be visible.
% ctx_DestOnly [[G2 â¨„ G3]] ensures that v2 is just made of dests, and with ctx_DestOnly [[G1]] in G1 â¨„ (-G3) â«¦ v1 : T1 we can conclude that v2 dests compensates at least all the holes from this ampar. This forbids <<(-h0, -h), +h>, +h0> which isn't constructible through alloc anyway.
% These more complex rules are made to allow this program, in which v2 is made of dests which are not exclusively from this ampar:
% alloc >map x0 |-> 
%     alloc >map x1 |->
%         let x2 = fromA (alloc >map xt |-> xt <| E â†‘ <|. (toA x0)) in
%         fromA ( alloc >map xt |-> xt <| (,) >case (xt1, xt2) |->
%                     xt1 <|. (toA x1) ; xt2 <|. (toA x2)
%               )
% We would have x2 = E â†‘ +h0, and res = < -h0, < -h1 , (+h1, E â†‘ +h0) > >
% If such a program typechecks, then we need the extra context G2 to v2 for dests coming from outside of this ampar (with ctx_DestOnly G2)
% We need to make sure that an ampar will bind as many holes as possible (i.e that holes and matching dests cannot escape respectively in G1 and G2) -> ensured by {{ ctx_DestOnly [[G1]] }}, as G1 and G2 cannot interact. So we no longer need ctx_Disjoint [[G1]] [[G2]]
{{ ctx_DestOnly [[G2 â¨„ G3]] }}
{{ ctx_DestOnly [[G1]] }}
G1 â¨„ (-G3) â«¦ v1 : T1 [[:TYRv1]]
G2 â¨„ G3 â«¦ v2 : T2 [[:TYRv2]]
---------------- :: A
G1 â¨„ G2 â«¦ hnames(-G3) âŸ¨v1 âŸ v2âŸ© : T1 â§” T2

defn
G âŠ¢ t : T :: :: Ty_term :: Ty_term_ {{ com Typing of terms }} by

{{ ctx_DestOnly [[G]] }} % Functionnally equivalent as ctx_NoHole G as values cannot syntactically contains free variables
G â«¦ v : T
-------------------- :: Val
G âŠ¢ v : T

{{ ctx_Compatible [[G]] [[x : Â¹Î½ T]] }}
-------------------- :: Var
G âŠ¢ x : T

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
G1 âŠ¢ t : T1 [[:TYt]]
G2 âŠ¢ u : T1 m â†’ T2 [[:TYu]]
----------------- :: App
mÂ·G1 â¨„ G2 âŠ¢ t â‰» u : T2

G1 âŠ¢ t :ğŸ [[:TYt]]
G2 âŠ¢ u : U [[:TYu]]
----------------- :: PatU
G1 â¨„ G2 âŠ¢ t ; u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G2]] [[{ x2 : m T2 }]] }}
G1 âŠ¢ t : T1 â¨ T2 [[:TYt]]
G2 â¨„ { x1 : m T1 } âŠ¢ u1 : U [[:TYu1]]
G2 â¨„ { x2 : m T2 } âŠ¢ u2 : U [[:TYu2]]
----------------- :: PatS
mÂ·G1 â¨„ G2 âŠ¢ t â‰»case m { Inl x1 âŸ¼ u1 , Inr x2 âŸ¼ u2 } : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }}
G1 âŠ¢ t : T1 â¨‚ T2 [[:TYt]]
G2 â¨„ { x1 : m T1, x2 : m T2 } âŠ¢ u : U [[:TYu]]
----------------- :: PatP
mÂ·G1 â¨„ G2 âŠ¢ t â‰»case m (x1 , x2) âŸ¼ u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x : mÂ·n T }]] }}
G1 âŠ¢ t : !n T [[:TYt]]
G2 â¨„ { x : mÂ·n T } âŠ¢ u : U [[:TYu]]
----------------- :: PatE
mÂ·G1 â¨„ G2 âŠ¢ t â‰»case m á´‡ n x âŸ¼ u : U

{{ ctx_Disjoint [[G2]] [[{ x : Â¹Î½ T2 }]] }}
G1 âŠ¢ t : T1 â§” T2 [[:TYt]]
Â¹â†‘Â·G2 â¨„ { x : Â¹Î½ T2 } âŠ¢ u : U [[:TYu]]
-------------------------------- :: Map
G1 â¨„ G2 âŠ¢ t â‰»map x âŸ¼ u : T1 â§” U

G âŠ¢ t : T [[:TYt]]
------------------------------- :: ToA
G âŠ¢ toâ§” t : T â§” ğŸ

G âŠ¢ t : T â§” ğŸ [[:TYt]]
------------------------------- :: FromA
G âŠ¢ fromâ§” t : T

-------------------------------- :: Alloc
{} âŠ¢ alloc : T â§” âŒŠTâŒ‹Â¹Î½

G âŠ¢ t : âŒŠğŸâŒ‹n [[:TYt]]
------------------------------ :: FillU
G âŠ¢ t â¨ () : ğŸ

{{ ctx_Disjoint [[G2]] [[{ x : m T1 }]] }}
G1 âŠ¢ t : âŒŠT1 m â†’ T2âŒ‹n [[:TYt]]
G2 â¨„ { x : m T1 } âŠ¢ u : T2 [[:TYu]]
---------------------------------------- :: FillF
G1 â¨„ (Â¹â†‘Â·n)Â·G2 âŠ¢ t â¨(Î» x m âŸ¼ u) : ğŸ

G âŠ¢ t : âŒŠT1 â¨ T2âŒ‹n [[:TYt]]
------------------------------ :: FillL
G âŠ¢ t â¨ Inl : âŒŠT1âŒ‹n

G âŠ¢ t : âŒŠT1 â¨ T2âŒ‹n [[:TYt]]
------------------------------ :: FillR
G âŠ¢ t â¨ Inr : âŒŠT2âŒ‹n

G âŠ¢ t : âŒŠT1 â¨‚ T2âŒ‹n [[:TYt]]
------------------------------ :: FillP
G âŠ¢ t â¨ (,) : âŒŠT1âŒ‹n â¨‚ âŒŠT2âŒ‹n

G âŠ¢ t : âŒŠ!n' TâŒ‹n [[:TYt]]
------------------------------ :: FillE
G âŠ¢ t â¨ á´‡ n' : âŒŠTâŒ‹n'Â·n

G1 âŠ¢ t : âŒŠT1âŒ‹n [[:TYt]]
G2 âŠ¢ u : T1 â§” T2 [[:TYu]]
----------------------------- :: FillC
G1 â¨„ (Â¹â†‘Â·n)Â·G2 âŠ¢ t â¨Â· u : T2

defn
G â«¦ C : T1 m â†£ T2 :: :: TyR_ectx :: TyR_ectx_ {{ com Typing of evaluation contexts }} {{ tex [[G]][[â«¦]][[C]]:[[T1]]_{[[m]]}\ottstype{\rightarrowtail}[[T2]] }} by

-------------------- :: Id
{} â«¦ [] : U0 â†£ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
-G0 â¨„ G1 â«¦ C : T2 â†£ U0 [[:TYRC]]
G1 != {} => m = Â¹Î½
G0 âŠ¢ u : T1 m â†’ T2 [[:TYu]]
----------------- :: App1
G1 â«¦ C âˆ˜ ([] â‰» u) : T1 â†£ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
-G0 â¨„ G1 â«¦ C : T2 â†£ U0 [[:TYRC]]
G0 âŠ¢ v : T1 [[:TYv]]
----------------- :: App2
G1 â«¦ C âˆ˜ (v â‰» []) : (T1 m â†’ T2) â†£ U0

{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
-G0 â¨„ G1 â«¦ C : U â†£ U0 [[:TYRC]]
G0 âŠ¢ u : U [[:TYu]]
----------------- :: PatU
G1 â«¦ C âˆ˜ ([] ; u) : ğŸ â†£ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
{{ ctx_Disjoint [[G0]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G0]] [[{ x2 : m T2 }]] }}
G1 != {} => m = Â¹Î½
-G0 â¨„ G1 â«¦ C : U â†£ U0 [[:TYRC]]
G0 â¨„ { x1 : m T1 } âŠ¢ u1 : U [[:TYu1]]
G0 â¨„ { x2 : m T2 } âŠ¢ u2 : U [[:TYu2]]
----------------- :: PatS
G1 â«¦ C âˆ˜ ([] â‰»case m { Inl x1 âŸ¼ u1 , Inr x2 âŸ¼ u2 }) : (T1 â¨ T2) â†£ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
{{ ctx_Disjoint [[G0]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G0]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }}
G1 != {} => m = Â¹Î½
-G0 â¨„ G1 â«¦ C : U â†£ U0 [[:TYRC]]
G0 â¨„ { x1 : m T1, x2 : m T2 } âŠ¢ u : U [[:TYu]]
----------------- :: PatP
G1 â«¦ C âˆ˜ ([] â‰»case m (x1 , x2) âŸ¼ u) : (T1 â¨‚ T2) â†£ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
{{ ctx_Disjoint [[G0]] [[{ x : mÂ·m' T }]] }}
G1 != {} => m = Â¹Î½
-G0 â¨„ G1 â«¦ C : U â†£ U0 [[:TYRC]]
G0 â¨„ { x : mÂ·m' T } âŠ¢ u : U [[:TYu]]
----------------- :: PatE
G1 â«¦ C âˆ˜ ([] â‰»case m á´‡ m' x âŸ¼ u) : ! m' T â†£ U0

%%% STOPPED HERE

{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}

{{ ctx_Disjoint [[Â¹â†‘Â·(G0 â¨„ G2)]] [[{ x : Â¹Î½ T2 }]] }}
-G0 â¨„ G1 â«¦ C : U n â†£ U0 [[:TYRC]]
Â¹â†‘Â·(G0 â¨„ G2) â¨„ { x : Â¹Î½ T2 } âŠ¢ u : U [[:TYu]]
-------------------------------- :: Map
G1 â¨„ nÂ·G2 â«¦ C âˆ˜ ([] â‰»map x âŸ¼ u) : (T1 â§” T2) n â†£ U0

G â«¦ C : (T â§” ğŸ) n â†£ U0 [[:TYRC]]
------------------------------- :: ToA
G â«¦ C âˆ˜ (toâ§” []) : T n â†£ U0

G â«¦ C : T n â†£ U0 [[:TYRC]]
------------------------------- :: FromA
G â«¦ C âˆ˜ (fromâ§” []) : (T â§” ğŸ) n â†£ U0

G â«¦ C : ğŸ n â†£ U0 [[:TYRC]]
------------------------------ :: FillU
G â«¦ C âˆ˜ ([] â¨ ()) : âŒŠğŸâŒ‹m' n â†£ U0

% Here we cannot have dest from u compensating for holes of C as any dest in u is morally one scope old(er). So ctx_IsValid -((Â¹â†‘Â·m'Â·n)Â·G0) is never true
{{ ctx_Disjoint [[G2]] [[{ x : m T1 }]] }}
G1 â«¦ C : ğŸ n â†£ U0 [[:TYRC]]
G2 â¨„ { x : m T1 } âŠ¢ u : T2 [[:TYu]]
---------------------------------------- :: FillF
G1 â¨„ (Â¹â†‘Â·m'Â·n)Â·G2 â«¦ C âˆ˜ ([] â¨(Î» x m âŸ¼ u)) : âŒŠT1 m â†’ T2âŒ‹m' n â†£ U0

G â«¦ C : âŒŠT1âŒ‹m' n â†£ U0 [[:TYRC]]
------------------------------ :: FillL
G â«¦ C âˆ˜ ([] â¨ Inl) : âŒŠT1 â¨ T2âŒ‹m' n â†£ U0

G â«¦ C : âŒŠT2âŒ‹m' n â†£ U0 [[:TYRC]]
------------------------------ :: FillR
G â«¦ C âˆ˜ ([] â¨ Inr) : âŒŠT1 â¨ T2âŒ‹m' n â†£ U0

G â«¦ C : (âŒŠT1âŒ‹m' â¨‚ âŒŠT2âŒ‹m') n â†£ U0 [[:TYRC]]
------------------------------ :: FillP
G â«¦ C âˆ˜ ([] â¨ (,)) : âŒŠT1 â¨‚ T2âŒ‹m' n â†£ U0

G â«¦ C : âŒŠTâŒ‹mÂ·m' n â†£ U0  [[:TYRC]]
------------------------------ :: FillE
G â«¦ C âˆ˜ ([] â¨ á´‡ m) : âŒŠ!m TâŒ‹m' n â†£ U0

% Here we cannot have dest from u compensating for holes of C as any dest in u is morally one scope old(er). So ctx_IsValid -((Â¹â†‘Â·m'Â·n)Â·G0) is never true
G1 â«¦ C : T2 n â†£ U0 [[:TYRC]]
G2 âŠ¢ u : T1 â§” T2 [[:TYu]]
----------------------------- :: FillC1
G1 â¨„ (Â¹â†‘Â·m'Â·n)Â·G2 â«¦ C âˆ˜ ([] â¨Â· u) : âŒŠT1âŒ‹m' n â†£ U0

% Here either we have G0 = {...}, G2 = empty, which means that v is a dest of a previous open ampar, or G0 = empty, G2 = {...} which means that v isn't bound by C
{{ ctx_DestOnly [[G0]] }}
-(nÂ·G0) â¨„ G1 â«¦ C : T2 n â†£ U0 [[:TYRC]]
G0 â¨„ G2 âŠ¢ v : âŒŠT1âŒ‹m' [[:TYu]]
----------------------------- :: FillC2
G1 â¨„ nÂ·G2 â«¦ C âˆ˜ (v â¨Â· []) : T1 â§” T2 (m'Â·n) â†£ U0

% -G0: Some holes of C compensated by dests from v1
% G : remaining holes/dests from C
% G1 : external dests from v1 (not bound by this ampar)
% -G3 : holes from v1 (bound by this ampar)
% We want G0 to be maximal, so G1 must be disjoint from G
% We do not want to holes from v1 to be compensated by dests from C. That would mean having {positive part of G} and -G3 to interact.
% {{ ctx_IsValid [[-(nÂ·G0)]] }} % TODO: check that ctx_minus enforces linearity+now
{{ ctx_DestOnly [[G0]] }}
{{ ctx_DestOnly [[G3]] }}
{{ hdns_Disjoint [[hnames(G3)]] [[hnames(C)]] }} % No shadowing for hole bindings
-(nÂ·G0) â¨„ G â«¦ C : (T1 â§” U) n â†£ U0 [[:TYRC]]
G0 â¨„ G1 â¨„ (-G3) â«¦ v1 : T1 [[:TYRv1]]
---------------- :: AOpen
G â¨„ nÂ·(G1 â¨„ (-G3)) â«¦ C âˆ˜ (hnames(-G3) áµ’áµ–âŸ¨v1 âŸ []) : U n â†£ U0

defn
âŠ¢ j : T :: :: Ty_eterm :: Ty_eterm_ {{ com Typing of extended terms (pair of evaluation context and term) }} by

-(nÂ·G) â«¦ C : T n â†£ U0 [[:TYRC]]
G âŠ¢ t : T [[:TYt]]
--------------------- :: ClosedEterm
âŠ¢ C[t] : U0

defns
Sem :: '' ::=

defn
j âŸ¶ j' :: :: Sem_eterm :: Sem_eterm_ {{ com Small-step evaluation of terms using evaluation contexts }} {{ tex [[j]]~\longrightarrow~[[j']] }} by

------------------ :: App
C[v â‰» (Î»áµ› x m âŸ¼ t) ] âŸ¶ C[t[x â‰” v] ]

----------------------- :: PatU
C[() ; t2] âŸ¶ C[t2]

----------------------- :: PatL
C[(Inl v) â‰»case m { Inl x1 âŸ¼ u1, Inr x2 âŸ¼ u2 }] âŸ¶ C[u1[x â‰” v] ]

----------------------- :: PatR
C[(Inr v) â‰»case m { Inl x1 âŸ¼ u1, Inr x2 âŸ¼ u2 }] âŸ¶ C[u2[x â‰” v] ]

----------------------- :: PatP
C[(v1, v2) â‰»case m (x1,x2) âŸ¼ u] âŸ¶ C[u[x1 â‰” v1][x2 â‰” v2] ]

----------------------- :: PatE
C[á´‡ n v â‰»case m á´‡ n x âŸ¼ u] âŸ¶ C[u[x â‰” v] ]

{{ [[h']] = [[max(hnames(C))]] }}
---------------------------------- :: MapOpen
C[ H âŸ¨ v1 âŸ v2 âŸ© â‰»map x âŸ¼ u] âŸ¶ (C âˆ˜ (Hâ©²h' áµ’áµ–âŸ¨ v1â©²h' âŸ []))[ u[x â‰” v2â©²h'] ]

---------------------------------- :: MapClose
(C âˆ˜ H áµ’áµ–âŸ¨ v1 âŸ [])[v2] âŸ¶ C[ H âŸ¨ v1 âŸ v2 âŸ© ]

-------------------------- :: Alloc
alloc âŸ¶ {1} âŸ¨ +1 âŸ -1 âŸ©

----------------------------------------- :: ToA
C[toâ§” v] âŸ¶ C[{} âŸ¨ v âŸ () âŸ©]

-------------------------------------- :: FromA
C[fromâ§” {} âŸ¨ v âŸ () âŸ©] âŸ¶ v

------------------------------------- :: FillU
C[+h â¨ ()] âŸ¶ C[h â‰” {} ()][()]

------------------------------------- :: FillF
C[+h â¨ (Î» x m âŸ¼ u)] âŸ¶ C[h â‰” {} Î»áµ› x m âŸ¼ u][()]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillL
C[+h â¨ Inl] âŸ¶ C[h â‰” {h'+1} Inl -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillR
C[+h â¨ Inr] âŸ¶ C[h â‰” {h'+1} Inr -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillE
C[+h â¨ á´‡ m] âŸ¶ C[h â‰” {h'+1} á´‡ m -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillP
C[+h â¨ (,)] âŸ¶ C[h â‰” {h'+1,h'+2} (-(h'+1),-(h'+2))][( +(h'+1), +(h'+2) )]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
---------------------------------------- :: FillC
C[+h â¨Â· H âŸ¨ v1 âŸ v2 âŸ©] âŸ¶ C[h â‰” (Hâ©²h') v1â©²h' ][v2â©²h' ]
