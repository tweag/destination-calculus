defns
Ty :: '' ::=

defn
G ⫦ v : T :: :: TyR_val :: TyR_val_ {{ com Typing of values (raw) }} by

% We must track linearity precisely, but age for received value is arbitrary
--------------------- :: H
{ - h : T ¹ν } ⫦ -h : T

{{ ctx_Compatible [[G]] [[+h : ¹ν ⌊T⌋n]] }}
---------------- :: D
G ⫦ +h : ⌊T⌋n

--------------------- :: U
{} ⫦ () :𝟏


% {{ mode_IsValid [[m]] }} : Probably we can relax that? Application will be impossible for such a function (as it would make the resulting context invalid), but it doesn't pose a problem per se
% {{ ctx_Disjoint [[G]] [[{ x : m T1 }]] }} : Redundant because ctx_DestOnly G => ctx_Disjoint G { x : m T1 }
% other rules don't need ctx_NoVar G as they cannot syntactically accept vars
{{ ctx_DestOnly [[G]] }} % Only says that we cannot have holes inside, as well as t cannot capture extra variables
G ⨄ { x : m T1 } ⊢ t : T2 [[:TYt]]
----------------- :: F
G ⫦ λᵛ x m ⟼ t : T1 m → T2

G ⫦ v : T1 [[:TYRv]]
--------------------- :: L
G ⫦ Inl v : T1 ⨁ T2

G ⫦ v : T2 [[:TYRv]]
--------------------- :: R
G ⫦ Inr v : T1 ⨁ T2

G1 ⫦ v1 : T1 [[:TYRv1]]
G2 ⫦ v2 : T2 [[:TYRv2]]
------------------------- :: P
G1 ⨄ G2 ⫦ (v1, v2) : T1 ⨂ T2

% we should augment age of holes which are below an exponential
G ⫦ v : T [[:TYRv]]
% {{ mode_IsValid [[n]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
--------------------- :: E
n·G ⫦ ᴇ n v : ! n T

% We perform controls here on Ampar, and not on the other rules, because outside of the ampar, the hole/dests that are compensated will no longer be visible.
% ctx_DestOnly [[G2 ⨄ G3]] ensures that v2 is just made of dests, and with ctx_DestOnly [[G1]] in G1 ⨄ (-G3) ⫦ v1 : T1 we can conclude that v2 dests compensates at least all the holes from this ampar. This forbids <<(-h0, -h), +h>, +h0> which isn't constructible through alloc anyway.
% These more complex rules are made to allow this program, in which v2 is made of dests which are not exclusively from this ampar:
% alloc >map x0 |-> 
%     alloc >map x1 |->
%         let x2 = fromA (alloc >map xt |-> xt <| E ↑ <|. (toA x0)) in
%         fromA ( alloc >map xt |-> xt <| (,) >case (xt1, xt2) |->
%                     xt1 <|. (toA x1) ; xt2 <|. (toA x2)
%               )
% We would have x2 = E ↑ +h0, and res = < -h0, < -h1 , (+h1, E ↑ +h0) > >
% If such a program typechecks, then we need the extra context G2 to v2 for dests coming from outside of this ampar (with ctx_DestOnly G2)
% We need to make sure that an ampar will bind as many holes as possible (i.e that holes and matching dests cannot escape respectively in G1 and G2) -> ensured by {{ ctx_DestOnly [[G1]] }}, as G1 and G2 cannot interact. So we no longer need ctx_Disjoint [[G1]] [[G2]]
{{ ctx_DestOnly [[G2 ⨄ G3]] }}
{{ ctx_DestOnly [[G1]] }}
G1 ⨄ (-G3) ⫦ v1 : T1 [[:TYRv1]]
G2 ⨄ G3 ⫦ v2 : T2 [[:TYRv2]]
---------------- :: A
G1 ⨄ G2 ⫦ hnames(-G3) ⟨v1 ❟ v2⟩ : T1 ⧔ T2

defn
G ⊢ t : T :: :: Ty_term :: Ty_term_ {{ com Typing of terms }} by

{{ ctx_DestOnly [[G]] }} % Functionnally equivalent as ctx_NoHole G as values cannot syntactically contains free variables
G ⫦ v : T
-------------------- :: Val
G ⊢ v : T

{{ ctx_Compatible [[G]] [[x : ¹ν T]] }}
-------------------- :: Var
G ⊢ x : T

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
G1 ⊢ t : T1 [[:TYt]]
G2 ⊢ u : T1 m → T2 [[:TYu]]
----------------- :: App
m·G1 ⨄ G2 ⊢ t ≻ u : T2

G1 ⊢ t :𝟏 [[:TYt]]
G2 ⊢ u : U [[:TYu]]
----------------- :: PatU
G1 ⨄ G2 ⊢ t ; u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G2]] [[{ x2 : m T2 }]] }}
G1 ⊢ t : T1 ⨁ T2 [[:TYt]]
G2 ⨄ { x1 : m T1 } ⊢ u1 : U [[:TYu1]]
G2 ⨄ { x2 : m T2 } ⊢ u2 : U [[:TYu2]]
----------------- :: PatS
m·G1 ⨄ G2 ⊢ t ≻case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }}
G1 ⊢ t : T1 ⨂ T2 [[:TYt]]
G2 ⨄ { x1 : m T1, x2 : m T2 } ⊢ u : U [[:TYu]]
----------------- :: PatP
m·G1 ⨄ G2 ⊢ t ≻case m (x1 , x2) ⟼ u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x : m·n T }]] }}
G1 ⊢ t : !n T [[:TYt]]
G2 ⨄ { x : m·n T } ⊢ u : U [[:TYu]]
----------------- :: PatE
m·G1 ⨄ G2 ⊢ t ≻case m ᴇ n x ⟼ u : U

{{ ctx_Disjoint [[G2]] [[{ x : ¹ν T2 }]] }}
G1 ⊢ t : T1 ⧔ T2 [[:TYt]]
¹↑·G2 ⨄ { x : ¹ν T2 } ⊢ u : U [[:TYu]]
-------------------------------- :: Map
G1 ⨄ G2 ⊢ t ≻map x ⟼ u : T1 ⧔ U

G ⊢ t : T [[:TYt]]
------------------------------- :: ToA
G ⊢ to⧔ t : T ⧔ 𝟏

G ⊢ t : T ⧔ 𝟏 [[:TYt]]
------------------------------- :: FromA
G ⊢ from⧔ t : T

-------------------------------- :: Alloc
{} ⊢ alloc : T ⧔ ⌊T⌋¹ν

G ⊢ t : ⌊𝟏⌋n [[:TYt]]
------------------------------ :: FillU
G ⊢ t ⨞ () : 𝟏

{{ ctx_Disjoint [[G2]] [[{ x : m T1 }]] }}
G1 ⊢ t : ⌊T1 m → T2⌋n [[:TYt]]
G2 ⨄ { x : m T1 } ⊢ u : T2 [[:TYu]]
---------------------------------------- :: FillF
G1 ⨄ (¹↑·n)·G2 ⊢ t ⨞(λ x m ⟼ u) : 𝟏

G ⊢ t : ⌊T1 ⨁ T2⌋n [[:TYt]]
------------------------------ :: FillL
G ⊢ t ⨞ Inl : ⌊T1⌋n

G ⊢ t : ⌊T1 ⨁ T2⌋n [[:TYt]]
------------------------------ :: FillR
G ⊢ t ⨞ Inr : ⌊T2⌋n

G ⊢ t : ⌊T1 ⨂ T2⌋n [[:TYt]]
------------------------------ :: FillP
G ⊢ t ⨞ (,) : ⌊T1⌋n ⨂ ⌊T2⌋n

G ⊢ t : ⌊!n' T⌋n [[:TYt]]
------------------------------ :: FillE
G ⊢ t ⨞ ᴇ n' : ⌊T⌋n'·n

G1 ⊢ t : ⌊T1⌋n [[:TYt]]
G2 ⊢ u : T1 ⧔ T2 [[:TYu]]
----------------------------- :: FillC
G1 ⨄ (¹↑·n)·G2 ⊢ t ⨞· u : T2

defn
G ⫦ C : T1 m ↣ T2 :: :: TyR_ectx :: TyR_ectx_ {{ com Typing of evaluation contexts }} {{ tex [[G]][[⫦]][[C]]:[[T1]]_{[[m]]}\ottstype{\rightarrowtail}[[T2]] }} by

-------------------- :: Id
{} ⫦ [] : U0 ↣ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
-G0 ⨄ G1 ⫦ C : T2 ↣ U0 [[:TYRC]]
G1 != {} => m = ¹ν
G0 ⊢ u : T1 m → T2 [[:TYu]]
----------------- :: App1
G1 ⫦ C ∘ ([] ≻ u) : T1 ↣ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
-G0 ⨄ G1 ⫦ C : T2 ↣ U0 [[:TYRC]]
G0 ⊢ v : T1 [[:TYv]]
----------------- :: App2
G1 ⫦ C ∘ (v ≻ []) : (T1 m → T2) ↣ U0

{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
-G0 ⨄ G1 ⫦ C : U ↣ U0 [[:TYRC]]
G0 ⊢ u : U [[:TYu]]
----------------- :: PatU
G1 ⫦ C ∘ ([] ; u) : 𝟏 ↣ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
{{ ctx_Disjoint [[G0]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G0]] [[{ x2 : m T2 }]] }}
G1 != {} => m = ¹ν
-G0 ⨄ G1 ⫦ C : U ↣ U0 [[:TYRC]]
G0 ⨄ { x1 : m T1 } ⊢ u1 : U [[:TYu1]]
G0 ⨄ { x2 : m T2 } ⊢ u2 : U [[:TYu2]]
----------------- :: PatS
G1 ⫦ C ∘ ([] ≻case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 }) : (T1 ⨁ T2) ↣ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
{{ ctx_Disjoint [[G0]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G0]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }}
G1 != {} => m = ¹ν
-G0 ⨄ G1 ⫦ C : U ↣ U0 [[:TYRC]]
G0 ⨄ { x1 : m T1, x2 : m T2 } ⊢ u : U [[:TYu]]
----------------- :: PatP
G1 ⫦ C ∘ ([] ≻case m (x1 , x2) ⟼ u) : (T1 ⨂ T2) ↣ U0

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}
{{ ctx_Disjoint [[G0]] [[{ x : m·m' T }]] }}
G1 != {} => m = ¹ν
-G0 ⨄ G1 ⫦ C : U ↣ U0 [[:TYRC]]
G0 ⨄ { x : m·m' T } ⊢ u : U [[:TYu]]
----------------- :: PatE
G1 ⫦ C ∘ ([] ≻case m ᴇ m' x ⟼ u) : ! m' T ↣ U0

%%% STOPPED HERE

{{ ctx_Disjoint [[G0]] [[G1]] }}
{{ ctx_DestOnly [[G0]] }}
{{ ctx_HoleOnly [[G1]] }}

{{ ctx_Disjoint [[¹↑·(G0 ⨄ G2)]] [[{ x : ¹ν T2 }]] }}
-G0 ⨄ G1 ⫦ C : U n ↣ U0 [[:TYRC]]
¹↑·(G0 ⨄ G2) ⨄ { x : ¹ν T2 } ⊢ u : U [[:TYu]]
-------------------------------- :: Map
G1 ⨄ n·G2 ⫦ C ∘ ([] ≻map x ⟼ u) : (T1 ⧔ T2) n ↣ U0

G ⫦ C : (T ⧔ 𝟏) n ↣ U0 [[:TYRC]]
------------------------------- :: ToA
G ⫦ C ∘ (to⧔ []) : T n ↣ U0

G ⫦ C : T n ↣ U0 [[:TYRC]]
------------------------------- :: FromA
G ⫦ C ∘ (from⧔ []) : (T ⧔ 𝟏) n ↣ U0

G ⫦ C : 𝟏 n ↣ U0 [[:TYRC]]
------------------------------ :: FillU
G ⫦ C ∘ ([] ⨞ ()) : ⌊𝟏⌋m' n ↣ U0

% Here we cannot have dest from u compensating for holes of C as any dest in u is morally one scope old(er). So ctx_IsValid -((¹↑·m'·n)·G0) is never true
{{ ctx_Disjoint [[G2]] [[{ x : m T1 }]] }}
G1 ⫦ C : 𝟏 n ↣ U0 [[:TYRC]]
G2 ⨄ { x : m T1 } ⊢ u : T2 [[:TYu]]
---------------------------------------- :: FillF
G1 ⨄ (¹↑·m'·n)·G2 ⫦ C ∘ ([] ⨞(λ x m ⟼ u)) : ⌊T1 m → T2⌋m' n ↣ U0

G ⫦ C : ⌊T1⌋m' n ↣ U0 [[:TYRC]]
------------------------------ :: FillL
G ⫦ C ∘ ([] ⨞ Inl) : ⌊T1 ⨁ T2⌋m' n ↣ U0

G ⫦ C : ⌊T2⌋m' n ↣ U0 [[:TYRC]]
------------------------------ :: FillR
G ⫦ C ∘ ([] ⨞ Inr) : ⌊T1 ⨁ T2⌋m' n ↣ U0

G ⫦ C : (⌊T1⌋m' ⨂ ⌊T2⌋m') n ↣ U0 [[:TYRC]]
------------------------------ :: FillP
G ⫦ C ∘ ([] ⨞ (,)) : ⌊T1 ⨂ T2⌋m' n ↣ U0

G ⫦ C : ⌊T⌋m·m' n ↣ U0  [[:TYRC]]
------------------------------ :: FillE
G ⫦ C ∘ ([] ⨞ ᴇ m) : ⌊!m T⌋m' n ↣ U0

% Here we cannot have dest from u compensating for holes of C as any dest in u is morally one scope old(er). So ctx_IsValid -((¹↑·m'·n)·G0) is never true
G1 ⫦ C : T2 n ↣ U0 [[:TYRC]]
G2 ⊢ u : T1 ⧔ T2 [[:TYu]]
----------------------------- :: FillC1
G1 ⨄ (¹↑·m'·n)·G2 ⫦ C ∘ ([] ⨞· u) : ⌊T1⌋m' n ↣ U0

% Here either we have G0 = {...}, G2 = empty, which means that v is a dest of a previous open ampar, or G0 = empty, G2 = {...} which means that v isn't bound by C
{{ ctx_DestOnly [[G0]] }}
-(n·G0) ⨄ G1 ⫦ C : T2 n ↣ U0 [[:TYRC]]
G0 ⨄ G2 ⊢ v : ⌊T1⌋m' [[:TYu]]
----------------------------- :: FillC2
G1 ⨄ n·G2 ⫦ C ∘ (v ⨞· []) : T1 ⧔ T2 (m'·n) ↣ U0

% -G0: Some holes of C compensated by dests from v1
% G : remaining holes/dests from C
% G1 : external dests from v1 (not bound by this ampar)
% -G3 : holes from v1 (bound by this ampar)
% We want G0 to be maximal, so G1 must be disjoint from G
% We do not want to holes from v1 to be compensated by dests from C. That would mean having {positive part of G} and -G3 to interact.
% {{ ctx_IsValid [[-(n·G0)]] }} % TODO: check that ctx_minus enforces linearity+now
{{ ctx_DestOnly [[G0]] }}
{{ ctx_DestOnly [[G3]] }}
{{ hdns_Disjoint [[hnames(G3)]] [[hnames(C)]] }} % No shadowing for hole bindings
-(n·G0) ⨄ G ⫦ C : (T1 ⧔ U) n ↣ U0 [[:TYRC]]
G0 ⨄ G1 ⨄ (-G3) ⫦ v1 : T1 [[:TYRv1]]
---------------- :: AOpen
G ⨄ n·(G1 ⨄ (-G3)) ⫦ C ∘ (hnames(-G3) ᵒᵖ⟨v1 ❟ []) : U n ↣ U0

defn
⊢ j : T :: :: Ty_eterm :: Ty_eterm_ {{ com Typing of extended terms (pair of evaluation context and term) }} by

-(n·G) ⫦ C : T n ↣ U0 [[:TYRC]]
G ⊢ t : T [[:TYt]]
--------------------- :: ClosedEterm
⊢ C[t] : U0

defns
Sem :: '' ::=

defn
j ⟶ j' :: :: Sem_eterm :: Sem_eterm_ {{ com Small-step evaluation of terms using evaluation contexts }} {{ tex [[j]]~\longrightarrow~[[j']] }} by

------------------ :: App
C[v ≻ (λᵛ x m ⟼ t) ] ⟶ C[t[x ≔ v] ]

----------------------- :: PatU
C[() ; t2] ⟶ C[t2]

----------------------- :: PatL
C[(Inl v) ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u1[x ≔ v] ]

----------------------- :: PatR
C[(Inr v) ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u2[x ≔ v] ]

----------------------- :: PatP
C[(v1, v2) ≻case m (x1,x2) ⟼ u] ⟶ C[u[x1 ≔ v1][x2 ≔ v2] ]

----------------------- :: PatE
C[ᴇ n v ≻case m ᴇ n x ⟼ u] ⟶ C[u[x ≔ v] ]

{{ [[h']] = [[max(hnames(C))]] }}
---------------------------------- :: MapOpen
C[ H ⟨ v1 ❟ v2 ⟩ ≻map x ⟼ u] ⟶ (C ∘ (H⩲h' ᵒᵖ⟨ v1⩲h' ❟ []))[ u[x ≔ v2⩲h'] ]

---------------------------------- :: MapClose
(C ∘ H ᵒᵖ⟨ v1 ❟ [])[v2] ⟶ C[ H ⟨ v1 ❟ v2 ⟩ ]

-------------------------- :: Alloc
alloc ⟶ {1} ⟨ +1 ❟ -1 ⟩

----------------------------------------- :: ToA
C[to⧔ v] ⟶ C[{} ⟨ v ❟ () ⟩]

-------------------------------------- :: FromA
C[from⧔ {} ⟨ v ❟ () ⟩] ⟶ v

------------------------------------- :: FillU
C[+h ⨞ ()] ⟶ C[h ≔ {} ()][()]

------------------------------------- :: FillF
C[+h ⨞ (λ x m ⟼ u)] ⟶ C[h ≔ {} λᵛ x m ⟼ u][()]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillL
C[+h ⨞ Inl] ⟶ C[h ≔ {h'+1} Inl -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillR
C[+h ⨞ Inr] ⟶ C[h ≔ {h'+1} Inr -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillE
C[+h ⨞ ᴇ m] ⟶ C[h ≔ {h'+1} ᴇ m -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
--------------------------------------- :: FillP
C[+h ⨞ (,)] ⟶ C[h ≔ {h'+1,h'+2} (-(h'+1),-(h'+2))][( +(h'+1), +(h'+2) )]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }}
---------------------------------------- :: FillC
C[+h ⨞· H ⟨ v1 ❟ v2 ⟩] ⟶ C[h ≔ (H⩲h') v1⩲h' ][v2⩲h' ]
