defns
Ty :: '' ::=

defn
G ⫦ v : T :: :: TyR_val :: TyR_val_ {{ com Typing of values (raw) }} by

% We must track linearity precisely, but age for received value is arbitrary
--------------------- :: H
{ -h : T ¹ν } ⫦ -h : T

{{ ctx_CompatibleDH [[G]] [[h]] [[₊ ¹ν ⌊T⌋n]] }} [[:CompatGh]]
---------------- :: D
G ⫦ +h : ⌊T⌋n

--------------------- :: U
{} ⫦ () :𝟏


% {{ mode_IsValid [[m]] }} [[:Validm]] : Probably we can relax that? Application will be impossible for such a function (as it would make the resulting context invalid), but it doesn't pose a problem per se
% {{ ctx_Disjoint [[D]] [[{ x : m T1 }]] }} : Redundant because ctx_DestOnly D => ctx_Disjoint D { x : m T1 }
% other rules don't need ctx_NoVar D as they cannot syntactically accept vars
{{ ctx_DestOnly [[D]] }} [[:DestOnlyD]] [[:DestOnlyD]] % Only says that we cannot have holes inside, as well as t cannot capture extra variables 
D ⨄ { x : m T } ⊢ u : U [[:Tyu]]
----------------- :: F
D ⫦ λᵛ x m ⟼ u : T m → U

G ⫦ v1 : T1 [[:TyRv1]]
--------------------- :: L
G ⫦ Inl v1 : T1 ⨁ T2

G ⫦ v2 : T2 [[:TyRv2]]
--------------------- :: R
G ⫦ Inr v2 : T1 ⨁ T2

G1 ⫦ v1 : T1 [[:TyRv1]]
G2 ⫦ v2 : T2 [[:TyRv2]]
------------------------- :: P
G1 ⨄ G2 ⫦ (v1, v2) : T1 ⨂ T2

% we should augment age of holes which are below an exponential
G ⫦ v' : T [[:TyRvp]]
% {{ mode_IsValid [[n]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
--------------------- :: E
n·G ⫦ ᴇ n v' : ! n T

% We perform controls here on Ampar, and not on the other rules, because outside of the ampar, the hole/dests that are compensated will no longer be visible.
% ctx_DestOnly [[G2 ⨄ G3]] ensures that v2 is just made of dests, and with ctx_DestOnly [[G1]] in G1 ⨄ (-G3) ⫦ v1 : T1 we can conclude that v2 dests compensates at least all the holes from this ampar. This forbids <<(-h0, -h), +h>, +h0> which isn't constructible through alloc anyway.
% These more complex rules are made to allow this program, in which v2 is made of dests which are not exclusively from this ampar:
% alloc >map x0 |-> 
%     alloc >map x1 |->
%         let x2 = fromA (alloc >map xt |-> xt <| E ↑ <|. (toA x0)) in
%         fromA ( alloc >map xt |-> xt <| (,) >case (xt1, xt2) |->
%                     xt1 <|. (toA x1) ; xt2 <|. (toA x2)
%               )
% We would have x2 = E ↑ +h0, and res = < -h0, < -h1 , (+h1, E ↑ +h0) > >
% If such a program typechecks, then we need the extra context G2 to v2 for dests coming from outside of this ampar (with ctx_DestOnly G2)
% We need to make sure that an ampar will bind as many holes as possible (i.e that holes and matching dests cannot escape respectively in G1 and G2) -> ensured by {{ ctx_DestOnly [[G1]] }}, as G1 and G2 cannot interact. So we no longer need ctx_Disjoint [[G1]] [[G2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_DestOnly [[D3]] }} [[:DestOnlyD3]]
{{ ctx_LinOnly [[D3]] }} [[:LinOnlyD3]]
{{ ctx_ValidOnly [[D3]] }} [[:ValidOnlyD3]]
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_Disjoint [[D1]] [[D3]] }} [[:DisjointD1D3]]
{{ ctx_Disjoint [[D2]] [[D3]] }} [[:DisjointD2D3]]
D1 ⨄ D3 ⫦ v1 : T [[:TyRv1]]
D2 ⨄ (-D3) ⫦ v2 : U [[:TyRv2]]
---------------- :: A
D1 ⨄ D2 ⫦ hnames(-D3) ⟨v2 ❟ v1⟩ : U ⧔ T

defn
P ⊢ t : T :: :: Ty_term :: Ty_term_ {{ com Typing of terms }} by

{{ ctx_DestOnly [[D]] }} [[:DestOnlyD]] % Functionnally equivalent as ctx_NoHole P as values cannot syntactically contains free variables
D ⫦ v : T [[:TyRv]]
-------------------- :: Val
D ⊢ v : T

{{ ctx_CompatibleVar [[P]] [[x]] [[ₓ ¹ν T]] }} [[:CompatPx]]
-------------------- :: Var
P ⊢ x : T

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
P1 ⊢ t : T [[:Tyt]]
P2 ⊢ t' : T m → U [[:Tytp]]
----------------- :: App
m·P1 ⨄ P2 ⊢ t ≻ t' : U

P1 ⊢ t : 𝟏 [[:Tyt]]
P2 ⊢ u : U [[:Tyu]]
----------------- :: PatU
P1 ⨄ P2 ⊢ t ; u : U

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x1 : m T1 }]] }} [[:DisjointP2x1]]
{{ ctx_Disjoint [[P2]] [[{ x2 : m T2 }]] }} [[:DisjointP2x2]]
P1 ⊢ t : T1 ⨁ T2 [[:Tyt]]
P2 ⨄ { x1 : m T1 } ⊢ u1 : U [[:Tyu1]]
P2 ⨄ { x2 : m T2 } ⊢ u2 : U [[:Tyu2]]
----------------- :: PatS
m·P1 ⨄ P2 ⊢ t ≻case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } : U

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x1 : m T1 }]] }} [[:DisjointP2x1]]
{{ ctx_Disjoint [[P2]] [[{ x2 : m T2 }]] }} [[:DisjointP2x2]]
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }} [[:Disjointx1x2]]
P1 ⊢ t : T1 ⨂ T2 [[:Tyt]]
P2 ⨄ { x1 : m T1 } ⨄ { x2 : m T2 } ⊢ u : U [[:Tyu]]
----------------- :: PatP
m·P1 ⨄ P2 ⊢ t ≻case m (x1 , x2) ⟼ u : U

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[P2]] [[{ x : m·n T }]] }} [[:DisjointP2x]]
P1 ⊢ t : !n T [[:Tyt]]
P2 ⨄ { x : m·n T } ⊢ u : U [[:Tyu]]
----------------- :: PatE
m·P1 ⨄ P2 ⊢ t ≻case m ᴇ n x ⟼ u : U

{{ ctx_Disjoint [[P2]] [[{ x : ¹ν T }]] }} [[:DisjointP2x]]
P1 ⊢ t : U ⧔ T [[:Tyt]]
¹↑·P2 ⨄ { x : ¹ν T } ⊢ t' : T' [[:Tytp]]
-------------------------------- :: Map
P1 ⨄ P2 ⊢ t ≻map x ⟼ t' : U ⧔ T'

P ⊢ u : U [[:Tyu]]
------------------------------- :: ToA
P ⊢ to⧔ u : U ⧔ 𝟏

P ⊢ t : U ⧔ 𝟏 [[:Tyt]]
------------------------------- :: FromA
P ⊢ from⧔ t : U

-------------------------------- :: Alloc
{} ⊢ alloc : U ⧔ ⌊U⌋¹ν

P ⊢ t : ⌊𝟏⌋n [[:Tyt]]
------------------------------ :: FillU
P ⊢ t ⨞ () : 𝟏

P ⊢ t : ⌊T1 ⨁ T2⌋n [[:Tyt]]
------------------------------ :: FillL
P ⊢ t ⨞ Inl : ⌊T1⌋n

P ⊢ t : ⌊T1 ⨁ T2⌋n [[:Tyt]]
------------------------------ :: FillR
P ⊢ t ⨞ Inr : ⌊T2⌋n

P ⊢ t : ⌊T1 ⨂ T2⌋n [[:Tyt]]
------------------------------ :: FillP
P ⊢ t ⨞ (,) : ⌊T1⌋n ⨂ ⌊T2⌋n

P ⊢ t : ⌊!n' T⌋n [[:Tyt]]
------------------------------ :: FillE
P ⊢ t ⨞ ᴇ n' : ⌊T⌋n'·n

{{ ctx_Disjoint [[P2]] [[{ x : m T }]] }} [[:DisjointP2x]]
P1 ⊢ t : ⌊T m → U⌋n [[:Tyt]]
P2 ⨄ { x : m T } ⊢ u : U [[:Tyu]]
---------------------------------------- :: FillF
P1 ⨄ (¹↑·n)·P2 ⊢ t ⨞(λ x m ⟼ u) : 𝟏

P1 ⊢ t : ⌊U⌋n [[:Tyt]]
P2 ⊢ t' : U ⧔ T [[:Tytp]]
----------------------------- :: FillC
P1 ⨄ (¹↑·n)·P2 ⊢ t ⨞· t' : T

defn
D ⊣ C : T ↣ U0 :: :: Ty_ectxs :: Ty_ectxs_ {{ com Typing of evaluation contexts }} {{ tex [[D]][[⊣]][[C]]:[[T]]\ottstype{\rightarrowtail}[[U0]] }} by

% Idea : remove MultCond, but have a failable multiplication through good intercalation of ctx_minus and mult. This would work without fancy things with having dual modes for holes I think. Because ctx_minus will enforce linearity, so hole ctx multiplied by non-linear n could never be compensated (which is a good thing). But that would remove the ability to have 2 holes compensated by 1 omega dest.
% If we go with "product mode" solution then we cannot multiply by n blindly as it would contaminate  ; we need to ??

-------------------- :: Id
{} ⊣ ⬜ : U0 ↣ U0

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
%{{ ctx_Empty [[D1]] \/ mode_IsLin [[m]] }} != {} => m = ¹ν
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ mode_IsValid [[m]] }} [[:Validm]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m·D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TyC]]
D2 ⊢ t' : T m → U [[:Tytp]]
----------------- :: AppFoc1
D1 ⊣ C ∘ (⬜ ≻ t') : T ↣ U0

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[m·D1]] }} [[:ValidmD1]]
m·D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TyC]]
D1 ⊢ v : T [[:Tyv]]
----------------- :: AppFoc2
D2 ⊣ C ∘ (v ≻ ⬜) : (T m → U) ↣ U0

{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TyC]]
D2 ⊢ u : U [[:Tyu]]
----------------- :: PatUFoc
D1 ⊣ C ∘ (⬜ ; u) : 𝟏 ↣ U0

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = ¹ν
% {{ ctx_Disjoint [[D2]] [[{ x1 : m T1 }]] }} useless with DestOnly
% {{ ctx_Disjoint [[D2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ mode_IsValid [[m]] }} [[:Validm]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m·D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TyC]]
D2 ⨄ { x1 : m T1 } ⊢ u1 : U [[:Tyu1]]
D2 ⨄ { x2 : m T2 } ⊢ u2 : U [[:Tyu2]]
----------------- :: PatSFoc
D1 ⊣ C ∘ (⬜ ≻case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 }) : (T1 ⨁ T2) ↣ U0

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = ¹ν
% {{ ctx_Disjoint [[D2]] [[{ x1 : m T1 }]] }} useless with DestOnly
% {{ ctx_Disjoint [[D2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }} [[:Disjointx1x2]]
{{ mode_IsValid [[m]] }} [[:Validm]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m·D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TyC]]
D2 ⨄ { x1 : m T1 } ⨄ { x2 : m T2 } ⊢ u : U [[:Tyu]]
----------------- :: PatPFoc
D1 ⊣ C ∘ (⬜ ≻case m (x1 , x2) ⟼ u) : (T1 ⨂ T2) ↣ U0

% {{ mode_IsValid [[m]] }} [[:Validm]] : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
% D1 != {} => m = ¹ν
% {{ ctx_Disjoint [[D2]] [[{ x : m·m' T }]] }} useless with DestOnly
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ mode_IsValid [[m]] }} [[:Validm]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
m·D1 ⨄ D2 ⊣ C : U ↣ U0 [[:TyC]]
D2 ⨄ { x : m·m' T } ⊢ u : U [[:Tyu]]
----------------- :: PatEFoc
D1 ⊣ C ∘ (⬜ ≻case m ᴇ m' x ⟼ u) : ! m' T ↣ U0

% {{ ctx_Disjoint [[¹↑·D2]] [[{ x : ¹ν T2 }]] }} useless with DestOnly
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[D2]] }} [[:ValidOnlyD2]]
D1 ⨄ D2 ⊣ C : U ⧔ T' ↣ U0 [[:TyC]]
¹↑·D2 ⨄ { x : ¹ν T } ⊢ t' : T' [[:Tytp]]
-------------------------------- :: MapFoc
D1 ⊣ C ∘ (⬜ ≻map x ⟼ t') : (U ⧔ T) ↣ U0

D ⊣ C : (U ⧔ 𝟏) ↣ U0 [[:TyC]]
------------------------------- :: ToAFoc
D ⊣ C ∘ (to⧔ ⬜) : U ↣ U0

D ⊣ C : U ↣ U0 [[:TyC]]
------------------------------- :: FromAFoc
D ⊣ C ∘ (from⧔ ⬜) : (U ⧔ 𝟏) ↣ U0

D ⊣ C : 𝟏 ↣ U0 [[:TyC]]
------------------------------ :: FillUFoc
D ⊣ C ∘ (⬜ ⨞ ()) : ⌊𝟏⌋n ↣ U0

D ⊣ C : ⌊T1⌋n ↣ U0 [[:TyC]]
------------------------------ :: FillLFoc
D ⊣ C ∘ (⬜ ⨞ Inl) : ⌊T1 ⨁ T2⌋n ↣ U0

D ⊣ C : ⌊T2⌋n ↣ U0 [[:TyC]]
------------------------------ :: FillRFoc
D ⊣ C ∘ (⬜ ⨞ Inr) : ⌊T1 ⨁ T2⌋n ↣ U0

D ⊣ C : (⌊T1⌋n ⨂ ⌊T2⌋n) ↣ U0 [[:TyC]]
------------------------------ :: FillPFoc
D ⊣ C ∘ (⬜ ⨞ (,)) : ⌊T1 ⨂ T2⌋n ↣ U0

D ⊣ C : ⌊T⌋m·n ↣ U0 [[:TyC]]
------------------------------ :: FillEFoc
D ⊣ C ∘ (⬜ ⨞ ᴇ m) : ⌊!m T⌋n ↣ U0

% Elements that can be compensated by u must be from an older scope
% Realistically dests are linear, so no dest from D2 can be stored in a non-linear function*
% D2 != {} => n = ¹ν
% {{ ctx_Disjoint [[D2]] [[{ x : m T1 }]] }} useless with DestOnly
{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[(¹↑·n)·D2]] }} [[:ValidsnD2]]
D1 ⨄ (¹↑·n)·D2 ⊣ C : 𝟏 ↣ U0 [[:TyC]]
D2 ⨄ { x : m T } ⊢ u : U [[:Tyu]]
---------------------------------------- :: FillFFoc
D1 ⊣ C ∘ (⬜ ⨞(λ x m ⟼ u)) : ⌊T m → U⌋n ↣ U0

{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[(¹↑·n)·D2]] }} [[:ValidsnD2]]
D1 ⨄ (¹↑·n)·D2 ⊣ C : T ↣ U0 [[:TyC]]
D2 ⊢ t' : U ⧔ T [[:Tytp]]
----------------------------- :: FillCFoc1
D1 ⊣ C ∘ (⬜ ⨞· t') : ⌊U⌋n ↣ U0

{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjointD1D2]]
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_ValidOnly [[D1]] }} [[:ValidsnD1]]
{{ mode_IsValid [[(¹↑·n)]] }} [[:Validsn]]
D1 ⨄ (¹↑·n)·D2 ⊣ C : T ↣ U0 [[:TyC]]
D1 ⊢ v : ⌊U⌋n [[:Tyt]]
----------------------------- :: FillCFoc2
D2 ⊣ C ∘ (v ⨞· ⬜) : U ⧔ T ↣ U0

% TODO: check that ctx_minus enforces linearity+now

{{ ctx_Disjoint [[D1]] [[D2]] }} [[:DisjoinD1D2]]
{{ ctx_Disjoint [[D1]] [[D3]] }} [[:DisjoinD1D3]]
{{ hdns_Disjoint [[hnames(C)]] [[hnames(-D3)]] }} [[:HDisjointCD3]] % No shadowing for hole bindings, even already compensated ones (which wouldn't be assured by ctx_Disjoint D2 D3). In particular, that predicate implies ctx_Disjoint D2 D3
{{ ctx_DestOnly [[D1]] }} [[:DestOnlyD1]]
{{ ctx_DestOnly [[D2]] }} [[:DestOnlyD2]]
{{ ctx_DestOnly [[D3]] }} [[:DestOnlyD3]]
{{ ctx_LinOnly [[D3]] }} [[:LinOnlyD3]]
{{ ctx_ValidOnly [[D1]] }} [[:ValidOnlyD1]]
D1 ⨄ D2 ⊣ C : (U ⧔ T') ↣ U0 [[:TyC]]
D2 ⨄ -D3 ⫦ v2 : U [[:TyRv2]]
---------------- :: AOpenFoc
¹↑·D1 ⨄ D3 ⊣ C ∘ (hnames(-D3) ᵒᵖ⟨v2 ❟ ⬜) : T' ↣ U0

defn
⊢ C [ t ] : T :: :: Ty_eterm :: Ty_eterm_ {{ com Typing of extended terms (pair of evaluation context and term) }} by

{{ ctx_ValidOnly [[D]] }} [[:ValidOnlyD]]
{{ ctx_DestOnly [[D]] }} [[:DestOnlyD]]
D ⊣ C : T ↣ U0 [[:TyC]]
D ⊢ t : T [[:Tyt]]
--------------------- :: ClosedEterm
⊢ C[t] : U0

defns
Sem :: '' ::=

% If ectx composition is not a meta instruction but a syntactic rule for context formation, then all unfoc rules can be merged as a single "pop & reform term" instruction ?
% Not really for AOpenUnfoc because it is transformed back to a closed ampar instead of just being ectx substitution.

% We want theorem that C[t] -->* C[v] where englobing context doesn't change?

defn
C [ t ] ⟶ C' [ t' ] :: :: Sem_eterm :: Sem_eterm_ {{ com Small-step evaluation of terms using evaluation contexts }} by

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------------- :: AppFoc1
C[t ≻ t'] ⟶ (C ∘ (⬜ ≻ t'))[t]

----------------------------- :: AppUnfoc1
(C ∘ (⬜ ≻ t'))[v] ⟶ C[v ≻ t']

{{ term_NotVal [[t']] }} [[:NotValtp]]
----------------------------- :: AppFoc2
C[v ≻ t'] ⟶ (C ∘ (v ≻ ⬜))[t']

----------------------------- :: AppUnfoc2
(C ∘ (v ≻ ⬜))[v'] ⟶ C[v ≻ v']

------------------ :: AppRed
C[v ≻ (λᵛ x m ⟼ u) ] ⟶ C[u[x ≔ v] ]

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatUFoc
C[t ; u] ⟶ (C ∘ (⬜ ; u))[t]

----------------------- :: PatUUnfoc
(C ∘ (⬜ ; u))[v] ⟶ C[v ; u]

----------------------- :: PatURed
C[() ; u] ⟶ C[u]

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatSFoc
C[t ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ (C ∘ (⬜ ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }))[t]

----------------------- :: PatSUnfoc
(C ∘ (⬜ ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }))[v] ⟶ C[v ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }]

----------------------- :: PatLRed
C[(Inl v1) ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u1[x1 ≔ v1] ]

----------------------- :: PatRRed
C[(Inr v2) ≻case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u2[x2 ≔ v2] ]

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatPFoc
C[t ≻case m (x1,x2) ⟼ u] ⟶ (C ∘ (⬜ ≻case m (x1,x2) ⟼ u))[t]

----------------------- :: PatPUnfoc
(C ∘ (⬜ ≻case m (x1,x2) ⟼ u))[v] ⟶ C[v ≻case m (x1,x2) ⟼ u]

----------------------- :: PatPRed
C[(v1, v2) ≻case m (x1,x2) ⟼ u] ⟶ C[u[x1 ≔ v1][x2 ≔ v2] ]

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------- :: PatEFoc
C[t ≻case m ᴇ n x ⟼ u] ⟶ (C ∘ (⬜ ≻case m ᴇ n x ⟼ u))[t]

----------------------- :: PatEUnfoc
(C ∘ (⬜ ≻case m ᴇ n x ⟼ u))[v] ⟶ C[v ≻case m ᴇ n x ⟼ u]

----------------------- :: PatERed
C[ᴇ n v' ≻case m ᴇ n x ⟼ u] ⟶ C[u[x ≔ v'] ]

{{ term_NotVal [[t]] }} [[:NotValt]]
----------------------- :: MapFoc
C[t ≻map x ⟼ t'] ⟶ (C ∘ (⬜ ≻map x ⟼ t'))[t]

----------------------- :: MapUnfoc
(C ∘ (⬜ ≻map x ⟼ t'))[v] ⟶ C[v ≻map x ⟼ t']

{{ [[h']] = [[max(hnames(C))]] }} [[:hpMaxC]]
---------------------------------- :: MapRedAOpenFoc
C[ H ⟨ v2 ❟ v1 ⟩ ≻map x ⟼ t'] ⟶ (C ∘ (H⩲h' ᵒᵖ⟨ v2⩲h' ❟ ⬜))[ t'[x ≔ v1⩲h'] ]

---------------------------------- :: AOpenUnfoc
(C ∘ H ᵒᵖ⟨ v2 ❟ ⬜)[v1] ⟶ C[ H ⟨ v2 ❟ v1 ⟩ ]

-------------------------- :: AllocRed
C[alloc] ⟶ C[{1} ⟨ +1 ❟ -1 ⟩]

{{ term_NotVal [[u]] }} [[:NotValu]]
-------------------------- :: ToAFoc
C[to⧔ u] ⟶ (C ∘ (to⧔ ⬜))[u]

% No shape control here, so could be totally merged with ToARed
-------------------------- :: ToAUnfoc
(C ∘ (to⧔ ⬜))[v2] ⟶ C[to⧔ v2]

----------------------------------------- :: ToARed
C[to⧔ v2] ⟶ C[{} ⟨ v2 ❟ () ⟩]

{{ term_NotVal [[t]] }} [[:NotValt]]
-------------------------- :: FromAFoc
C[from⧔ t] ⟶ (C ∘ (from⧔ ⬜))[t]

-------------------------- :: FromAUnfoc
(C ∘ (from⧔ ⬜))[v] ⟶ C[from⧔ v]

-------------------------------------- :: FromARed
C[from⧔ {} ⟨ v2 ❟ () ⟩] ⟶ C[v2]

{{ term_NotVal [[t]] }} [[:NotValt]]
-------------------------- :: FillUFoc
C[t ⨞ ()] ⟶ (C ∘ (⬜ ⨞ () ))[t]

-------------------------- :: FillUUnfoc
(C ∘ (⬜ ⨞ () ))[v] ⟶ C[v ⨞ ()]

------------------------------------- :: FillURed
C[+h ⨞ ()] ⟶ C[h ≔ {} ()][()]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillLFoc
C[t ⨞ Inl] ⟶ (C ∘ (⬜ ⨞ Inl))[t]

------------------------------------- :: FillLUnfoc
(C ∘ (⬜ ⨞ Inl))[v] ⟶ C[v ⨞ Inl]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }} [[:hpMaxCh]]
--------------------------------------- :: FillLRed
C[+h ⨞ Inl] ⟶ C[h ≔ {h'+1} Inl -(h'+1)][+(h'+1)]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillRFoc
C[t ⨞ Inr] ⟶ (C ∘ (⬜ ⨞ Inr))[t]

------------------------------------- :: FillRUnfoc
(C ∘ (⬜ ⨞ Inr))[v] ⟶ C[v ⨞ Inr]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }} [[:hpMaxCh]]
--------------------------------------- :: FillRRed
C[+h ⨞ Inr] ⟶ C[h ≔ {h'+1} Inr -(h'+1)][+(h'+1)]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillEFoc
C[t ⨞ ᴇ m] ⟶ (C ∘ (⬜ ⨞ ᴇ m))[t]

------------------------------------- :: FillEUnfoc
(C ∘ (⬜ ⨞ ᴇ m))[v] ⟶ C[v ⨞ ᴇ m]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }} [[:hpMaxCh]]
--------------------------------------- :: FillERed
C[+h ⨞ ᴇ m] ⟶ C[h ≔ {h'+1} ᴇ m -(h'+1)][+(h'+1)]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillPFoc
C[t ⨞ (,)] ⟶ (C ∘ (⬜ ⨞ (,)))[t]

------------------------------------- :: FillPUnfoc
(C ∘ (⬜ ⨞ (,)))[v] ⟶ C[v ⨞ (,)]

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }} [[:hpMaxCh]]
--------------------------------------- :: FillPRed
C[+h ⨞ (,)] ⟶ C[h ≔ {h'+1,h'+2} (-(h'+1),-(h'+2))][( +(h'+1), +(h'+2) )]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillFFoc
C[t ⨞(λ x m ⟼ u)] ⟶ (C ∘ (⬜ ⨞(λ x m ⟼ u)))[t]

------------------------------------- :: FillFUnfoc
(C ∘ (⬜ ⨞(λ x m ⟼ u)))[v] ⟶ C[v ⨞(λ x m ⟼ u)]

------------------------------------- :: FillFRed
C[+h ⨞ (λ x m ⟼ u)] ⟶ C[h ≔ {} λᵛ x m ⟼ u][()]

{{ term_NotVal [[t]] }} [[:NotValt]]
------------------------------------- :: FillCFoc1
C[t ⨞· t'] ⟶ (C ∘ (⬜ ⨞· t'))[t]

------------------------------------- :: FillCUnfoc1
(C ∘ (⬜ ⨞· t'))[v] ⟶ C[v ⨞· t']

{{ term_NotVal [[t']] }} [[:NotValtp]]
------------------------------------- :: FillCFoc2
C[v ⨞· t'] ⟶ (C ∘ (v ⨞· ⬜))[t']

------------------------------------- :: FillCUnfoc2
(C ∘ (v ⨞· ⬜))[v'] ⟶ C[v ⨞· v']

{{ [[h']] = [[max(hnames(C) ∪ {h})]] }} [[:hpMaxCh]]
---------------------------------------- :: FillCRed
C[+h ⨞· H ⟨ v2 ❟ v1 ⟩] ⟶ C[h ≔ (H⩲h') v2⩲h' ][v1⩲h' ]
