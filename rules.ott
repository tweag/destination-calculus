defns
Ty :: '' ::=

% Tout trou créé doit apparaître soit comme dest dans le terme, soit être rempli par un effet suivant

defn
C1 ## C2 :: :: C_D :: C_D_ {{ tex [[dom]]([[C1]]) \cap [[dom]]([[C2]]) = \emptyset }} by
defn
h notin dom ( C ) :: :: C_NI :: C_NI_ {{ tex [[h]] \notin [[dom]]([[C]]) }} by
defn
destOnly G :: :: PC_DO :: PC_DO_ by
defn
fresh h :: :: C_FH :: C_FH_ by

defn
G u D ||- e :: :: Ty_e :: Ty_e_ {{ com Typing of effects (require both positive and negative contexts) }} by

-------------- :: N
{} u {} ||- o

G u D ||- w : T
G ## {@h : m |T|n}
G ## D
{@h : m |T|n} ## D
------------------- :: A
(1.m.n).G µ {@h : m |T|n} u (m.n).D ||- h := w

G1 u D1 µ -G22 ||- e1
G21 µ G22 u D2 ||- e2
G1 ## G21
G1 ## G22
G1 ## D1
G1 ## D2
G21 ## G22
G21 ## D1
G21 ## D2
G22 ## D1
G22 ## D2
D1 ## D2
------------------------- :: P
G1 µ G21 u D1 µ D2 ||- e1, e2

defn
G |- v <> e : T :: :: Ty_c :: Ty_c_ {{ com Typing of commands (only a positive context is needed) }} by

G11 µ G12 |- v : T
G2 u -G12 ||- e
G11 ## G12
G11 ## G2
G12 ## G2
------------------ :: C
G11 µ G2 |- v <> e : T


defn
G u D ||- w : T :: :: Ty_w :: Ty_w_ {{ com Typing of extended values (require both positive and negative contexts) }} by

--------------------- :: H
{} u { h : 0 T } ||- h : T

---------------- :: D
{ @h : 0 |T|n } u {} ||- @h : |T|n

--------------------- :: U
{} u {} ||- () : I

G u D ||- w : T1
G ## D
--------------------- :: L
G u D ||- Inl w : T1 + T2

G u D ||- w : T2
G ## D
--------------------- :: R
G u D ||- Inr w : T1 + T2

G1 u D1 ||- w1 : T1
G2 u D2 ||- w2 : T2
G1 ## G2
G1 ## D1
G1 ## D2
G2 ## D1
G2 ## D2
D1 ## D2
------------------------- :: P
G1 µ G2 u D1 µ D2 ||- (w1, w2) : T1 * T2

% TODO: should we augment age of holes which are below an exponential?
% TODO: yes so that they match their destination mode?
G u D ||- w : T
G ## D
--------------------- :: E
m.G u m.D ||- exp m w : ! m T

G1 u {} ||- v1 : T1
G2 u -G1 ||- w2 : T2
G1 ## G2
---------------- :: A
G2 u {} ||- <v1 ¤ w2> -G1 : T1 ><| T2

G µ { x : m T1 } |- t : T2
G ## { x : m T1 }
----------------- :: F
G u {} ||- \x -> t : T1 m -> T2

defn
G |- t : T :: :: Ty_t :: Ty_t_ {{ com Typing of terms (only a positive context is needed) }} by

G u {} ||- v : T
----------------- :: V
G |- v : T

-------------------- :: X0
{ x : 0 T } |- x : T

-------------------- :: XInf
{ x : Inf T } |- x : T

G1 |- t : T1
G2 |- u : T1 m -> T2
G1 ## G2
----------------- :: App
m.G1 µ G2 |- t & u : T2

G1 |- t : I
G2 |- u : U
G1 ## G2
----------------- :: PatU
G1 µ G2 |- t ; u : U

G1 |- t : T1 + T2
G2 µ { x1 : m T1 } |- u1 : U
G2 µ { x2 : m T2 } |- u2 : U
G1 ## G2
G2 ## { x1 : m T1 }
G2 ## { x2 : m T2 }
----------------- :: PatS
m.G1 µ G2 |- t & \case { Inl x1 -> u1 , Inr x2 -> u2 } : U

G1 |- t : T1 * T2
G2 µ { x1 : m T1, x2 : m T2 } |- u : U
G1 ## G2
G2 ## { x1 : m T1}
G2 ## { x2 : m T2}
{x1 : m T1} ## {x2 : m T2}
----------------- :: PatP
m.G1 µ G2 |- t & \case (x1 , x2) -> u : U

G1 |- t : !n T
G2 µ { x : m.n T } |- u : U
G1 ## G2
G2 ## { x : m.n T }
----------------- :: PatE
m.G1 µ G2 |- t & \case exp n x -> u : U

G1 |- t : T1 ><| T2
1.G2 µ { x : 0 T1 } |- u : U
G1 ## G2
G2 ## { x : 0 T1 }
-------------------------------- :: Map
G1 µ G2 |- t <&> \ x -> u : U ><| T2

G1 |- t : |T2|n
G2 |- u : T1 ><| T2
G1 ## G2
----------------------------- :: FillC
G1 µ (1.n).G2 |- t <|. u : T1

G |- t : |I|n
------------------------------ :: FillU
G |- t <| () : I

G |- t : |T1 + T2| n
------------------------------ :: FillL
G |- t <| Inl : |T1|n

G |- t : |T1 + T2| n
------------------------------ :: FillR
G |- t <| Inr : |T2|n

G |- t : |T1 * T2|n
------------------------------ :: FillP
G |- t <| (,) : |T1|n * |T2|n

G |- t : |!n T|m
------------------------------ :: FillE
G |- t <| exp n : |T|m.n

-------------------------------- :: Alloc
{} |- alloc T : |T|0 ><| T

G |- t : T
------------------------------- :: ToA
G |- toAmpar t : I ><| T

G |- t : I ><| T
------------------------------- :: FromA
G |- fromAmpar t : T

defns
Sem :: '' ::=

defn
w1 D1 | e1 ~> w2 D2 | e2 :: :: Sem_e :: Sem_e_ {{ com Big-step evaluation of effects on extended values }} by

------------------------- :: N
w1 D1 | o ~> w1 D1 | o

% G2 u D2 ||- w2 : T
% G' ## -D
h notin dom(D1)
w1 D1 |e1 ~> w2 D2| e2 
--------------------- :: S
w1 D1 | h := w', e1 ~> w2 D2 | h := w', e2

G1' u D1' ||- w' : T
G1' ## D1'
D1 ## { h : n T }
D1 ## D1'
w1[h := w'] (D1 µ n.D1') | e1 ~> w2 D2 | e2
--------------------- :: F
w1 D1 µ { h : n T } | h := w', e1 ~> w2 D2 | e2

% eff_app1 = eff_app2 :: :: EffApp :: EffApp_ {{ com $[[apply]]$: how effects are applied locally or winded up (we assume effect lists are $\otteff{\varepsilon}$-terminated) }} by

% ------------- :: NoEff
% apply (o, w D) = o , w D

% % Those two conditions ensures that no destination escapes its inner scope
% % TODO Should we put them there?


% % ------------------ :: FillUnit
% % apply(h := (), e, w D µ { -h : 0 1 }) = apply(e , w[h := ()] D)

% % ------------------ :: FillInl
% % apply(h := Inl h', e, w D µ { -h : 0 T1 + T2 }) = apply(e , w[h := Inl h'] D µ {-h' : 0 T1})

% % ------------------ :: FillInr
% % apply(h := Inr h', e, w D µ { -h : 0 T1 + T2 }) = apply(e , w[h := Inr h'] D µ {-h' : 0 T2})
% % ------------------ :: FillProd
% % apply(h := (h1, h2), e, w D µ { -h : 0 T1 * T2 }) = apply(e , w[h := (h1, h2)] D µ {-h1 : 0 T1, -h2 : 0 T2})


defn
t !! v <> e :: :: Sem_t :: Sem_t_ {{ com Big-step evaluation into commands }} by

------------------ :: V
v !! v <> o

t1 !! v1 <> e1
t2 !! \x -> u <> e2
u[x := v1] !! v3 <> e3
------------------ :: App
t1 & t2 !! v3 <> e1, e2, e3

t1 !! () <> e1
t2 !! v2 <> e2
----------------------- :: PatU
t1 ; t2 !! v2 <> e1, e2

t !! Inl v1 <> e1
u1[x1 := v1] !! v2 <> e2
----------------------- :: PatL
t & \case { Inl x1 -> u1, Inr x2 -> u2 } !! v2 <> e1, e2

t !! Inr v1 <> e1
u2[x2 := v1] !! v2 <> e2
----------------------- :: PatR
t & \case { Inl x1 -> u1, Inr x2 -> u2 } !! v2 <> e1, e2

t !! (v1,v2) <> e1
u[x1 := v1][x2 := v2] !! v2 <> e2
----------------------- :: PatP
t & \case (x1,x2) -> u !! v2 <> e1, e2

% Can e1 have effect on the content of the ampar? I don't think so, but maybe
t !! < v1 ¤ w2 > D <> e1
u[x := v1] !! v3 <> e2
 w2 D |e2 ~> w4 D'| e3 
---------------------------------- :: Map
t <&> \ x -> u !! <v3 ¤ w4> D' <> e1, e3

fresh h
-------------------------- :: Alloc
alloc T !! < @h ¤ h > { h : 0 T } <> o

t !! v <> e
----------------------------------------- :: ToA
toAmpar t !! < () ¤ v > {} <> e

t !! < () ¤ v > {} <> e
-------------------------------------- :: FromA
fromAmpar t !! v <> e

t !! @h <> e
------------------------------------- :: FillU
t <| () !! () <> e, h := ()

t !! @h <> e
fresh h'
--------------------------------------- :: FillL
t <| Inl !! @h' <> e, h := Inl h'

t !! @h <> e
--------------------------------------- :: FillR
t <| Inr !! @h' <> e, h := Inr h'

t !! @h <> e
fresh h1
fresh h2
--------------------------------------- :: FillP
t <| (,) !! (@h1, @h2) <> e, h := (h1,h2)

t !! @h <> e1
u !! <v1 ¤ w2> D <> e2
---------------------------------------- :: FillC
t <|. u !! v1<> e1, e2, h := w2
