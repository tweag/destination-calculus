defns
AuxPred :: '' ::=
defn
aux_pred :: :: JudgPred :: JudgPred_ by

defns
Ty :: '' ::=

% Tout trou créé doit apparaître soit comme dest dans le terme, soit être rempli par un effet suivant

defn
H1 = H2 :: :: AtApp :: AtApp_ {{ com $\otthol{@^{\scriptscriptstyle\text{-}1} }$: "Inverse sign of context" operation }} by

------------------- :: Empty
-{} = {}

------------------- :: Rec
-({@h : m |A| n} µ G) = {h : m.n A} µ -G

defn
D ||- e :: :: TyEff :: TyEff_ {{ com Typing of effects (require both positive and negative contexts) }} by

-------------- :: NoEff
{} u {} ||- o

G u H ||- w : A
h notin names (G)
------------------- :: Single
m°((n.I).G µ {@h : 0 |A|n} u n.H) ||- h := w

G1 u H1 µ -G22 ||- e1
G21 µ G22 u H2 ||- e2
G1 u H1 disjoint G21 u H2
------------------------- :: Union
G1 µ G21 u H1 µ H2 ||- e1 . e2

defn
G |- v | e : A :: :: TyCmd :: TyCmd_ {{ com Typing of commands (only a positive context is needed) }} by

G11 µ G12 |- v : A
G2 u -G12 ||- e
G11 disjoint G2
------------------ :: Cmd
G11 µ G2 |- v | e : A


defn
D ||- w : A :: :: TyValExt :: TyValExt_ {{ com Typing of extended values (require both positive and negative contexts) }} by

--------------------- :: Hole
{} u { h : 0 A } ||- h : A

---------------- :: Dest
{ @h : 0 |A|n } u {} ||- @h : |A|n

--------------------- :: Unit
{} u {} ||- () : 1

G u H ||- w : A1
--------------------- :: Inl
G u H ||- Inl w : A1 + A2

G u H ||- w : A2
--------------------- :: Inr
G u H ||- Inr w : A1 + A2

G1 u H1 ||- w1 : A1
G2 u H2 ||- w2 : A2
G1 u H1 disjoint G2 u H2
------------------------- :: Prod
G1 µ G2 u H1 µ H2 ||- (w1, w2) : A1 * A2

% TODO: should we augment age of holes which are below an exponential?
% TODO: yes so that they match their destination mode?
G u H ||- w : A
--------------------- :: Exp
m.G u m.H ||- exp m w : ! m A

G1 u {} ||- v1 : A1
G2 u -G1 ||- w2 : A2
---------------- :: Ampar
G2 u {} ||- <v1 ¤ w2> H : A1 ><| A2

G µ { x : m A1 } |- t : A2
----------------- :: Lambda
G u {} ||- \x -> t : A1 m -> A2

defn
G |- t : A :: :: TyTerm :: TyTerm_ {{ com Typing of terms (only a positive context is needed) }} by

G u {} ||- v : A
----------------- :: Val
G |- v : A

-------------------- :: VarNow
{ x : 0 A } |- x : A

-------------------- :: VarInf
{ x : inf A } |- x : A

G1 |- t : A1
G2 |- u : A1 m -> A2
G1 disjoint G2
----------------- :: App
m.G1 µ G2 |- t & u : A2

G1 |- t : 1
G2 |- u : B
G1 disjoint G2
----------------- :: PatUnit
G1 µ G2 |- t ; u : B

G1 |- t : A1 + A2
G2 µ { x1 : m A1 } |- u1 : B
G2 µ { x2 : m A2 } |- u2 : B
G1 disjoint G2
----------------- :: PatSum
m.G1 µ G2 |- t & \case { Inl x1 -> u1 , Inr x2 -> u2 } : B

G1 |- t : A1 * A2
G2 µ { x1 : m A1, x2 : m A2 } |- u : B
G1 disjoint G2
----------------- :: PatProd
m.G1 µ G2 |- t & \case ( x1 , x2) -> u : B

G1 |- t : !m' A
G2 µ { x : m.m' A1 } |- u : B
G1 disjoint G2
----------------- :: PatExp
m.G1 µ G2 |- t & \case exp m' x -> u : B

G1 |- t : A1 ><| A2
I.G2 µ { x : 0 A1 } |- u : B
G1 disjoint G2
-------------------------------- :: MapAmpar
G1 µ G2 |- t <&> \ x -> u : B ><| A2

G1 |- t : |A2|n
G2 |- u : A1 ><| A2
G1 disjoint G2
----------------------------- :: FillComp
G1 µ (n.I).G2 |- t <|. u : A1

G |- t : |1|n
------------------------------ :: FillUnit
G |- t <| () : 1

G |- t : |A1 + A2| n
------------------------------ :: FillInl
G |- t <| Inl : |A1|n

G |- t : |A1 + A2| n
------------------------------ :: FillInr
G |- t <| Inr : |A2|n

G |- t : |A1 * A2|n
------------------------------ :: FillProd
G |- t <| (,) : |A1|n * |A2|n

G |- t : |!n' A|n
------------------------------ :: FillExp
G |- t <| exp n' : |A|n.n'

-------------------------------- :: Alloc
{} |- alloc A : |A|0 ><| A

G |- t : A
------------------------------- :: ToAmpar
G |- toAmpar t : 1 ><| A

G |- t : 1 ><| A
------------------------------- :: FromAmpar
G |- fromAmpar t : A

defns
Sem :: '' ::=

defn
eff_app1 = eff_app2 :: :: EffApp :: EffApp_ {{ com $[[apply]]$: how effects are applied locally or winded up (we assume effect lists are $\otteff{\varepsilon}$-terminated) }} by

------------- :: NoEff
apply (o, w H) = o , w H

% Those two conditions ensures that no destination escapes its inner scope
% TODO Should we put them there?
% G' u _ ||- w' : A
% G' disjoint -H
h notin names(H)
--------------------- :: WindUp
apply (h := w2 . e, w1 H) = h := w2 .^ apply (e, w1 H)

% ------------------ :: FillUnit
% apply(h := () . e, w H µ { -h : 0 1 }) = apply(e , w[h := ()] H)

% ------------------ :: FillInl
% apply(h := Inl h' . e, w H µ { -h : 0 A1 + A2 }) = apply(e , w[h := Inl h'] H µ {-h' : 0 A1})

% ------------------ :: FillInr
% apply(h := Inr h' . e, w H µ { -h : 0 A1 + A2 }) = apply(e , w[h := Inr h'] H µ {-h' : 0 A2})

% ------------------ :: FillProd
% apply(h := (h1, h2) . e, w H µ { -h : 0 A1 * A2 }) = apply(e , w[h := (h1, h2)] H µ {-h1 : 0 A1, -h2 : 0 A2})

_ u H' ||- w2 : A
H µ { h : n A } disjoint H'
--------------------- :: Fill
apply (h := w2 . e, w1 H µ { h : n A }) = apply (e, w1[h := w2] H µ n.H')

defn
t !! v | e :: :: BigStep :: BigStep_ {{ com Big-step evaluation into commands }} by

------------------ :: Val
v !! v | o

t1 !! v1 | e1
t2 !! \x -> u | e2
u[x := v1] !! v3 | e3
------------------ :: App
t1 & t2 !! v3 | (e1 . e2) . e3

t1 !! () | e1
t2 !! v2 | e2
----------------------- :: PatUnit
t1 ; t2 !! v2 | e1 . e2

t !! Inl v1 | e1
u1[x1 := v1] !! v2 | e2
----------------------- :: PatInl
t & \case { Inl x1 -> u1, Inr x2 -> u2 } !! v2 | e1 . e2

t !! Inr v1 | e1
u2[x2 := v1] !! v2 | e2
----------------------- :: PatInr
t & \case { Inl x1 -> u1, Inr x2 -> u2 } !! v2 | e1 . e2

t !! (v1,v2) | e1
u[x1 := v1, x2 := v2] !! v2 | e2
----------------------- :: PatProd
t & \case (x1,x2) -> u !! v2 | e1 . e2

% Can e1 have effect on the content of the ampar? I don't think so, but maybe
t !! < v1 ¤ w2 > H | e1
u[x := v1] !! v3 | e2
e3, w4 H' = apply(e2, w2 H)
---------------------------------- :: MapAmpar
t <&> \ x -> u !! <v3 ¤ w4> H' | e1 . e3

fresh h
-------------------------- :: Alloc
alloc A !! < @h ¤ h > { h : 0 A } | o

t !! v | e
----------------------------------------- :: ToAmpar
toAmpar t !! < () ¤ v > {} | e

t !! < () ¤ v > {} | e
-------------------------------------- :: FromAmpar
fromAmpar t !! v | e

t !! @h | e
------------------------------------- :: FillUnit
t <| () !! () | e . h := ()

t !! @h | e
fresh h'
--------------------------------------- :: FillInl
t <| Inl !! @h' | e . h := Inl h'

t !! @h | e
--------------------------------------- :: FillInr
t <| Inr !! @h' | e . h := Inr h'

t !! @h | e
fresh h1
fresh h2
--------------------------------------- :: FillProd
t <| (,) !! (@h1, @h2) | e . h := (h1,h2)

t !! @h | e1
u !! <v1 ¤ w2> H | e2
---------------------------------------- :: FillComp
t <|. u !! v1 | (e1 . e2) . h := w2
