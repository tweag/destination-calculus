defns
Ty :: '' ::=

defn
G â«¦ v : T :: :: TyR_val :: TyR_val_ {{ com Typing of values (raw) }} by

% We must track linearity precisely, but age for received value is arbitrary
--------------------- :: H
{ - h : T Â¹a } â«¦ -h : T

{{ ctx_Compatible [[G]] [[+h : Â¹Î½ âŒŠTâŒ‹n]] }}
---------------- :: D
G â«¦ +h : âŒŠTâŒ‹n

--------------------- :: U
{} â«¦ () :ğŸ


% {{ mode_IsValid [[m]] }} : Probably we can relax that? Application will be impossible for such a function (as it would make the resulting context invalid), but it doesn't pose a problem per se
% {{ ctx_Disjoint [[G]] [[{ x : m T1 }]] }} : Redundant because ctx_DestOnly G => ctx_Disjoint G { x : m T1 }
% other rules don't need ctx_NoVar G as they cannot syntactically accept vars
{{ ctx_DestOnly [[G]] }} % Only says that we cannot have holes inside, as well as t cannot capture extra variables
G â¨„ { x : m T1 } âŠ¢ t : T2 [[:TYt]]
----------------- :: F
G â«¦ Î»áµ› x âŸ¼ t : T1 m â†’ T2

G â«¦ v : T1 [[:TYRv]]
--------------------- :: L
G â«¦ Inl v : T1 â¨ T2

G â«¦ v : T2 [[:TYRv]]
--------------------- :: R
G â«¦ Inr v : T1 â¨ T2

G1 â«¦ v1 : T1 [[:TYRv1]]
G2 â«¦ v2 : T2 [[:TYRv2]]
------------------------- :: P
G1 â¨„ G2 â«¦ (v1, v2) : T1 â¨‚ T2

% we should augment age of holes which are below an exponential
G â«¦ v : T [[:TYRv]]
% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
--------------------- :: E
mÂ·G â«¦ á´‡ m v : ! m T

% We perform controls here on Ampar, and not on the other rules, because outside of the ampar, the hole/dests that are compensated will no longer be visible.
% ctx_DestOnly [[G2 â¨„ G3]] ensures that v2 is just made of dests, and with ctx_DestOnly [[G1]] in G1 â¨„ (-G3) â«¦ v1 : T1 we can conclude that v2 dests compensates at least all the holes from this ampar. This forbids <<(-h0, -h), +h>, +h0> which isn't constructible through alloc anyway.
% These more complex rules are made to allow this program, in which v2 is made of dests which are not exclusively from this ampar:
% alloc >map x0 |-> 
%     alloc >map x1 |->
%         let x2 = fromA (alloc >map xt |-> xt <| E â†‘ <|. (toA x0)) in
%         fromA ( alloc >map xt |-> xt <| (,) >case (xt1, xt2) |->
%                     xt1 <|. (toA x1) ; xt2 <|. (toA x2)
%               )
% We would have x2 = E â†‘ +h0, and res = < -h0, < -h1 , (+h1, E â†‘ +h0) > >
% If such a program typechecks, then we need the extra context G2 to v2 for dests coming from outside of this ampar (with ctx_DestOnly G2)
% We need to make sure that an ampar will bind as many holes as possible (i.e that holes and matching dests cannot escape respectively in G1 and G2), that's why we have ctx_Disjoint [[G1]] [[G2]]
{{ ctx_Disjoint [[G1]] [[G2]] }}
{{ ctx_DestOnly [[G2 â¨„ G3]] }}
{{ ctx_DestOnly [[G1]] }}
G1 â¨„ (-G3) â«¦ v1 : T1 [[:TYRv1]]
G2 â¨„ G3 â«¦ v2 : T2 [[:TYRv2]]
---------------- :: A
G1 â¨„ G2 â«¦ hnames(-G3) âŸ¨v1 âŸ v2âŸ© : T1 â§” T2

defn
G âŠ¢ j : T :: :: Ty_term :: Ty_term_ {{ com Typing of terms }} by

{{ ctx_NoHole [[G]] }} % Functionnally equivalent as ctx_DestOnly G as values cannot syntactically contains free variables
G â«¦ v : T
-------------------- :: Val
G âŠ¢ v : T

{{ ctx_Compatible [[G]] [[x : Â¹Î½ T]] }}
-------------------- :: Var
G âŠ¢ x : T

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
G1 âŠ¢ t : T1 [[:TYt]]
G2 âŠ¢ u : T1 m â†’ T2 [[:TYu]]
----------------- :: App
mÂ·G1 â¨„ G2 âŠ¢ t â‰» u : T2

G1 âŠ¢ t :ğŸ [[:TYt]]
G2 âŠ¢ u : U [[:TYu]]
----------------- :: PatU
G1 â¨„ G2 âŠ¢ t ; u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G2]] [[{ x2 : m T2 }]] }}
G1 âŠ¢ t : T1 â¨ T2 [[:TYt]]
G2 â¨„ { x1 : m T1 } âŠ¢ u1 : U [[:TYu1]]
G2 â¨„ { x2 : m T2 } âŠ¢ u2 : U [[:TYu2]]
----------------- :: PatS
mÂ·G1 â¨„ G2 âŠ¢ t â‰»case m { Inl x1 âŸ¼ u1 , Inr x2 âŸ¼ u2 } : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x1 : m T1 }]] }}
{{ ctx_Disjoint [[G2]] [[{ x2 : m T2 }]] }}
{{ ctx_Disjoint [[{ x1 : m T1 }]] [[{ x2 : m T2 }]] }}
G1 âŠ¢ t : T1 â¨‚ T2 [[:TYt]]
G2 â¨„ { x1 : m T1, x2 : m T2 } âŠ¢ u : U [[:TYu]]
----------------- :: PatP
mÂ·G1 â¨„ G2 âŠ¢ t â‰»case m (x1 , x2) âŸ¼ u : U

% {{ mode_IsValid [[m]] }} : again, we can probably relax that. If m is invalid, it will contaminate the context anyway
{{ ctx_Disjoint [[G2]] [[{ x : mÂ·n T }]] }}
G1 âŠ¢ t : !n T [[:TYt]]
G2 â¨„ { x : mÂ·n T } âŠ¢ u : U [[:TYu]]
----------------- :: PatE
mÂ·G1 â¨„ G2 âŠ¢ t â‰»case m á´‡ n x âŸ¼ u : U

{{ ctx_Disjoint [[G2]] [[{ x : Â¹Î½ T2 }]] }}
G1 âŠ¢ t : T1 â§” T2 [[:TYt]]
Â¹â†‘Â·G2 â¨„ { x : Â¹Î½ T2 } âŠ¢ u : U [[:TYu]]
-------------------------------- :: Map
G1 â¨„ G2 âŠ¢ t â‰»map x âŸ¼ u : T1 â§” U

G âŠ¢ t : âŒŠğŸâŒ‹n [[:TYt]]
------------------------------ :: FillU
G âŠ¢ t â¨ () : ğŸ

{{ ctx_Disjoint [[G2]] [[{ x : m T1 }]] }}
G1 âŠ¢ t : âŒŠT1 m â†’ T2âŒ‹n [[:TYt]]
G2 â¨„ { x : m T1 } âŠ¢ u : T2 [[:TYu]]
---------------------------------------- :: FillF
G1 â¨„ (Â¹â†‘Â·n)Â·G2 âŠ¢ t â¨ Î» x âŸ¼ u : ğŸ

G âŠ¢ t : âŒŠT1 â¨ T2âŒ‹n [[:TYt]]
------------------------------ :: FillL
G âŠ¢ t â¨ Inl : âŒŠT1âŒ‹n

G âŠ¢ t : âŒŠT1 â¨ T2âŒ‹n [[:TYt]]
------------------------------ :: FillR
G âŠ¢ t â¨ Inr : âŒŠT2âŒ‹n

G âŠ¢ t : âŒŠT1 â¨‚ T2âŒ‹n [[:TYt]]
------------------------------ :: FillP
G âŠ¢ t â¨ (,) : âŒŠT1âŒ‹n â¨‚ âŒŠT2âŒ‹n

G âŠ¢ t : âŒŠ!m TâŒ‹n [[:TYt]]
------------------------------ :: FillE
G âŠ¢ t â¨ á´‡ m : âŒŠTâŒ‹mÂ·n

G1 âŠ¢ t : âŒŠT1âŒ‹n [[:TYt]]
G2 âŠ¢ u : T1 â§” T2 [[:TYu]]
----------------------------- :: FillC
G1 â¨„ (Â¹â†‘Â·n)Â·G2 âŠ¢ t â¨Â· u : T2

-------------------------------- :: Alloc
{} âŠ¢ alloc T : T â§” âŒŠTâŒ‹Â¹Î½

G âŠ¢ t : T [[:TYt]]
------------------------------- :: ToA
G âŠ¢ toâ§” t : T â§” ğŸ

G âŠ¢ t : T â§” ğŸ [[:TYt]]
------------------------------- :: FromA
G âŠ¢ fromâ§” t : T

defn
G â«¦ C : T :: :: TyR_ectx :: TyR_ectx_ {{ com Typing of evaluation contexts }} by

% G2 contains dests that aren't present in G1, so must have been absorbed by holes of open ampars from C
% G3 contains dests that still appear in G1 so that aren't absorbed by holes of open ampars from C
% {{ ctx_SubsetEq [[G3]] [[G1]] }} Should be provable; redundant
{{ ctx_Disjoint [[G1]] [[G2]] }}
{{ ctx_Disjoint [[G2]] [[G3]] }}
{{ ctx_NoVar [[G2 â¨„ G3]] }} % Because t1 types as a term, it cannot contain holes, so this is equivalent to ctx_DestOnly G11 â¨„ G12
{{ ctx_NoVar [[G1]] }} % Same here
G2 â¨„ G3 âŠ¢ t : T1 [[:TYt]]
G1 âŠ¢ C[t] : T2 [[:TYj]]
--------------------- :: T
G1 â¨„ (-G2) â«¦ C : T1 â†£ T2

defns
Sem :: '' ::=

defn
j âŸ¶ j' :: :: Sem_eterm :: Sem_eterm_ {{ com Small-step evaluation of terms using evaluation contexts }} {{ tex [[j]]~\longrightarrow~[[j']] }} by

------------------ :: App
C[v â‰» (Î»áµ› x âŸ¼ t) ] âŸ¶ C[t[x â‰” v] ]

----------------------- :: PatU
C[() ; t2] âŸ¶ C[t2]

----------------------- :: PatL
C[(Inl v) â‰»case m { Inl x1 âŸ¼ u1, Inr x2 âŸ¼ u2 }] âŸ¶ C[u1[x â‰” v] ]

----------------------- :: PatR
C[(Inr v) â‰»case m { Inl x1 âŸ¼ u1, Inr x2 âŸ¼ u2 }] âŸ¶ C[u2[x â‰” v] ]

----------------------- :: PatP
C[(v1, v2) â‰»case m (x1,x2) âŸ¼ u] âŸ¶ C[u[x1 â‰” v1][x2 â‰” v2] ]

----------------------- :: PatE
C[á´‡ n v â‰»case m á´‡ n x âŸ¼ u] âŸ¶ C[u[x â‰” v] ]

{{ [[h']] = [[max(hnames(C))]] }}
---------------------------------- :: MapOpen
C[ H âŸ¨ v1 âŸ v2 âŸ© â‰»map x âŸ¼ u] âŸ¶ (C âˆ˜ (Hâ©²h' áµ’âŸ¨ v1â©²h' âŸ []))[ u[x â‰” v2â©²h'] ]

---------------------------------- :: MapClose
(C âˆ˜ H áµ’âŸ¨ v1 âŸ [])[v2] âŸ¶ C[ H âŸ¨ v1 âŸ v2 âŸ© ]

-------------------------- :: Alloc
alloc T âŸ¶ {1} âŸ¨ +1 âŸ -1 âŸ©

----------------------------------------- :: ToA
C[toâ§” v] âŸ¶ C[{} âŸ¨ v âŸ () âŸ©]

-------------------------------------- :: FromA
C[fromâ§” {} âŸ¨ v âŸ () âŸ©] âŸ¶ v

------------------------------------- :: FillU
C[+h â¨ ()] âŸ¶ C[h â‰” {} ()][()]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillL
C[+h â¨ Inl] âŸ¶ C[h â‰” {h'+1} Inl -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillR
C[+h â¨ Inr] âŸ¶ C[h â‰” {h'+1} Inr -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillE
C[+h â¨ á´‡ m] âŸ¶ C[h â‰” {h'+1} á´‡ m -(h'+1)][+(h'+1)]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
--------------------------------------- :: FillP
C[+h â¨ (,)] âŸ¶ C[h â‰” {h'+1,h'+2} (-(h'+1),-(h'+2))][( +(h'+1), +(h'+2) )]

{{ [[h']] = [[max(hnames(C) âˆª {h})]] }}
---------------------------------------- :: FillC
C[+h â¨Â· H âŸ¨ v1 âŸ v2 âŸ©] âŸ¶ C[h â‰” (Hâ©²h') v1â©²h' ][v2â©²h' ]
