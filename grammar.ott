embed
{{ coq
Require Import Ott.ext_nat.
Require Import Coq.Structures.Equalities.
Require Import Coq.Structures.Orders.
Require Import Coq.Structures.OrdersAlt.
Require Import Coq.Structures.OrdersEx.
Require Import Coq.FSets.FMapWeakList.
Require Import Coq.FSets.FMapFacts.
}}

metavar tmv, x, y ::= {{ com Term-level variable name }}
  {{ tex \ottmv{[[tmv]]} }} {{ coq nat }}

metavar hdmv ::= {{ com Hole or destination static name }}
  {{ tex \ottshdnm{[[hdmv]]} }} {{ coq nat }}

indexvar k ::= {{ coq nat }} {{ com Index for ranges }}

grammar
hddyn, d :: 'hddyn_' ::= {{ com Hole or destination dynamic name }} {{ coq list nat }} {{ tex \ottshdnm{[[hddyn]]} }}
  | ⋆ :: :: R {{ com Root namespace }} {{ coq nil }} {{ tex \ottshdnm{\star} }}
  | d . 1 :: :: S1 {{ com Subnamespace 1 }} {{ coq ([[d]] ++ (cons 1 nil)) }} {{ tex [[d]]\ottshdnm{.1} }}
  | d . 2 :: :: S2 {{ com Subnamespace 2 }} {{ coq ([[d]] ++ (cons 2 nil)) }} {{ tex [[d]]\ottshdnm{.2} }}
  | d . 3 :: :: S3 {{ com Subnamespace 3 }} {{ coq ([[d]] ++ (cons 3 nil)) }} {{ tex [[d]]\ottshdnm{.3} }}

hdnm, h :: 'hdnm_' ::= {{ com Hole or destination name }} {{ tex \ottshdnm{[[hdnm]]} }}
  | dyn d :: :: D {{ tex [[d]] }} {{ com Dynamic name }}
  | static hdmv :: :: S  {{ tex [[hdmv]] }} {{ com Static name }}

embed
{{ coq
(* Will be aliased later to mul *)
Inductive _mul : Type :=
  | Lin : _mul
  | Ur : _mul.

Definition mul_plus (p1 p2: _mul) : _mul := Ur.

Definition mul_times (p1 p2: _mul) : _mul :=
  match p1, p2 with
  | Lin, Lin => Lin
  | _, _ => Ur
  end.

Definition mul_times' (pl: list _mul) : _mul :=
  List.fold_right mul_times Lin pl.

Theorem mul_eq_dec : forall (p1 p2: _mul), {p1 = p2} + {p1 <> p2}.
Proof.
  decide equality.
Defined.

Theorem mode_eq_dec : forall (m1 m2: option (_mul * ext_nat)), {m1 = m2} + {m1 <> m2}.
Proof.
  decide equality. destruct a, p.
  - destruct (mul_eq_dec _m _m0), (ext_eq_dec e e0); subst; auto.
    * right. congruence.
    * right. congruence.
    * right. congruence.
Defined.
}}

grammar

mul, p :: 'mul_' ::= {{ tex \ottsmode{[[mul]]} }} {{ com Multiplicity (first component of modality) }} {{ coq _mul }}
  | ¹ :: :: Lin {{ tex \ottsmode{1} }} {{ com Linear. Neutral element of the product }} {{ coq Lin }}
  | ω :: :: Ur {{ tex \ottsmode{\omega} }} {{ com Non-linear. Absorbing for the product }} {{ coq Ur }}
  | p1 . ... . pk :: :: P {{ com Semiring product }} {{ coq (mul_times' [[p1...pk]]) }}
  | ( p ) :: S :: Paren {{ tex \ottsmode{(}[[p]]\ottsmode{)} }} {{ coq [[p]] }}

age, a :: 'age_' ::= {{ tex \ottsmode{[[age]]} }} {{ com Age (second component of modality) }} {{ coq ext_nat }}
  | ν :: :: 0 {{ tex \ottsmode{\nu} }} {{ com Born now. Neutral element of the product }} {{ coq (Fin 0) }}
  | ↑ :: :: 1 {{ tex \ottsmode{\uparrow} }} {{ com One scope older }} {{ coq (Fin 1) }}
  | ∞ :: :: Inf {{ tex \ottsmode{\infty} }} {{ com Infinitely old / static. Absorbing for the product }} {{ coq Inf }}
  | a1 · ... · ak :: :: P {{ com Semiring product }} {{ coq (age_times' [[a1...ak]]) }}
  | ( a ) :: S :: Paren {{ tex \ottsmode{(}[[a]]\ottsmode{)} }} {{ coq [[a]] }}

mode, m, n :: 'mode_' ::= {{ tex \ottsmode{[[mode]]} }} {{ com Mode (Semiring) }} {{ coq option (mul * age) }}
  | p a :: :: C {{ com Pair of a multiplicity and age }} {{ tex [[p]]\![[a]] }} {{ coq (Some (pair [[p]] [[a]])) }}
  | ☠ :: :: Err {{ tex \ottsmode{\skull} }} {{ coq None }} {{ com Error case (incompatible types, multiplicities, or ages) }}
  | m1 · ... · mk :: :: P {{ com Semiring product }} {{ coq (mode_times' [[m1...mk]]) }}
  | ( m ) :: S :: Paren {{ tex \ottsmode{(}[[m]]\ottsmode{)} }} {{ coq [[m]] }}

type, T, U :: 'type_' ::= {{ com Type }} {{ tex \ottstype{[[type]]} }} {{ coq-equality decide equality. apply mode_eq_dec. apply mode_eq_dec. apply mode_eq_dec. }}
  | 𝟏 :: :: U {{ tex \ottstype{1} }} {{ com Unit }}
  | T1 ⨁ T2 :: :: S {{ tex [[T1]]\ottstype{\oplus}[[T2]] }} {{ com Sum }}
  | T1 ⨂ T2 :: :: P {{ tex [[T1]]\ottstype{\otimes}[[T2]] }} {{ com Product }}
  | ! m T :: :: E {{ tex \ottstype{!}^{[[m]]}\,[[T]] }} {{ com Exponential }}
  | T1 ⧔ T2 :: :: A {{ tex [[T1]]\,\ottstype{\ltimes}\,[[T2]] }} {{ com Ampar type (consuming $[[T2]]$ yields $[[T1]]$) }}
  | T1 m1 → T2 :: :: F {{ tex [[T1]]\,_{[[m1]]}\!\ottstype{\to}\,[[T2]] }} {{ com Function }}
  | ⌊ T ⌋ m :: :: D {{ tex \ottstype{\lfloor}[[T]]\ottstype{\rfloor}^{[[m]]} }} {{ com Destination }}
  | ( T ) :: S :: Paren {{ tex \ottstype{(}[[T]]\ottstype{)} }} {{ coq [[T]]}}

bndr, b :: 'bndr_' ::= {{ com Type assignment to either variable, destination or hole }}
  | x : m T :: :: V {{ com Variable }} {{ tex [[x]]:_{[[m]]}[[T]] }}
  | + h : m ⌊ T ⌋ n :: :: D {{ com Destination ($[[m]]$ is its own modality; $[[n]]$ is the modality for values it accepts) }} {{ tex \ottshdnm{+}[[h]]:_{[[m]]}\ottstype{\lfloor}[[T]]\ottstype{\rfloor}^{[[n]]} }}
  | - h : n T :: :: H {{ com Hole ($[[n]]$ is the modality for values it accepts, it doesn't have a modality on its own) }} {{ tex \ottshdnm{-}[[h]]:^{[[n]]}[[T]] }}

embed
{{ coq
Inductive name : Type :=
  | name_X : tmv -> name
  | name_HD : hdnm -> name.

Module Name_as_UDT <: UsualDecidableType.
  Definition t := name.

  Definition eq := @eq name.
  Definition eq_refl := @eq_refl name.
  Definition eq_sym := @eq_sym name.
  Definition eq_trans := @eq_trans name.

  (* Define the eq_dec function *)
  Theorem eq_dec : forall x y : name, {x = y} + {x <> y}.
  Proof.
    intros x y. induction x.
    - induction y.
        + assert ({t0 = t1} + {t0 <> t1}) by apply Nat.eq_dec. destruct H.
           * left. rewrite e. reflexivity.
           * right. congruence.
        + right. congruence.
    - induction y.
        + right. congruence.
        + induction h, h0.
          * assert ({d = d0} + {d <> d0}) by apply (list_eq_dec Nat.eq_dec). destruct H.
            ** left. rewrite e. reflexivity.
            ** right. congruence.
          * right. congruence.
          * right. congruence.
          * assert ({hdmv5 = hdmv0} + {hdmv5 <> hdmv0}) by apply Nat.eq_dec. destruct H.
            ** left. rewrite e. reflexivity.
            ** right. congruence.
    Defined.

  Instance eq_equiv : Equivalence Name_as_UDT.eq. split. exact eq_refl. exact eq_sym. exact eq_trans. Defined.

End Name_as_UDT.

Module Name_as_UDTOrig := Backport_DT(Name_as_UDT).
Module CtxM := FMapWeakList.Make(Name_as_UDTOrig).

Definition type_eq_dec : forall (T1 T2: type), {T1 = T2} + {T1 <> T2} := eq_type.

Definition age_eq_dec : forall (a1 a2: age), {a1 = a2} + {a1 <> a2} := ext_eq_dec.
Definition age_times (a1 a2 : age) : age := ext_plus a1 a2.
Definition age_times' (al: list age) : age := ext_plus' al.

Definition mode_plus (m1 m2: mode) : mode :=
  match m1, m2 with
  | None, _ => None
  | _, None => None
  | Some (p1, a1), Some (p2, a2) => match a1, a2 with
    | _, Inf => Some (mul_plus p1 p2, Inf)
    | Inf, _ => Some (mul_plus p1 p2, Inf)
    | _, _ => match a1, a2 with
      | Fin n1, Fin n2 => match Nat.eq_dec n1 n2 with
        | left _ => (* true *) Some (mul_plus p1 p2, Fin n1)
        | right _ => (* false *) None
        end
      | Inf, Inf => Some (mul_plus p1 p2, Inf)
      | _, _ => None
      end
    end
  end.

Definition mode_times (m1 m2: mode) : mode :=
  match m1, m2 with
  | None, _ => None
  | _, None => None
  | Some (p1, a1), Some (p2, a2) => Some (mul_times p1 p2, age_times a1 a2)
  end.

Definition mode_times' (ml: list mode) : mode :=
  List.fold_right mode_times (Some (Lin, Fin 0)) ml.

Definition bndr_name (b : bndr) : name :=
  match b with
  | bndr_V x m T => name_X x
  | bndr_H h m T => name_HD h
  | bndr_D h m1 T m2 => name_HD h
  end.

Definition bndr_mode (b : bndr) : mode := match b with
  | bndr_V _ m _ => m
  | bndr_H _ m _ => m
  | bndr_D _ m1 _ m2 => m1
  end.

Definition bndr_update_mode (b:bndr) (m:mode) := match b with
  | bndr_V x _ T => bndr_V x m T
  | bndr_H h _ T => bndr_H h m T
  | bndr_D h _ T m2 => bndr_D h m T m2
  end.

Definition bndr_IsDest (b: bndr) : Prop :=
  match b with
    | bndr_D _ _ _ _ => True
    | _ => False
  end.
Definition bndr_IsVar (b: bndr) : Prop :=
  match b with
    | bndr_V _ _ _ => True
    | _ => False
  end.
Definition bndr_IsHole (b: bndr) : Prop :=
  match b with
    | bndr_H _ _ _ => True
    | _ => False
  end.
Definition ctx_DestOnly (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> bndr_IsDest b.
Definition ctx_HoleOnly (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> bndr_IsHole b.
Definition ctx_VarOnly (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> bndr_IsVar b.
Definition ctx_NoDest (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> ~bndr_IsDest b.
Definition ctx_NoHole (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> ~bndr_IsHole b.
Definition ctx_NoVar (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> ~bndr_IsVar b.
Definition ctx_Valid (G: CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> exists m, bndr_mode b = Some m.
Definition ctx_SubsetEq (G1 G2 : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G1 -> CtxM.MapsTo n b G2.
Definition ctx_HdnmNotMem (h : hdnm) (G : CtxM.t bndr) : Prop :=
  ~CtxM.In (name_HD h) G.
Definition ctx_Compatible (G1 G2 : CtxM.t bndr) : Prop := True. (* TODO : define *)

Axiom ctx_Coherent: forall (G : CtxM.t bndr) n b, CtxM.MapsTo n b G -> bndr_name b = n.

Definition ctx_add (b' : bndr) (G : CtxM.t bndr) : CtxM.t bndr :=
  match CtxM.find (bndr_name b') G with
  | None => CtxM.add (bndr_name b') b' G
  | Some b => let new_bndr := match b, b' with
    | bndr_V x1 m1 T1, bndr_V x2 m2 T2 =>
      (* assert x1 = x2 *)
      match type_eq_dec T1 T2 with
      | left _ => (* true *) bndr_V x1 (mode_plus m1 m2) T1
      | right _ => bndr_update_mode b None
      end
    | bndr_D h1 m11 T1 m12, bndr_D h2 m21 T2 m22 =>
      (* assert h1 = h2 *)
      match mode_eq_dec m12 m22, type_eq_dec T1 T2 with
      | left _, left _ => (* true *) bndr_D h1 (mode_plus m11 m21) T1 m12
      | _, _ => (* false *) bndr_update_mode b None
      end
    | bndr_H h1 m1 T1, bndr_H h2 m2 T2 =>
      (* assert h1 = h2 *)
      match type_eq_dec T1 T2 with
      | left _ => (* true *) bndr_H h1 (mode_plus m1 m2) T1
      | right _ => bndr_update_mode b None
      end
    | _, _ => bndr_update_mode b None
    end
    in CtxM.add (bndr_name b') new_bndr G
  end.

Definition ctx_add_hdint (b':bndr) (G: CtxM.t bndr) : CtxM.t bndr :=
  let fallback := ctx_add b' G in
  match CtxM.find (bndr_name b') G with
  | None => fallback
  | Some b => match b, b' with
    | bndr_H h1 m1 T1, bndr_D h2 m21 T2 m22 =>
      (* assert h1 = h2 *)
      match mode_eq_dec (mode_plus m21 m22) m1, type_eq_dec T1 T2 with
      | left _, left _ => (* true *) match m1 with
        | Some (Lin, _) => CtxM.remove (bndr_name b') G
        | _ => fallback
        end
      | _, _ => (* false *) fallback
      end
    | _, _ => fallback
    end
  end.

Definition ctx_from_list (bs : list bndr) : CtxM.t bndr :=
  List.fold_right (fun b G => ctx_add b G) (CtxM.empty bndr) bs.

Definition ctx_union (G1 G2 : CtxM.t bndr) : CtxM.t bndr :=
  (* G1 is acc, G2 is iterated over *)
  CtxM.fold (fun n b G => ctx_add b G) G2 G1.

Definition ctx_interact (G1 G2 : CtxM.t bndr) : CtxM.t bndr :=
  (* G1 is acc, G2 is iterated over *)
  CtxM.fold (fun n b G => ctx_add_hdint b G) G2 G1.

Definition ctx_stimes (m1 : mode) (G : CtxM.t bndr) : CtxM.t bndr :=
  CtxM.map (fun b =>
    match b with
    | bndr_V x m2 T2 => bndr_V x (mode_times m1 m2) T2
    | bndr_D h m2 T2 m3 => bndr_D h (mode_times m1 m2) T2 m3
    | bndr_H h m2 T2 => bndr_H h (mode_times m1 m2) T2
    end
  ) G.

Definition ctx_minus (G : CtxM.t bndr) : CtxM.t bndr :=
  CtxM.map (fun b =>
    match b with
    | bndr_V x m2 T2 => bndr_V x None T2 (* error *)
    | bndr_D h m2 T2 m3 => bndr_H h (mode_times m2 m3) T2
    | bndr_H h m2 T2 => bndr_H h None T2 (* error *)
    end
  ) G.

Definition concat {A : Type} (ll : list (list A)) : list A :=
  List.fold_right (fun x1 x2 => x1 ++ x2) nil ll.
}}

grammar
ctx, G {{ tex \Gamma }}, D {{ tex \Delta }} :: 'ctx_' ::= {{ com Typing context }} {{ coq (CtxM.t bndr) }}
  | { b1 , .. , bk } :: :: L {{ coq (ctx_from_list [[b1..bk]]) }} {{ com List of bindings }}
  | m · G :: :: S {{ com Multiply each binding by $[[m]]$ }} {{ coq (ctx_stimes [[m]] [[G]]) }}
  | G1 ⨄ G2 :: :: U {{ coq (ctx_union [[G1]] [[G2]]) }} {{ com Sum contexts $[[G1]]$ and $[[G2]]$. Duplicates/incompatible elements will give bindings with mode $\ottsmode{\skull}$ }}
  | G1 ⁻⨄⁺ G2 :: :: I {{ coq (ctx_interact [[G1]] [[G2]]) }} {{ com Sum contexts, but allow linear holes from $[[G1]]$ to be compensated by linear dests from $[[G2]]$ }}
  | - G :: :: M {{ coq (ctx_minus [[G]]) }} {{ com Transforms every hole binding into a dest binding (requires \texttt{ctx\_DestOnly} $[[G]]$) }}
  | ( G ) :: S :: Paren {{ coq [[G]] }}

grammar
term, t, u :: 'term_' ::=                                               {{ com Term }}
  | v :: :: Val {{ com Value }}
  | x :: :: Var {{ com Variable }}
  | t ≻ u                                    ::   :: App      {{ com Application }} {{ tex [[t]]\,\succ[[u]] }}
  % | t ; u                   ::   :: PatU {{ com Pattern-match on unit }} {{ tex [[t]]\,\succ\,\ottkw{case}\,\ottsctor{()}\,\mapsto\,[[u]] }}
  | t ; u                   ::   :: PatU {{ com Pattern-match on unit }} {{ tex [[t]]~;\,[[u]] }}
  | t ≻case { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 }   ::   :: PatS (+ bind x1 in u1 +) (+ bind x2 in u2 +)     {{ com Pattern-match on sum }} {{ tex [[t]]\,\succ\ottkw{case}\,\{\,\ottsctor{Inl}\,[[x1]][[⟼]][[u1]]\,,~\ottsctor{Inr}\,[[x2]][[⟼]][[u2]]\,\} }}
  | t ≻case ( x1 , x2 ) ⟼ u            ::   :: PatP (+ bind x1 in u +) (+ bind x2 in u +)     {{ com Pattern-match on product }} {{ tex [[t]]\,\succ\ottkw{case}\,\ottsctor{(}[[x1]]\,\ottsctor{,}~[[x2]]\ottsctor{)}\![[⟼]][[u]] }} 
  | t ≻case ⦆ m x ⟼ u            ::   :: PatE (+ bind x in u +)    {{ com Pattern-match on exponential }} {{ tex [[t]]\,\succ\ottkw{case}~\expcons{[[m]]}[[x]][[⟼]][[u]] }}
  | t ≻map x ⟼ u :: :: Map (+ bind x in u +) {{ com Map over the right side of the ampar }} {{ tex [[t]]\,\succ\ottkw{map}~[[x]]\![[⟼]][[u]] }}

  % | toGlobal t :: :: ToGlobal {{ tex \ottkw{to}_{\ottsmode{\scriptstyle G} } }} {{ com Mode coercion to ${\ottsmode{\scriptstyle G} }$ }}
  % | fromGlobal t :: :: FromGlobal {{ tex \ottkw{from}_{\ottsmode{\scriptstyle G} } }} {{ com Mode coercion from ${\ottsmode{\scriptstyle G} }$ }}
  | to⧔ t :: :: ToA {{ tex \ottkw{to}_{\ottstype{\ltimes} }\,[[t]] }} {{ com Wrap $[[t]]$ into a trivial ampar }}
  | from⧔ t :: :: FromA {{ tex \ottkw{from}_{\ottstype{\ltimes} }\,[[t]] }} {{ com Extract value from trivial ampar }}

  | alloc T :: :: Alloc {{ com Return a fresh "identity" ampar object }} {{ tex \ottkw{alloc}_{ [[T]]} }}
  | t ⨞ () :: :: FillU {{ com Fill destination with unit }}
  | t ⨞ Inl                          ::   :: FillL   {{ com Fill destination with left variant }}
  | t ⨞ Inr                          ::   :: FillR   {{ com Fill destination with right variant }}
  | t ⨞ (,)                              ::   :: FillP    {{ com Fill destination with product constructor }}
  | t ⨞ ⦆ m :: :: FillE {{ com Fill destination with exponential constructor }} {{ tex [[t]][[⨞]]\expcons{[[m]]} }}
  | t ⨞· u :: :: FillC {{ com Fill destination with root of ampar $[[u]]$ }} {{ tex [[t]]\triangleleft\!\mybullet\,[[u]] }}

  | ( t )                                   :: S :: Paren {{ coq [[t]] }}
  | t [ x ≔ v ]                             :: M :: Sub {{ coq (term_sub [[t]] [[x]] [[v]]) }} {{ tex [[t]][ [[x]] \coloneq [[v]] ] }}
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpaacing2
  % | t b spe : : S :: BreakSpacing3

val, v :: 'val_' ::= {{ com Term value }}
  | - h :: :: H {{ com Hole }} {{ tex \ottshdnm{-}[[h]] }}
  | + h :: :: D {{ tex \ottshdnm{+}[[h]] }} {{ com Destination }}
  | () :: :: U {{ com Unit }}
  | λ x ⟼ t :: :: F (+ bind x in t +) {{ tex \lamnt{[[x]]}{[[t]]} }} {{ com Lambda abstraction }}
  | Inl v :: :: L {{ com Left variant for sum }}
  | Inr v :: :: R {{ com Right variant for sum }}
  | ⦆ m v :: :: E {{ tex \expcons{[[m]]}[[v]] }} {{ com Exponential }}
  | ( v1 , v2 ) :: :: P {{ tex \ottsctor{(}[[v1]]\,\ottsctor{,}~[[v2]]\ottsctor{)} }} {{ com Product }}
  | ⟨ v1 ❟ v2 ⟩ D :: :: A {{ com Ampar }} {{ tex \ottsctor{\langle}[[v1]]\,\ottsctor{\bbcomma}~[[v2]]\ottsctor{\rangle}_{[[D]]} }}
  | v [ e ] :: M :: Effect {{ coq (val_effapp [[v]] [[e]]) }}
  | ( v ) :: S :: Paren {{ coq [[v]] }}

hf, f :: 'hf_' ::= {{ com Hole filling }}
  | h ≔ v :: :: A {{ tex [[h]]\coloneq[[v]] }} {{ com Fill $[[h]]$ with value $[[v]]$ (that may contain holes) }}

grammar
eff, e :: 'eff_' ::= {{ com Effect }} {{ tex \ottseff{[[eff]]} }} {{ coq list hf }}
  | ε :: :: N {{ tex \ottseff{\varepsilon} }} {{ coq nil }} {{ com No-op effect }}
  | f :: :: S {{ coq (cons [[f]] nil) }} {{ com Single hole assignment }}
  | e1 » .. » ek :: :: C {{ com Chain effects }} {{ coq (concat [[e1..ek]]) }}
  | ( e ) :: S :: Paren {{ coq [[e]] }}

embed
{{ coq
Definition term_sub (t: term) (x : tmv) (v : val) : term := t.
(* TODO *)
Definition val_effapp (v : val) (e : eff) : val := v.
(* TODO *)
}}

grammar

% spacing, sp :: 'sp_' ::= {{ tex \ottssp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottssp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=

% === Term syntax ===
  | ⟼                                     ::   :: Mapsto       {{ tex \mapsto }}
  | () :: :: unit {{ tex \ottsctor{()} }}
  | Inl :: :: inl {{ tex \ottsctor{Inl} }}
  | Inr :: :: inr {{ tex \ottsctor{Inr} }}
  | (,) :: :: prod {{ tex \ottsctor{({,})} }}
  | ⨞ :: :: fill {{ tex \triangleleft }}
  | · :: :: semiring {{ tex \ottsmode{\hspace{-0.1ex}\cdot\hspace{-0.1ex} } }}
  | » :: :: chain {{ tex \gg }}

% === Contexts ===
  | ⨄ :: :: union {{ tex \cupplus }}
  | ⁻⨄⁺ :: :: interact {{ tex ^{\,\,\,\scriptscriptstyle\ottshdnm{-}\!\!}\cupplus^{\scriptscriptstyle\!\!\ottshdnm{+} }\, }}

% === Typing & Semantics ===
  | ⤋ :: :: effred {{ tex \text{\raisebox{-0.7ex}{\rotatebox{90}{$\Lleftarrow$}\!\!} } }}
  | ⋄ :: :: diam {{ tex ~\diamond~ }}
  | ⇓ :: :: downto {{ tex ~\Downarrow~ }}
  | ⊢ :: :: vdash {{ tex \,\vdash\, }}
  | ⫦ :: :: dvdash {{ tex \,\Vdash\, }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred :: '_' ::= {{ com Serves for the .mng file. Isn't used in the actual rules }}
  | ctx_DestOnly G :: :: ctx_DestOnly {{ tex \texttt{ctx\_DestOnly}~[[G]] }}
  | ctx_HoleOnly G :: :: ctx_HoleOnly {{ tex \texttt{ctx\_HoleOnly}~[[G]] }}
  | ctx_VarOnly G :: :: ctx_VarOnly {{ tex \texttt{ctx\_VarOnly}~[[G]] }}
  | ctx_NoDest G :: :: ctx_NoDest {{ tex \texttt{ctx\_NoDest}~[[G]] }}
  | ctx_NoHole G :: :: ctx_NoHole {{ tex \texttt{ctx\_NoHole}~[[G]] }}
  | ctx_NoVar G :: :: ctx_NoVar {{ tex \texttt{ctx\_NoVar}~[[G]] }}
  | ctx_Valid G :: :: ctx_Valid {{ tex \texttt{ctx\_Valid}~[[G]] }}
  | ctx_SubsetEq G1 G2 :: :: ctx_SubsetEq {{ tex \texttt{ctx\_SubsetEq}~[[G1]]~[[G2]] }}
  | ctx_HdnmNotMem h G :: :: ctx_HdnmNotMem {{ tex \texttt{ctx\_NotMem}~[[h]]~[[G]] }}
  | ctx_Compatible G1 G2 :: :: ctx_Compatible {{ tex \texttt{ctx\_Compatible}~[[G1]]~[[G2]] }}

  | ctx_Disjoint G1 G2 :: :: ctx_Disjoint {{ tex \texttt{ctx\_Disjoint}~[[G1]]~[[G2]] }} {{ com TODO: Just for legacy proof; remove }}

  | G ⫦ e :: :: TyR_eff
  | G ⫦ t : T :: :: TyR_term
  | G ⊢ e :: :: Ty_eff
  | G ⊢ t : T :: :: Ty_term
  | G ⊢ v ⋄ e : T :: :: Ty_cmd

  | v1 D1 | e1 ⤋ v2 D2 | e2 :: :: Sem_eff {{ tex [[v1]]_{~[[D1]]}\,|~[[e1]]~~[[⤋]]~~[[v2]]_{~[[D2]]}\,|~[[e2]] }}
  | t ‿ d ⇓ v ⋄ e :: :: Sem_term {{ tex [[t]]~_{\scriptscriptstyle[[d]]\!\!\!\!\!}[[⇓]][[v]][[⋄]][[e]] }}

parsing
ctx_U <= ctx_S
ctx_S <= ctx_M
ctx_U left ctx_U

