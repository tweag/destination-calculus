embed
{{ coq
Require Import Ott.ext_nat.
Require Import Coq.Structures.Equalities.
Require Import Coq.Structures.Orders.
Require Import Coq.Structures.OrdersAlt.
Require Import Coq.Structures.OrdersEx.
Require Import Coq.FSets.FMapWeakList.
Require Import Coq.FSets.FSetWeakList.
Require Import Coq.FSets.FMapFacts.
Require Import Coq.FSets.FSetFacts.

Inductive name : Type :=
  | name_X : nat -> name
  | name_HD : nat -> name.

Module Name_as_UDT <: UsualDecidableType.
  Definition t := name.

  Definition eq := @eq name.
  Definition eq_refl := @eq_refl name.
  Definition eq_sym := @eq_sym name.
  Definition eq_trans := @eq_trans name.

  (* Define the eq_dec function *)
  Theorem eq_dec : forall x y : name, {x = y} + {x <> y}.
  Proof.
    intros x y. decide equality. apply Nat.eq_dec. apply Nat.eq_dec.
  Defined.

  Instance eq_equiv : Equivalence Name_as_UDT.eq. split. exact eq_refl. exact eq_sym. exact eq_trans. Defined.

End Name_as_UDT.

Module Nat_as_UDTOrig := Backport_DT(Nat_as_OT).
Module HdnsM := FSetWeakList.Make(Nat_as_UDTOrig).
Module Name_as_UDTOrig := Backport_DT(Name_as_UDT).
Module CtxM := FMapWeakList.Make(Name_as_UDTOrig).

(* We need to predefine eq_dec for mode so that Ott can generate eq_dec for type *)

(* Will be aliased later to mul *)
Inductive _mul : Type :=
  | Lin : _mul
  | Ur : _mul.
Theorem mul_eq_dec : forall (p1 p2: _mul), {p1 = p2} + {p1 <> p2}.
Proof.
  decide equality.
Defined.
Definition age_eq_dec : forall (a1 a2: ext_nat), {a1 = a2} + {a1 <> a2} := ext_eq_dec.
Theorem mode_eq_dec : forall (m1 m2: option (_mul * ext_nat)), {m1 = m2} + {m1 <> m2}.
Proof.
  decide equality. destruct a, p.
  - destruct (mul_eq_dec _m _m0), (age_eq_dec e e0); subst; auto.
    * right. congruence.
    * right. congruence.
    * right. congruence.
Defined.
}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NAMES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

metavar var, x, y ::= {{ com Term-level variable name }}
  {{ tex \ottmv{[[var]]} }} {{ coq nat }}

indexvar k ::= {{ coq nat }} {{ com Index for ranges }}

grammar

hdn, h :: 'hdn_' ::= {{ com Hole or destination name ($\mathbb{N}$) }} {{ coq nat }} {{ tex \ottshdn{[[hdn]]} }}
  | 1 :: S :: O {{ coq 1 }} {{ tex \ottshdn{1} }}
  | 2 :: S :: T {{ coq 2 }} {{ tex \ottshdn{2} }}
  | h + h' :: M :: S {{ com Sum }} {{ coq ([[h]] + [[h']]) }} {{ tex [[h]]\ottshdn{+}[[h']] }}
  | max ( H ) :: M :: M {{ com Maximum of a set of holes }} {{ coq (hdns_max_hnames [[H]]) }} {{ tex \ottshdn{max(}[[H]]\ottshdn{)} }}
  | ( h ) :: S :: Paren {{ coq [[h]] }} {{ tex \ottshdn{(}[[h]]\ottshdn{)} }}

hdns, H :: 'hdns_' ::= {{ com Set of hole names }} {{ coq HdnsM.t }} {{ tex \ottshdn{[[hdns]]} }}
  | { h1 , .. , hk } :: :: L {{ coq (hdns_from_list [[h1..hk]]) }}
  | H1 âˆª H2 :: M :: U {{ com Union of sets }} {{ coq (HdnsM.union [[H1]] [[H2]]) }} {{ tex [[H1]]\ottshdn{\cup}\,[[H2]] }}
  | H â©² h :: M :: S {{ com Increase all names from $[[H]]$ by $[[h]]$. }} {{ coq (hdns_incr_hnames [[H]] [[h]]) }}
  | hnames ( G ) :: M :: C {{ com Hole names of a context (requires $\texttt{ctx\_NoVar}([[G]])$) }} {{ tex \ottshdn{hnames(}[[G]]\ottshdn{)} }} {{ coq (hdns_from_ctx [[G]]) }}
  | hnames ( C ) :: M :: E {{ com Hole names of an evaluation context }} {{ tex \ottshdn{hnames(}[[C]]\ottshdn{)} }} {{ coq (hdns_from_ectx [[C]]) }}
  | ( H ) :: S :: Paren {{ coq [[H]] }} {{ tex \ottshdn{(}[[H]]\ottshdn{)} }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LANGUAGE SYNTAX (STATIC)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

term, t, u :: 'term_' ::=                                               {{ com Term }}
  | v :: :: Val {{ com Value }}
  | x :: :: Var {{ com Variable }}
  | t â‰» u                                    ::   :: App      {{ com Application }} {{ tex [[t]]\,\succ[[u]] }}
  % | t ; u                   ::   :: PatU {{ com Pattern-match on unit }} {{ tex [[t]]\,\succ\,\ottkw{case}\,\ottsctor{()}\,\mapsto\,[[u]] }}
  | t ; u                   ::   :: PatU {{ com Pattern-match on unit }} {{ tex [[t]]~;\,[[u]] }}
  | t â‰»case m { Inl x1 âŸ¼ u1 , Inr x2 âŸ¼ u2 }   ::   :: PatS (+ bind x1 in u1 +) (+ bind x2 in u2 +)     {{ com Pattern-match on sum }} {{ tex [[t]]\,\succ\ottkw{case}_{[[m]]}\,\{\,\ottsctor{Inl}\,[[x1]][[âŸ¼]][[u1]]\,,~\ottsctor{Inr}\,[[x2]][[âŸ¼]][[u2]]\,\} }}
  | t â‰»case m ( x1 , x2 ) âŸ¼ u            ::   :: PatP (+ bind x1 in u +) (+ bind x2 in u +)     {{ com Pattern-match on product }} {{ tex [[t]]\,\succ\ottkw{case}_{[[m]]}\,\ottsctor{(}[[x1]]\,\ottsctor{,}~[[x2]]\ottsctor{)}\![[âŸ¼]][[u]] }} 
  | t â‰»case m á´‡ n x âŸ¼ u            ::   :: PatE (+ bind x in u +)    {{ com Pattern-match on exponential }} {{ tex [[t]]\,\succ\ottkw{case}_{[[m]]}\,\expcons{[[n]]}[[x]][[âŸ¼]][[u]] }}
  | t â‰»map x âŸ¼ u :: :: Map (+ bind x in u +) {{ com Map over the right side of ampar $[[t]]$ }} {{ tex [[t]]\,\succ\ottkw{map}~[[x]]\![[âŸ¼]][[u]] }}

  % | toGlobal t :: :: ToGlobal {{ tex \ottkw{to}_{\ottsmode{\scriptstyle G} } }} {{ com Mode coercion to ${\ottsmode{\scriptstyle G} }$ }}
  % | fromGlobal t :: :: FromGlobal {{ tex \ottkw{from}_{\ottsmode{\scriptstyle G} } }} {{ com Mode coercion from ${\ottsmode{\scriptstyle G} }$ }}
  | toâ§” t :: :: ToA {{ tex \ottkw{to}_{\ottstype{\ltimes} }\,[[t]] }} {{ com Wrap $[[t]]$ into a trivial ampar }}
  | fromâ§” t :: :: FromA {{ tex \ottkw{from}_{\ottstype{\ltimes} }\,[[t]] }} {{ com Extract value from trivial ampar }}

  | alloc :: :: Alloc {{ com Return a fresh "identity" ampar object }} {{ tex \ottkw{alloc} }}
  | t â¨ž () :: :: FillU {{ com Fill destination with unit }}
  | t â¨ž ( Î» x m âŸ¼ u ) :: :: FillF (+ bind x in u +) {{ com Fill destination with function }} {{ tex [[t]][[â¨ž]](\lamnt{[[x]]}{[[m]]}{[[u]]}) }}
  | t â¨ž Inl                          ::   :: FillL   {{ com Fill destination with left variant }}
  | t â¨ž Inr                          ::   :: FillR   {{ com Fill destination with right variant }}
  | t â¨ž (,)                              ::   :: FillP    {{ com Fill destination with product constructor }}
  | t â¨ž á´‡ m :: :: FillE {{ com Fill destination with exponential constructor }} {{ tex [[t]][[â¨ž]]\expcons{[[m]]} }}
  | t â¨žÂ· u :: :: FillC {{ com Fill destination with root of ampar $[[u]]$ }} {{ tex [[t]]\triangleleft\!\mybullet\,[[u]] }}

  | t [ x â‰” v ]                             :: M :: Sub {{ coq (term_sub [[t]] [[x]] [[v]]) }} {{ tex [[t]][ [[x]] \coloneq [[v]] ] }}
  | ( t )                                   :: S :: Paren {{ coq [[t]] }}
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpaacing2
  % | t b spe : : S :: BreakSpacing3

val, v :: 'val_' ::= {{ com Term value }}
  | - h :: :: H {{ com Hole }} {{ tex \ottshdn{-}[[h]] }}
  | + h :: :: D {{ tex \ottshdn{+}[[h]] }} {{ com Destination }}
  | () :: :: U {{ com Unit }}
  | Î»áµ› x m âŸ¼ t :: :: F (+ bind x in t +) {{ tex \lamvnt{[[x]]}{[[m]]}{[[t]]} }} {{ com Lambda abstraction }}
  | Inl v :: :: L {{ com Left variant for sum }}
  | Inr v :: :: R {{ com Right variant for sum }}
  | á´‡ m v :: :: E {{ tex \expcons{[[m]]}[[v]] }} {{ com Exponential }}
  | ( v1 , v2 ) :: :: P {{ tex \ottsctor{(}[[v1]]\,\ottsctor{,}~[[v2]]\ottsctor{)} }} {{ com Product }}
  | H âŸ¨ v1 âŸ v2 âŸ© :: :: A {{ com Ampar }} {{ tex _{[[H]]\!}\ottsctor{\langle}[[v1]]\,\ottsctor{\bbcomma}~[[v2]]\ottsctor{\rangle} }}
  | v â©² h :: M :: Rename {{ com Rename hole names inside $[[v]]$ by shifting them by $[[h]]$ }} {{ coq (val_incr_hnames [[v]] [[h]]) }}
  | ( v ) :: S :: Paren {{ coq [[v]] }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DYNAMIC SYNTAX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

eterm, j :: 'eterm_' ::= {{ com Pseudo-term }} {{ coq (ectx * term) }}
  | C [ t ] :: :: ECtxApp {{ coq (pair [[C]] [[t]]) }}
  | t :: S :: TermSugar {{ coq (pair ectx_Id [[t]]) }}

ectx, C :: 'ectx_' ::= {{ com Evaluation context }}
  | [ ] :: :: Id {{ com Identity }} {{ tex \square }}
  | C â‰» u                                    ::   :: App1      {{ com Application }} {{ tex [[C]]\,\succ[[u]] }}
  | v â‰» C                                    ::   :: App2      {{ com Application }} {{ tex [[v]]\,\succ[[C]] }}
  | C ; u                   ::   :: PatU {{ com Pattern-match on unit }} {{ tex [[C]]~;\,[[u]] }}
  | C â‰»case m { Inl x1 âŸ¼ u1 , Inr x2 âŸ¼ u2 }   ::   :: PatS (+ bind x1 in u1 +) (+ bind x2 in u2 +)     {{ com Pattern-match on sum }} {{ tex [[C]]\,\succ\ottkw{case}_{[[m]]}\,\{\,\ottsctor{Inl}\,[[x1]][[âŸ¼]][[u1]]\,,~\ottsctor{Inr}\,[[x2]][[âŸ¼]][[u2]]\,\} }}
  | C â‰»case m ( x1 , x2 ) âŸ¼ u            ::   :: PatP (+ bind x1 in u +) (+ bind x2 in u +)     {{ com Pattern-match on product }} {{ tex [[C]]\,\succ\ottkw{case}_{[[m]]}\,\ottsctor{(}[[x1]]\,\ottsctor{,}~[[x2]]\ottsctor{)}\![[âŸ¼]][[u]] }} 
  | C â‰»case m á´‡ n x âŸ¼ u            ::   :: PatE (+ bind x in u +)    {{ com Pattern-match on exponential }} {{ tex [[C]]\,\succ\ottkw{case}_{[[m]]}\,\expcons{[[n]]}[[x]][[âŸ¼]][[u]] }}
  | C â‰»map x âŸ¼ u :: :: Map (+ bind x in u +) {{ com Map over the right side of ampar }} {{ tex [[C]]\,\succ\ottkw{map}~[[x]]\![[âŸ¼]][[u]] }}

  | toâ§” C :: :: ToA {{ tex \ottkw{to}_{\ottstype{\ltimes} }\,[[C]] }} {{ com Wrap into a trivial ampar }}
  | fromâ§” C :: :: FromA {{ tex \ottkw{from}_{\ottstype{\ltimes} }\,[[C]] }} {{ com Extract value from trivial ampar }}
  | C â¨ž () :: :: FillU {{ com Fill destination with unit }}
  | C â¨ž ( Î» x m âŸ¼ u ) :: :: FillF (+ bind x in u +) {{ com Fill destination with function }} {{ tex [[C]][[â¨ž]](\lamnt{[[x]]}{[[m]]}{[[u]]}) }}
  | C â¨ž Inl                          ::   :: FillL   {{ com Fill destination with left variant }}
  | C â¨ž Inr                          ::   :: FillR   {{ com Fill destination with right variant }}
  | C â¨ž (,)                              ::   :: FillP    {{ com Fill destination with product constructor }}
  | C â¨ž á´‡ m :: :: FillE {{ com Fill destination with exponential constructor }} {{ tex [[C]][[â¨ž]]\expcons{[[m]]} }}
  | C â¨žÂ· u :: :: FillC1 {{ com Fill destination with root of ampar }} {{ tex [[C]]\triangleleft\!\mybullet\,[[u]] }}
  | v â¨žÂ· C :: :: FillC2 {{ com Fill destination with root of ampar }} {{ tex [[v]]\triangleleft\!\mybullet\,[[C]] }}
  | H áµ’áµ–âŸ¨ v1 âŸ C :: :: AOpen {{ tex ^{\text{op}\!}_{[[H]]\!}\ottsctor{\langle}[[v1]]\,\ottsctor{\bbcomma}~[[C]] }} {{ com Open ampar. \textcolor{red}{Only new addition to term shapes} }}
  | C âˆ˜ C' :: M :: Comp {{ com Compose evaluation contexts }} {{ tex [[C]]\circ\,[[C']] }}
  | C [ h â‰” H v ] :: M :: Fill {{ tex [[C]][ [[h]]\coloneq_{[[H]]}\,[[v]] ] }} {{ com Fill $[[h]]$ with value $[[v]]$ (that may contain holes) }} {{ coq (ectx_fill [[C]] [[h]] [[v]]) }}
  | ( C ) :: S :: Paren {{ coq [[C]] }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TYPING SYNTAX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type, T, U :: 'type_' ::= {{ com Type }} {{ tex \ottstype{[[type]]} }} {{ coq-equality decide equality. apply mode_eq_dec. apply mode_eq_dec. apply mode_eq_dec. }}
  | ðŸ :: :: U {{ tex \ottstype{1} }} {{ com Unit }}
  | T1 â¨ T2 :: :: S {{ tex [[T1]]\ottstype{\oplus}[[T2]] }} {{ com Sum }}
  | T1 â¨‚ T2 :: :: P {{ tex [[T1]]\ottstype{\otimes}[[T2]] }} {{ com Product }}
  | ! m T :: :: E {{ tex \ottstype{!}^{[[m]]}\,[[T]] }} {{ com Exponential }}
  | T1 â§” T2 :: :: A {{ tex [[T1]]\,\ottstype{\ltimes}\,[[T2]] }} {{ com Ampar type (consuming $[[T2]]$ yields $[[T1]]$) }}
  | T1 m1 â†’ T2 :: :: F {{ tex [[T1]]\,_{[[m1]]}\!\ottstype{\to}\,[[T2]] }} {{ com Function }}
  | âŒŠ T âŒ‹ m :: :: D {{ tex \ottstype{\lfloor}[[T]]\ottstype{\rfloor}^{[[m]]} }} {{ com Destination }}
  | ( T ) :: S :: Paren {{ tex \ottstype{(}[[T]]\ottstype{)} }} {{ coq [[T]]}}

mode, m, n :: 'mode_' ::= {{ tex \ottsmode{[[mode]]} }} {{ com Mode (Semiring) }} {{ coq option (mul * age) }}
  | p a :: :: C {{ com Pair of a multiplicity and age }} {{ tex [[p]]\![[a]] }} {{ coq (Some (pair [[p]] [[a]])) }}
  | â˜  :: :: Err {{ tex \ottsmode{\skull} }} {{ coq None }} {{ com Error case (incompatible types, multiplicities, or ages) }}
  | m1 Â· ... Â· mk :: M :: P {{ com Semiring product }} {{ coq (mode_times' [[m1...mk]]) }}
  | ( m ) :: S :: Paren {{ tex \ottsmode{(}[[m]]\ottsmode{)} }} {{ coq [[m]] }}

mul, p :: 'mul_' ::= {{ tex \ottsmode{[[mul]]} }} {{ com Multiplicity (first component of modality) }} {{ coq _mul }}
  | Â¹ :: :: Lin {{ tex \ottsmode{1} }} {{ com Linear. Neutral element of the product }} {{ coq Lin }}
  | Ï‰ :: :: Ur {{ tex \ottsmode{\omega} }} {{ com Non-linear. Absorbing for the product }} {{ coq Ur }}
  | p1 . ... . pk :: M :: P {{ com Semiring product }} {{ coq (mul_times' [[p1...pk]]) }}
  | ( p ) :: S :: Paren {{ tex \ottsmode{(}[[p]]\ottsmode{)} }} {{ coq [[p]] }}

age, a :: 'age_' ::= {{ tex \ottsmode{[[age]]} }} {{ com Age (second component of modality) }} {{ coq ext_nat }}
  | Î½ :: :: 0 {{ tex \ottsmode{\nu} }} {{ com Born now. Neutral element of the product }} {{ coq (Fin 0) }}
  | â†‘ :: :: 1 {{ tex \ottsmode{\uparrow} }} {{ com One scope older }} {{ coq (Fin 1) }}
  | âˆž :: :: Inf {{ tex \ottsmode{\infty} }} {{ com Infinitely old / static. Absorbing for the product }} {{ coq Inf }}
  | a1 Â· ... Â· ak :: M :: P {{ com Semiring product }} {{ coq (age_times' [[a1...ak]]) }}
  | ( a ) :: S :: Paren {{ tex \ottsmode{(}[[a]]\ottsmode{)} }} {{ coq [[a]] }}

bndr, b :: 'bndr_' ::= {{ com Type assignment to either variable, destination or hole }}
  | x : m T :: :: V {{ com Variable }} {{ tex [[x]]:_{[[m]]}[[T]] }}
  | + h : m âŒŠ T âŒ‹ n :: :: D {{ com Destination ($[[m]]$ is its own modality; $[[n]]$ is the modality for values it accepts) }} {{ tex \ottshdn{+}[[h]]:_{[[m]]}\ottstype{\lfloor}[[T]]\ottstype{\rfloor}^{[[n]]} }}
  | - h : T n :: :: H {{ com Hole ($[[n]]$ is the modality for values it accepts, it doesn't have a modality on its own) }} {{ tex \ottshdn{-}[[h]]:[[T]]^{[[n]]} }}

ctx, G {{ tex \Gamma }}, D {{ tex \Delta }} :: 'ctx_' ::= {{ com Typing context }} {{ coq (CtxM.t bndr) }}
  | { b1 , .. , bk } :: :: L {{ coq (ctx_from_list [[b1..bk]]) }} {{ com List of bindings }}
  | m Â· G :: M :: S {{ com Multiply each binding by $[[m]]$ }} {{ coq (ctx_stimes [[m]] [[G]]) }}
  | G1 â¨„ G2 :: M :: U {{ coq (ctx_union [[G1]] [[G2]]) }} {{ com Sum contexts $[[G1]]$ and $[[G2]]$. Duplicates/incompatible elements will give bindings with mode $\ottsmode{\skull}$ }}
  | - G :: M :: M {{ coq (ctx_minus [[G]]) }} {{ com Transforms every dest binding into a hole binding (requires \texttt{ctx\_DestOnly} $[[G]]$) }}
  | ( G ) :: S :: Paren {{ coq [[G]] }}

embed
{{ coq
(******************************************************************************
 * NAMES
 *****************************************************************************)

Definition name_eq_dec := Name_as_UDT.eq_dec.

Fixpoint hdns_from_list (l : list nat) : HdnsM.t :=
  match l with
  | nil => HdnsM.empty
  | h :: t => HdnsM.add h (hdns_from_list t)
  end.

Definition hdns_max_hnames (H : HdnsM.t) : nat :=
  HdnsM.fold (fun k acc => max k acc) H 0.

Definition hdns_incr_hnames (H : HdnsM.t) (h' : nat) : HdnsM.t :=
  HdnsM.fold (fun h acc => HdnsM.add (h + h') acc) H HdnsM.empty.

Definition hdns_from_ctx (G : CtxM.t bndr) : HdnsM.t :=
  CtxM.fold (fun n b acc =>
    match b with
    | bndr_H h _ _ => HdnsM.add h acc
    | _ => acc
    end
  ) G HdnsM.empty.

(* TODO: check definition *)
Fixpoint hdns_from_ectx (C : ectx) : HdnsM.t :=
  match C with
  | ectx_Id => HdnsM.empty
  | ectx_AOpen H v C' => HdnsM.union H (hdns_from_ectx C')
  | ectx_Comp C1 C2 => HdnsM.union (hdns_from_ectx C1) (hdns_from_ectx C2)
  end.

(******************************************************************************
 * TERMS DYNAMIC BEHAVIOUR
 *****************************************************************************)

Fixpoint term_sub_name (t: term) (n : name) (v : val) : term := match t with
  | term_Val v' => term_Val (val_sub_name v' n v)
  | term_Var y => match name_eq_dec n (name_X y) with
    | left _ => term_Val v
    | right _ => term_Var y
    end
  | term_App t1 t2 => term_App (term_sub_name t1 n v) (term_sub_name t2 n v)
  | term_PatU t1 t2 => term_PatU (term_sub_name t1 n v) (term_sub_name t2 n v)
  | term_PatS t' m x1 u1 x2 u2 =>
    let u1' := match name_eq_dec n (name_X x1) with
      | left _ => (* shadowing *) u1
      | right _ => term_sub_name u1 n v
    end in
    let u2' := match name_eq_dec n (name_X x2) with
      | left _ => (* shadowing *) u2
      | right _ => term_sub_name u2 n v
    end in term_PatS (term_sub_name t' n v) m x1 u1' x2 u2'
  | term_PatP t' m x1 x2 u => match name_eq_dec n (name_X x1), name_eq_dec n (name_X x2) with
    | right _, right _ => term_PatP (term_sub_name t' n v) m x1 x2 (term_sub_name u n v)
    | _, _ => (* at least one shadowing *) term_PatP (term_sub_name t' n v) m x1 x2 u
    end
  | term_PatE t' m m' x' u => let u' := match name_eq_dec n (name_X x') with
      | left _ => (* shadowing *) u
      | right _ => term_sub_name u n v
    end in term_PatE (term_sub_name t' n v) m m' x' u'
  | term_Map t' x' u => let u' := match name_eq_dec n (name_X x') with
      | left _ => (* shadowing *) u
      | right _ => term_sub_name u n v
    end in term_Map (term_sub_name t' n v) x' u'
  | term_ToA t' => term_ToA (term_sub_name t' n v)
  | term_FromA t' => term_FromA (term_sub_name t' n v)
  | term_Alloc => term_Alloc
  | term_FillU t1 => term_FillU (term_sub_name t1 n v)
  | term_FillF t1 x' m u => let u' := match name_eq_dec n (name_X x') with
    | left _ => (* shadowing *) u
    | right _ => term_sub_name u n v
    end in term_FillF (term_sub_name t1 n v) x' m u'
  | term_FillL t1 => term_FillL (term_sub_name t1 n v)
  | term_FillR t1 => term_FillR (term_sub_name t1 n v)
  | term_FillP t1 => term_FillP (term_sub_name t1 n v)
  | term_FillE t1 m => term_FillE (term_sub_name t1 n v) m
  | term_FillC t u => term_FillC (term_sub_name t n v) (term_sub_name u n v)
end
with val_sub_name (v': val) (n:name) (v:val) : val := match v' with
  | val_F x' m u => let u' := match name_eq_dec n (name_X x') with
    | left _ => (* shadowing *) u
    | right _ => term_sub_name u n v
    end in val_F x' m u'
  | val_H h => match name_eq_dec n (name_HD h) with
    | left _ => v
    | right _ => val_H h
  end
  | val_D h => val_D h
  | val_U => val_U
  | val_L v'' => val_L (val_sub_name v'' n v)
  | val_R v'' => val_R (val_sub_name v'' n v)
  | val_E m v'' => val_E m (val_sub_name v'' n v)
  | val_P v1 v2 => val_P (val_sub_name v1 n v) (val_sub_name v2 n v)
  | val_A H v1 v2 => val_A H (val_sub_name v1 n v) (val_sub_name v2 n v) (* TODO: false, need to update H by removing name (maybe) and adding new ones *)
end.

Definition term_sub (t: term) (x:var) (v:val) : term := term_sub_name t (name_X x) v.
Definition ectx_fill (C: ectx) (h:hdn) (v:val) : ectx := C. (* TODO complete *)
Definition val_incr_hnames (v : val) (h : hdn) : val := v. (* TODO complete *)

(******************************************************************************
 * TYPE
 *****************************************************************************)

(* Alias to the one defined by Ott *)
Definition type_eq_dec : forall (T1 T2: type), {T1 = T2} + {T1 <> T2} := eq_type.

(******************************************************************************
 * MULTIPLICITY
 *****************************************************************************)

Definition mul_plus (p1 p2: _mul) : _mul := Ur.
Definition mul_times (p1 p2: _mul) : _mul :=
  match p1, p2 with
  | Lin, Lin => Lin
  | _, _ => Ur
  end.
Definition mul_times' (pl: list _mul) : _mul :=
  List.fold_right mul_times Lin pl.
Inductive mul_IsSubtype : _mul -> _mul -> Prop :=
  | mul_IsSubtypeProofEq : forall (p : _mul), mul_IsSubtype p p
  | mul_IsSubtypeProofUr : forall (p2 : _mul), mul_IsSubtype Ur p2.
Theorem mul_IsSubtype_dec : forall (p1 p2: _mul), {mul_IsSubtype p1 p2} + {~mul_IsSubtype p1 p2}.
Proof.
  intros p1 p2. destruct p1, p2.
  - left. exact (mul_IsSubtypeProofEq Lin).
  - right. intros contra. inversion contra.
  - left. exact (mul_IsSubtypeProofUr Lin).
  - left. exact (mul_IsSubtypeProofEq Ur).
Defined.

(******************************************************************************
 * AGE
 *****************************************************************************)

Definition age_times (a1 a2 : age) : age := ext_plus a1 a2.
Definition age_times' (al: list age) : age := ext_plus' al.
Inductive age_IsSubtype : age -> age -> Prop :=
  | age_IsSubtypeProofEq : forall (a : age), age_IsSubtype a a
  | age_IsSubtypeProofInf : forall (a2 : age), age_IsSubtype Inf a2.
Theorem age_IsSubtype_dec : forall (a1 a2: age), {age_IsSubtype a1 a2} + {~(age_IsSubtype a1 a2)}.
Proof.
  intros a1 a2. destruct a1, a2.
  - assert ({n = n0} + {n <> n0}) by apply Nat.eq_dec. destruct H.
    * rewrite e. left. exact (age_IsSubtypeProofEq (Fin n0)).
    * right. intros contra. inversion contra. congruence.
  - right. intros contra. inversion contra.
  - left. exact (age_IsSubtypeProofInf (Fin n)).
  - left. exact (age_IsSubtypeProofEq Inf).
Defined.

(******************************************************************************
 * MODE
 *****************************************************************************)

Definition mode_plus (m1 m2: mode) : mode :=
  match m1, m2 with
  | None, _ => None
  | _, None => None
  | Some (p1, a1), Some (p2, a2) => match a1, a2 with
    | _, Inf => Some (mul_plus p1 p2, Inf)
    | Inf, _ => Some (mul_plus p1 p2, Inf)
    | _, _ => match a1, a2 with
      | Fin n1, Fin n2 => match Nat.eq_dec n1 n2 with
        | left _ => (* true *) Some (mul_plus p1 p2, Fin n1)
        | right _ => (* false *) None
        end
      | Inf, Inf => Some (mul_plus p1 p2, Inf)
      | _, _ => None
      end
    end
  end.
Definition mode_times (m1 m2: mode) : mode :=
  match m1, m2 with
  | None, _ => None
  | _, None => None
  | Some (p1, a1), Some (p2, a2) => Some (mul_times p1 p2, age_times a1 a2)
  end.
Definition mode_times' (ml: list mode) : mode :=
  List.fold_right mode_times (Some (Lin, Fin 0)) ml.
Inductive mode_IsSubtype : mode -> mode -> Prop :=
  | mode_IsSubtypeProofNone : forall (m1 : mode), mode_IsSubtype m1 None
  | mode_IsSubtypeProofPair : forall (p1 p2 : _mul) (a1 a2 : age), mul_IsSubtype p1 p2 -> age_IsSubtype a1 a2 -> mode_IsSubtype (Some (p1, a1)) (Some (p2, a2)).
Theorem mode_IsSubtype_dec : forall (m1 m2: mode), {mode_IsSubtype m1 m2} + {~mode_IsSubtype m1 m2}.
Proof.
  intros m1 m2. destruct m1 as [(p1 & a1)|], m2 as [(p2 & a2)|].
  - destruct (mul_IsSubtype_dec p1 p2), (age_IsSubtype_dec a1 a2).
    + left. exact (mode_IsSubtypeProofPair p1 p2 a1 a2 m a).
    + right. intros contra. inversion contra. congruence.
    + right. intros contra. inversion contra. congruence.
    + right. intros contra. inversion contra. congruence.
  - left. exact (mode_IsSubtypeProofNone (Some (p1, a1))).
  - right. intros contra. inversion contra.
  - left. exact (mode_IsSubtypeProofNone None).
Defined.
Inductive mode_IsValid : mode -> Prop :=
  mode_IsValidProof : forall (pa : mul * age), mode_IsValid (Some pa).
Theorem mode_IsValid_dec : forall (m : mode), {mode_IsValid m} + {~mode_IsValid m}.
Proof.
  intros m. destruct m as [pa|].
  - left. exact (mode_IsValidProof pa).
  - right. intros contra. inversion contra.
Qed.
Inductive mode_IsLin : mode -> Prop :=
  mode_IsLinProof : forall (a : age), mode_IsLin (Some (Lin, a)).
Theorem mode_IsLin_dec : forall (m : mode), {mode_IsLin m} + {~mode_IsLin m}.
Proof.
  intros m. destruct m as [pa|].
  - destruct pa as [p a]. destruct p.
    + left. exact (mode_IsLinProof a).
    + right. intros contra. inversion contra.
  - right. intros contra. inversion contra.
Qed.
Inductive mode_IsUr : mode -> Prop :=
  mode_IsUrProof : forall (a : age), mode_IsUr (Some (Ur, a)).
Theorem mode_IsUr_dec : forall (m : mode), {mode_IsUr m} + {~mode_IsUr m}.
Proof.
  intros m. destruct m as [pa|].
  - destruct pa as [p a]. destruct p.
    + right. intros contra. inversion contra.
    + left. exact (mode_IsUrProof a).
  - right. intros contra. inversion contra.
Qed.

(******************************************************************************
 * BINDERS
 *****************************************************************************)

Definition bndr_name (b : bndr) : name :=
  match b with
  | bndr_V x m T => name_X x
  | bndr_H h T m => name_HD h
  | bndr_D h m1 T m2 => name_HD h
  end.

Definition bndr_mode (b : bndr) : mode := match b with
  | bndr_V _ m _ => m
  | bndr_H _ _ m => m
  | bndr_D _ m1 _ m2 => m1
  end.

Inductive bndr_IsVar : bndr -> Prop :=
  bndr_IsVarProof : forall x m T, bndr_IsVar (bndr_V x m T).
Theorem bndr_IsVar_dec : forall (b: bndr), {bndr_IsVar b} + {~bndr_IsVar b}.
Proof.
  intros b. destruct b.
  - left. exact (bndr_IsVarProof x m T).
  - right. intros contra. inversion contra.
  - right. intros contra. inversion contra.
Qed.

Inductive bndr_IsDest : bndr -> Prop :=
  bndr_IsDestProof : forall h m T n, bndr_IsDest (bndr_D h m T n).
Theorem bndr_IsDest_dec : forall (b: bndr), {bndr_IsDest b} + {~bndr_IsDest b}.
Proof.
  intros b. destruct b.
  - right. intros contra. inversion contra.
  - left. exact (bndr_IsDestProof h m T n).
  - right. intros contra. inversion contra.
Qed.

Inductive bndr_IsHole : bndr -> Prop :=
  bndr_IsHoleProof : forall h m T, bndr_IsHole (bndr_H h m T).
Theorem bndr_IsHole_dec : forall (b: bndr), {bndr_IsHole b} + {~bndr_IsHole b}.
Proof.
  intros b. destruct b.
  - right. intros contra. inversion contra.
  - right. intros contra. inversion contra.
  - left. exact (bndr_IsHoleProof h T n).
Qed.

(******************************************************************************
 * CONTEXTS
 *****************************************************************************)

Axiom ctx_Coherent: forall (G : CtxM.t bndr) n b, CtxM.MapsTo n b G -> (bndr_name b) = n.

Definition ctx_DestOnly (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> bndr_IsDest b.
Definition ctx_HoleOnly (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> bndr_IsHole b.
Definition ctx_VarOnly (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> bndr_IsVar b.
Definition ctx_NoDest (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> ~ (bndr_IsDest b).
Definition ctx_NoHole (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> ~ (bndr_IsHole b).
Definition ctx_NoVar (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> ~ (bndr_IsVar b).
Definition ctx_IsValid (G: CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> mode_IsValid (bndr_mode b).
Definition ctx_SubsetEq (G1 G2 : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G1 -> CtxM.MapsTo n b G2.
Definition ctx_HdnmNotMem (h : hdn) (G : CtxM.t bndr) : Prop :=
  ~CtxM.In (name_HD h) G.
Definition ctx_OnlyLin (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> mode_IsLin (bndr_mode b).
Definition ctx_OnlyUr (G : CtxM.t bndr) : Prop :=
  forall n b, CtxM.MapsTo n b G -> mode_IsUr (bndr_mode b).
Definition ctx_Disjoint (G1 G2 : CtxM.t bndr) : Prop :=
  forall n, (CtxM.In n G1 -> ~CtxM.In n G2) /\ (CtxM.In n G2 -> ~CtxM.In n G1).
Inductive ctx_Compatible : CtxM.t bndr -> bndr -> Prop :=
  | ctx_CompatibleProofV : forall G x m1 m2 T, CtxM.MapsTo (name_X x) (bndr_V x m1 T) G -> mode_IsSubtype m1 m2 -> ctx_OnlyUr (CtxM.remove (name_X x) G) -> ctx_Compatible G (bndr_V x m2 T)
  | ctx_CompatibleProofD : forall G h m11 m2 m21 T, CtxM.MapsTo (name_HD h) (bndr_D h m11 T m2) G -> mode_IsSubtype m11 m21 -> ctx_OnlyUr (CtxM.remove (name_HD h) G) -> ctx_Compatible G (bndr_D h m21 T m2)
  | ctx_CompatibleProofH : forall G h m1 m2 T, CtxM.MapsTo (name_HD h) (bndr_H h T m1) G -> mode_IsSubtype m1 m2 -> ctx_OnlyUr (CtxM.remove (name_HD h) G) -> ctx_Compatible G (bndr_H h T m2).

(* Actually a function; not really a theorem *)
Theorem ctx_add (b' : bndr) (G : CtxM.t bndr) : CtxM.t bndr.
Proof.
  destruct (CtxM.find (bndr_name b') G) eqn:eq_find.
  * (* Some b *)
    assert (CtxM.MapsTo (bndr_name b') b G). apply CtxM.find_2. exact eq_find.
    apply ctx_Coherent in H. destruct b as [x m1 T1 | h m11 T1 m12 | h T1 m1], b' as [x' m2 T2 | h' m21 T2 m22 | h' T2 m2].
    all: unfold bndr_name in H, eq_find.
    - assert (x = x') as name_eq by (injection H ; tauto). rewrite (eq_sym name_eq) in eq_find. destruct (type_eq_dec T1 T2).
      (* T1 = T2 *) exact (CtxM.add (name_X x) (bndr_V x (mode_plus m1 m2) T1) G).
      (* T1 != T2 *) all: exact (CtxM.add (name_X x) (bndr_V x None type_U) G).
    - congruence.
    - congruence.
    - congruence.
    - assert (h = h') as name_eq by (injection H ; tauto). rewrite (eq_sym name_eq) in eq_find. destruct (type_eq_dec T1 T2), (mode_eq_dec m12 m22).
      (* T1 = T2, m12 = m22 *) exact (CtxM.add (name_HD h) (bndr_D h (mode_plus m11 m21) T1 m12) G).
      (* T1 != T2 \/ m12 != m22 *) all: exact (CtxM.add (name_HD h) (bndr_D h None type_U None) G).
    - (* bndr_D vs bndr_H *) exact (CtxM.add (name_HD h) (bndr_D h None type_U None) G).
    - congruence.
    - (* bndr_H vs bndr_D *) exact (CtxM.add (name_HD h) (bndr_D h None type_U None) G).
    - assert (h = h') as name_eq by (injection H ; tauto). rewrite (eq_sym name_eq) in eq_find. destruct (type_eq_dec T1 T2).
      (* T1 = T2 *) exact (CtxM.add (name_HD h) (bndr_H h T1 (mode_plus m1 m2)) G).
      (* T1 != T2 *) all: exact (CtxM.add (name_HD h) (bndr_H h type_U None) G).
  * (* None *)
    exact (CtxM.add (bndr_name b') b' G).
Defined.

Definition ctx_from_list (bs : list bndr) : CtxM.t bndr :=
  List.fold_right (fun b G => ctx_add b G) (CtxM.empty bndr) bs.

Definition ctx_union (G1 G2 : CtxM.t bndr) : CtxM.t bndr :=
  (* G1 is acc, G2 is iterated over *)
  CtxM.fold (fun n b G => ctx_add b G) G2 G1.

Definition ctx_stimes (m1 : mode) (G : CtxM.t bndr) : CtxM.t bndr :=
  CtxM.map (fun b =>
    match b with
    | bndr_V x m2 T2 => bndr_V x (mode_times m1 m2) T2
    | bndr_D h m2 T2 m3 => bndr_D h (mode_times m1 m2) T2 m3
    | bndr_H h T2 m2 => bndr_H h T2 (mode_times m1 m2)
    end
  ) G.

Definition ctx_minus (G : CtxM.t bndr) : CtxM.t bndr :=
  CtxM.map (fun b =>
    match b with
    | bndr_V x m2 T2 => bndr_V x None type_U (* error *)
    | bndr_D h m2 T2 m3 => bndr_H h T2 m3
    | bndr_H h T2 m2 => bndr_H h type_U None (* error *)
    end
  ) G.

(*****************************************************************************)
}}

grammar

% spacing, sp :: 'sp_' ::= {{ tex \ottssp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottssp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=

% === Term syntax ===
  | âŸ¼                                     ::   :: Mapsto       {{ tex \mapsto }}
  | () :: :: unit {{ tex \ottsctor{()} }}
  | Inl :: :: inl {{ tex \ottsctor{Inl} }}
  | Inr :: :: inr {{ tex \ottsctor{Inr} }}
  | (,) :: :: prod {{ tex \ottsctor{({,})} }}
  | â¨ž :: :: fill {{ tex \triangleleft }}
  | Â· :: :: semiring {{ tex \ottsmode{\hspace{-0.1ex}\cdot\hspace{-0.1ex} } }}
  | â©² :: :: rename {{ tex \pluseq }}

% === Contexts ===
  | â¨„ :: :: union {{ tex \cupplus }}

% === Typing & Semantics ===
  | â†£ :: :: ectxarrow {{ tex \ottstype{\rightarrowtail} }}
  | âŸ¶ :: :: red {{ tex ~\longrightarrow~ }}
  | âŠ¢ :: :: vdash {{ tex \,\vdash\, }}
  | â«¦ :: :: dvdash {{ tex \,\Vdash\, }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred :: '_' ::= {{ com Serves for the .mng file. Isn't used in the actual rules }}
  | ctx_DestOnly G :: :: ctx_DestOnly {{ tex \texttt{ctx\_DestOnly}~[[G]] }}
  | ctx_HoleOnly G :: :: ctx_HoleOnly {{ tex \texttt{ctx\_HoleOnly}~[[G]] }}
  | ctx_VarOnly G :: :: ctx_VarOnly {{ tex \texttt{ctx\_VarOnly}~[[G]] }}
  | ctx_NoDest G :: :: ctx_NoDest {{ tex \texttt{ctx\_NoDest}~[[G]] }}
  | ctx_NoHole G :: :: ctx_NoHole {{ tex \texttt{ctx\_NoHole}~[[G]] }}
  | ctx_NoVar G :: :: ctx_NoVar {{ tex \texttt{ctx\_NoVar}~[[G]] }}
  | ctx_IsValid G :: :: ctx_IsValid {{ tex \texttt{ctx\_Valid}~[[G]] }}
  | ctx_SubsetEq G1 G2 :: :: ctx_SubsetEq {{ tex \texttt{ctx\_SubsetEq}~[[G1]]~[[G2]] }}
  | ctx_HdnmNotMem h G :: :: ctx_HdnmNotMem {{ tex \texttt{ctx\_NotMem}~[[h]]~[[G]] }}
  | ctx_Compatible G b :: :: ctx_Compatible {{ tex \texttt{ctx\_Compatible}~[[G]]~[[b]] }}
  | ctx_OnlyLin G :: :: ctx_OnlyLin {{ tex \texttt{ctx\_OnlyLin}~[[G]] }}
  | ctx_OnlyUr G :: :: ctx_OnlyUr {{ tex \texttt{ctx\_OnlyUr}~[[G]] }}
  | ctx_Disjoint G1 G2 :: :: ctx_Disjoint {{ tex \texttt{ctx\_Disjoint}~[[G1]]~[[G2]] }}
  | mode_IsValid m :: :: mode_IsValid {{ tex \texttt{mode\_Valid}~[[m]] }}
  | mode_IsLin m :: :: mode_IsLin {{ tex \texttt{mode\_Lin}~[[m]] }}
  | mode_IsUr m :: :: mode_IsUr {{ tex \texttt{mode\_Ur}~[[m]] }}

  | G â«¦ v : T :: :: TyR_val
  | G âŠ¢ j : T :: :: Ty_eterm
  | G â«¦ C : T :: :: TyR_ectx

parsing
ctx_U <= ctx_S
ctx_S <= ctx_M
ctx_U left ctx_U
term_Val <= term_Paren
