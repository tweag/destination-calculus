metavar tvar, x, y, d ::= {{ com Term-level variable }}
  {{ tex \ottmv{[[tvar]]} }} {{ coq string }}

metavar hvar, h ::= {{ com Hole }}
  {{ tex \otthol{[[hvar]]} }} {{ coq string }}

indexvar n ::= {{ coq nat }}

grammar

v :: 'v_' ::= {{ com Term value }}
  | < v1 ¤ w2 > D :: :: T {{ com Ampar }} {{ tex \ottcons{\langle}[[v1]]\,\ottcons{\bbcomma}~[[w2]]\ottcons{\rangle}_{[[D]]} }}
  | @ h :: :: D {{ tex \otthol{@}[[h]] }} {{ com Destination }}
  | () :: :: U {{ com Unit }}
  | Inl v :: :: L {{ com Left variant for sum }}
  | Inr v :: :: R {{ com Right variant for sum }}
  | ( v1 , v2 ) :: :: P {{ tex \ottcons{(}[[v1]]\,\ottcons{,}~[[v2]]\ottcons{)} }} {{ com Product }}
  | exp M v :: :: E {{ tex \expcons{[[M]]}[[v]] }} {{ com Exponential }}
  | \ x -> t :: :: F {{ tex \lamnt{[[x]]}{[[t]]} }} {{ com Linear function }}
  | ( v ) :: S :: Paren {{ icho [[v]] }}

w :: 'w_' ::= {{ com Pseudo-value that may contain holes }} {{ tex \ottextval{[[w]]} }}
  | v :: :: V {{ com Term value }}
  | h :: :: H {{ com Hole }}
  | Inl w :: :: L {{ com Left variant with val or hole }}
  | Inr w :: :: R {{ com Right variant with val or hole }}
  | ( w1 , w2 ) :: :: P {{ tex \ottcons{(}[[w1]]\,\ottcons{,}~[[w2]]\ottcons{)} }} {{ com Product with val or hole }}
  | exp M w :: :: E {{ tex \expcons{[[M]]}[[w]] }} {{ com Exponential with val or hole }}
  | ( w ) :: S :: Paren {{ icho [[w]] }}
  | w [ e ] :: M :: Effect {{ icho (w_eapp [[w]] [[e]]) }}

t, u :: 't_' ::=                                               {{ com Term }}
  | v :: :: V {{ com Term value }}
  | x :: :: X {{ com Variable }}
  | t & u                                    ::   :: App      {{ com Application }} {{ tex [[t]]~\succ~[[u]] }}
  | t ; u                   ::   :: PatU {{ com Pattern-match on unit }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,[[()]]\![[->]]\,[[u]] }}
  | t & \case { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatS     {{ com Pattern-match on sum }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\{\,\ottcons{Inl}\,[[x1]][[->]][[u1]]\,,~\ottcons{Inr}\,[[x2]][[->]][[u2]]\,\} }}
  | t & \case ( x1 , x2 ) -> u            ::   :: PatP     {{ com Pattern-match on product }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\ottcons{(}[[x1]]\,\ottcons{,}~[[x2]]\ottcons{)}\![[->]]\,[[u]] }}
  | t & \case exp M x -> u            ::   :: PatE     {{ com Pattern-match on exponential }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\expcons{[[M]]}[[x]][[->]]\,[[u]] }}
  | t <&> \ x -> u :: :: Map {{ com Map over the left side of the ampar }} {{ tex [[t]]~\succ\!\!\ottkw{mapL}\,[[x]]\![[->]]\,[[u]] }}

  % | toGlobal t :: :: ToGlobal {{ tex \ottkw{to}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion to ${\ottmod{\scriptstyle G} }$ }}
  % | fromGlobal t :: :: FromGlobal {{ tex \ottkw{from}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion from ${\ottmod{\scriptstyle G} }$ }}
  | toAmpar t :: :: ToA {{ tex \ottkw{to}_{[[><|]]}\,[[t]] }} {{ com Wrap $[[t]]$ into a trivial ampar }}
  | fromAmpar t :: :: FromA {{ tex \ottkw{from}_{[[><|]]}\,[[t]] }} {{ com Extract value from trivial ampar }}

  | alloc T :: :: Alloc {{ com Return a fresh "identity" ampar object }} {{ tex \ottkw{alloc}_{ [[T]]} }}
  | t <| () :: :: FillU {{ com Fill destination with unit }}
  | t <| Inl                          ::   :: FillL   {{ com Fill destination with left variant }}
  | t <| Inr                          ::   :: FillR   {{ com Fill destination with right variant }}
  | t <| (,)                              ::   :: FillP    {{ com Fill destination with product constructor }}
  | t <| exp M :: :: FillE {{ com Fill destination with exponential constructor }} {{ tex [[t]][[<|]]\expcons{[[M]]} }}
  | t <|. u :: :: FillC {{ com Fill destination with root of ampar $[[u]]$ }}

  | ( t )                                   :: S :: Paren {{ icho [[t]] }}
  | t [ x := v ]                             :: M :: Sub {{ icho (t_sub [[[x]] [[v]]) }}
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpaacing2
  % | t b spe : : S :: BreakSpacing3

% extended_term, j :: 'ExtTerm_' ::= {{ com Extended term }} {{ tex \ottextterm{[[extended_term]]} }}
%   | t :: :: Term
%   | w :: :: ExtVal

e :: 'e_' ::= {{ com Effect }} {{ tex \otteff{[[e]]} }}
  | o :: :: N {{ tex \otteff{\varepsilon} }}
  | h := w :: :: T
  | e1 , ... , en :: :: X {{ com Chain effects }}
  | ( e ) :: S :: InvisParen {{ icho [[e]] }} {{ tex [[e]] }}

% ew :: 'ew_' ::= {{ com Pair (Effect, Extended value with hole context)}}
%   | ( e , w D ) :: :: P {{ tex ([[e]],\,[[w]]\,_{[[D]]}) }}
%   | e . ew :: :: C {{ tex [[e]]~\,\hat{\cdot}\,~[[ew]] }}
%   | interact ew :: M :: I {{ icho (ew_interact [[ew]]) }}

T, U :: 'T_' ::= {{ com Type }} {{ tex \ottty{[[T]]} }}
  | I :: :: U {{ tex \ottty{1} }} {{ com Unit }}
  | T1 + T2 :: :: S {{ tex [[T1]]\ottty{\oplus}[[T2]] }} {{ com Sum }}
  | T1 * T2 :: :: P {{ tex [[T1]]\ottty{\otimes}[[T2]] }} {{ com Product }}
  | ! M T :: :: E {{ tex \ottty{!}^{[[M]]}\,[[T]] }} {{ com Exponential }}
  | T1 ><| T2 :: :: T {{ tex [[T1]]\,[[><|]]\,[[T2]] }} {{ com Ampar type (consuming $[[T1]]$ yields $[[T2]]$) }}
  | T1 M -> T2 :: :: F {{ tex [[T1]]\,_{[[M]]}\!\ottty{\to}\,[[T2]] }} {{ com Linear function }}
  | | T | M :: :: D {{ tex \,^{[[M]]}\hspace{-0.2ex}\ottty{\lfloor}[[T]]\ottty{\rfloor} }} {{ com Destination }}
  | ( T ) :: S :: Paren {{ tex \ottty{(}[[T]]\ottty{)} }} {{ icho [[T]]}}

M {{ tex \ottmod{\textsc{m} } }}, N {{ tex \ottmod{\textsc{n} } }} :: 'M_' ::= {{ tex \ottmod{[[M]]} }} {{ com Multiplicity (Semiring with product $[[.]]$) }}
  | 0 :: :: 0 {{ tex \ottmod{\nu} }} {{ com Born now. Identity of the product }}
  | 1 :: :: 1 {{ tex \ottmod{\uparrow} }} {{ com One scope older }}
  | Inf :: :: Inf {{ tex \ottmod{\infty} }} {{ com Infinitely old / static. Absorbing for product }}
  | M1 . ... . Mn :: :: X {{ com Semiring product }}
  | ( M ) :: S :: Paren {{ tex \ottmod{(}[[M]]\ottmod{)} }} {{ icho [[M]] }}

% C :: 'C_' ::= {{ com Typing context }}
%   | G    ::   :: P
%   | D ::    :: N
%   | G u D :: :: S {{ tex [[G]]\mathrel{\raisebox{1pt}{\scalebox{0.5}{$\sqcup$}\!\! } }[[D]] }}
% %  | M . D :: M :: X {{ com Increase age of bindings by $[[M]]$ }} {{ tex [[M]][[.]][[D]] }}
%   | ( C ) :: S :: Paren {{ icho [[C]] }}

C :: 'C_' ::= {{ com Context }}
  | PC :: :: P
  | NC :: :: N

PC, G {{ tex \Gamma }} :: 'PC_' ::= {{ com Positive typing context }}
  | { PA1 , .. , PAn } :: :: L
  | M . G :: :: X {{ com Increase age of bindings by $[[M]]$ }} {{ icho (PC_times [[M]] [[G]]) }}
  | G1 µ G2 :: :: U {{ icho (PC_union [[G1]] [[G2]]) }}
  | ( G ) :: S :: Paren {{ icho [[G]] }}

PA :: 'PA_' ::= {{ com Positive type assignment }}
  | x : M T :: :: V {{ com Variable }} {{ tex [[x]]:_{[[M]]}[[T]] }}
  | @ h : M | T | N :: :: D {{ com Destination ($[[M]]$ is its own age; $[[N]]$ is the age of values it accepts) }} {{ tex \otthol{@}[[h]]:_{[[M]]}\,\!^{[[N]]}\!\ottty{\lfloor}[[T]]\ottty{\rfloor} }}

NC, D {{ tex \Delta }} :: 'NC_' ::= {{ com Negative typing context }}
  | { NA1 , .. , NAn } :: :: L
  | M . D :: :: X {{ com Increase age of bindings by $[[M]]$ }} {{ tex \topprod{[[M]]}[[D]] }} {{ icho (NC_times [[M]] [[D]]) }}
  | - G :: :: M  {{ tex \otthol{@^{\scriptscriptstyle\text{-}1} }[[G]] }} {{ com Invert the sign of the context }} {{ icho (NC_minus [[G]]) }}
  | D1 µ D2    :: :: U {{ icho (NC_dunion [[D1]] [[D2]]) }}
  | ( D ) :: S :: Paren {{ icho [[D]] }}

NA :: 'NA_' ::= {{ com Negative type assignment }}
  | h : N T :: :: Hole {{ com Hole ($[[N]]$ is the age of values it accepts, its own age is undefined) }} {{ tex [[h]]:^{[[N]]}[[T]] }}

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=
% === Type syntax ===
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | ><| :: :: rtimes {{ tex \ottty{\rtimes} }}

% === Term syntax ===
  | ->                                     ::   :: mapsto       {{ tex \mapsto }}
  | () :: :: unit {{ tex \ottcons{()} }}
  | Inl :: :: inl {{ tex \ottcons{Inl} }}
  | Inr :: :: inr {{ tex \ottcons{Inr} }}
  | (,) :: :: prod {{ tex \ottcons{({,})} }}
  | <| :: :: fill {{ tex \triangleleft }}
  | <|. :: :: fillcomp {{ tex \triangleleft\!\mybullet\, }}
  | := :: :: assign {{ tex \coloneq }}
  | '.' :: :: semiring {{ tex \ottmod{\hspace{-0.1ex}\cdot\hspace{-0.1ex} } }}

% === Contexts ===
  | µ :: :: dunion {{ tex \sqcup }}
%  | µ+ :: :: sdunion {{ tex \,\text{\makebox[0pt][l]{$\sqcup$}\raisebox{.40ex}{\hspace{.15ex}$\scriptscriptstyle\pm$} } }}
%  | '{}' :: :: empty {{ tex \emptyset }}

% === Judgements ===
%  | exists :: :: exists {{ tex \exists }}
%  | != :: :: neq {{ tex \neq }}
%  | <= :: :: leq {{ tex \leq }}
%  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
%  | includedin :: :: includedin {{ tex \subset }}
  % | names :: :: names {{ tex \mathcal{N} }}

% === Typing ===
  | |- :: :: turnstile {{ tex \,\vdash\, }}
  | ||- :: :: dturnstile {{ tex \,\Vdash\, }}

% === Semantics ===
  | '~>' :: :: effred {{ tex \rightsquigarrow }}
  | '<>' :: :: diam {{ tex \diamond }}
  | '|' :: :: eff {{ tex ~|~ }}
  | !! :: :: downto {{ tex ~\Downarrow~ }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Used only to allow predicates in body text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

P :: '_' ::=
  | C1 ## C2 :: :: C_D {{ tex [[dom]]([[C1]]) \cap [[dom]]([[C2]]) = \emptyset }}
  | h notin dom ( C ) :: :: C_NI{{ tex [[h]] \notin [[dom]]([[C]]) }}
  | destOnly G :: :: PC_DO
  | fresh h :: :: C_FH
  | G u D ||- e :: :: Ty_e {{ com Typing of effects (require both positive and negative contexts) }}
  | G |- v <> e : T :: :: Ty_c {{ com Typing of commands (only a positive context is needed) }}
  | G u D ||- w : T :: :: Ty_w {{ com Typing of extended values (require both positive and negative contexts) }}
  | G |- t : T :: :: Ty_t {{ com Typing of terms (only a positive context is needed) }}
  | w1 D1 | e1 ~> w2 D2 | e2 :: :: Sem_e {{ com Semantics of effects }}
  | t !! v <> e :: :: Sem_t {{ com Big-step evaluation into commands }}

parsing
PC_U <= PC_X
NC_U <= NC_M
NC_U <= NC_X
