embed
{{ coq
Require Import Ott.ext_nat.
Require Import Coq.Structures.Equalities.
Require Import Coq.Structures.Orders.
Require Import Coq.Structures.OrdersAlt.
Require Import Coq.Structures.OrdersEx.
Require Import Coq.FSets.FMapWeakList.
Require Import Coq.FSets.FMapFacts.
}}

metavar tvar, x, y ::= {{ com Term-level variable name }}
  {{ tex \ottmv{[[tvar]]} }} {{ coq nat }}

metavar hvar, h ::= {{ com Hole or destination name }}
  {{ tex \ottshvar{[[hvar]]} }} {{ coq nat }}

indexvar k ::= {{ coq nat }} {{ com Index for ranges }}

embed
{{ coq
(* Will be aliased later to mul *)
Inductive _mul : Type :=
  | Lin : _mul
  | Ur : _mul.

Definition mul_times (p1 p2: _mul) : _mul :=
  match p1, p2 with
  | Lin, Lin => Lin
  | _, _ => Ur
  end.

Definition mul_times' (pl: list _mul) : _mul :=
  List.fold_left mul_times pl Lin.
}}

grammar

mul, p :: 'mul_' ::= {{ tex \ottsmoda{[[mul]]} }} {{ com Multiplicity (first component of modality) }} {{ coq _mul }}
  | 1 :: :: Lin {{ tex \ottsmoda{1} }} {{ com Linear. Neutral element of the product }} {{ coq Lin }}
  | œâ :: :: Ur {{ tex \ottsmoda{\omega} }} {{ com Non-linear. Absorbing for the product }} {{ coq Ur }}
  | p1 . ... . pk :: :: P {{ com Semiring product }} {{ coq (mul_times' [[p1...pk]]) }}
  | ( p ) :: S :: Paren {{ tex \ottsmoda{(}[[p]]\ottsmoda{)} }} {{ coq [[p]] }}

age, a :: 'age_' ::= {{ tex \ottsmoda{[[age]]} }} {{ com Age (second component of modality) }} {{ coq ext_nat }}
  | ŒΩ :: :: 0 {{ tex \ottsmoda{\nu} }} {{ com Born now. Neutral element of the product }} {{ coq (Fin 0) }}
  | ‚Üë :: :: 1 {{ tex \ottsmoda{\uparrow} }} {{ com One scope older }} {{ coq (Fin 1) }}
  | ‚àû :: :: Inf {{ tex \ottsmoda{\infty} }} {{ com Infinitely old / static. Absorbing for the product }} {{ coq Inf }}
  | a1 ¬∑ ... ¬∑ ak :: :: P {{ com Semiring product }} {{ coq (age_times' [[a1...ak]]) }}
  | ( a ) :: S :: Paren {{ tex \ottsmoda{(}[[a]]\ottsmoda{)} }} {{ coq [[a]] }}

moda, m, n :: 'moda_' ::= {{ tex \ottsmoda{[[moda]]} }} {{ com Modality (Semiring) }} {{ coq (mul * age) }}
  | p | a :: :: C {{ com Pair of a multiplicity and age }} {{ tex [[p]]\ottsmoda{|}[[a]] }} {{ coq (pair [[p]] [[a]]) }}
  | 1ŒΩ :: :: Lin0 {{ tex \ottsmoda{\underline{\nu} } }} {{ com Neutral element of the product. Notation for $\ottsmoda{1 | \nu}$. }} {{ coq (pair Lin (Fin 0)) }}
  | 1‚Üë :: :: Lin1 {{ tex \ottsmoda{\underline{\uparrow} } }} {{ com Same multiplicity, but one scope older. Notation for $\ottsmoda{1 | \uparrow}$. }} {{ coq (pair Lin (Fin 1)) }}
  | 1‚àû :: :: LinInf {{ tex \ottsmoda{\underline{\infty} } }} {{ com Linear, infinitely old / static. Notation for $\ottsmoda{1 | \infty}$. }} {{ coq (pair Lin Inf) }}
  | m1 ¬∑ ... ¬∑ mk :: :: P {{ com Semiring product }} {{ coq (moda_times' [[m1...mk]]) }}
  | ( m ) :: S :: Paren {{ tex \ottsmoda{(}[[m]]\ottsmoda{)} }} {{ coq [[m]] }}

typ, T, U :: 'typ_' ::= {{ com Type }} {{ tex \ottstyp{[[typ]]} }}
  | ùüè :: :: U {{ tex \ottstyp{1} }} {{ com Unit }}
  | T1 ‚®Å T2 :: :: S {{ tex [[T1]]\ottstyp{\oplus}[[T2]] }} {{ com Sum }}
  | T1 ‚®Ç T2 :: :: P {{ tex [[T1]]\ottstyp{\otimes}[[T2]] }} {{ com Product }}
  | ! m T :: :: E {{ tex \ottstyp{!}^{[[m]]}\,[[T]] }} {{ com Exponential }}
  | T1 ‚ßï T2 :: :: A {{ tex [[T1]]\,\ottstyp{\rtimes}\,[[T2]] }} {{ com Ampar type (consuming $[[T1]]$ yields $[[T2]]$) }}
  | T1 m1 ‚Üí T2 :: :: F {{ tex [[T1]]\,_{[[m1]]}\!\ottstyp{\to}\,[[T2]] }} {{ com Linear function }}
  | m ‚åä T ‚åã :: :: D {{ tex \,^{[[m]]}\hspace{-0.2ex}\ottstyp{\lfloor}[[T]]\ottstyp{\rfloor} }} {{ com Destination }}
  | ( T ) :: S :: Paren {{ tex \ottstyp{(}[[T]]\ottstyp{)} }} {{ coq [[T]]}}

pas :: 'pas_' ::= {{ com Positive type assignment }}
  | x : m T :: :: V {{ com Variable }} {{ tex [[x]]:_{[[m]]}[[T]] }}
  | @ h : m n ‚åä T ‚åã :: :: D {{ com Destination ($[[m]]$ is its own modality; $[[n]]$ is the modality for values it accepts) }} {{ tex \ottshvar{@}[[h]]:_{[[m]]}\,\!^{[[n]]}\!\ottstyp{\lfloor}[[T]]\ottstyp{\rfloor} }}

nas :: 'nas_' ::= {{ com Negative type assignment }}
  | h : n T :: :: H {{ com Hole ($[[n]]$ is the modality for values it accepts, it doesn't have a modality on its own) }} {{ tex [[h]]:^{[[n]]}[[T]] }}

embed
{{ coq
Inductive name : Type :=
  | name_X : tvar ‚Üí name
  | name_HD : hvar ‚Üí name.

Module Name_as_UDT <: UsualDecidableType.
  Definition t := name.

  Definition eq := @eq name.
  Definition eq_refl := @eq_refl name.
  Definition eq_sym := @eq_sym name.
  Definition eq_trans := @eq_trans name.

  (* Define the eq_dec function *)
  Theorem eq_dec : forall x y : name, {x = y} + {x <> y}.
  Proof.
    intros x y. induction x.
    - induction y.
        + assert ({t0 = t1} + {t0 <> t1}) by apply Nat.eq_dec. destruct H.
           * left. rewrite e. reflexivity.
           * right. congruence.
        + right. congruence.
    - induction y.
        + right. congruence.
        + assert ({h = h0} + {h <> h0}) by apply Nat.eq_dec. destruct H.
           * left. rewrite e. reflexivity.
           * right. congruence.
    Defined.

  Instance eq_equiv : Equivalence Name_as_UDT.eq. split. exact eq_refl. exact eq_sym. exact eq_trans. Defined.

End Name_as_UDT.

Module Name_as_UDTOrig := Backport_DT(Name_as_UDT).
Module CtxM := FMapWeakList.Make(Name_as_UDTOrig).

Definition age_times (a1 a2 : age) : age := ext_plus a1 a2.
Definition age_times' (al: list age) : age := ext_plus' al.

Definition moda_times (m1 m2: moda) : moda :=
  match m1, m2 with
  | (p1, a1), (p2, a2) => (mul_times p1 p2, age_times a1 a2)
  end.

Definition moda_times' (ml: list moda) : moda :=
  fold_left moda_times ml (Lin, Fin 0).

Definition pas_name (b : pas) : name :=
  match b with
  | pas_V x m2 T2 => name_X x
  | pas_D h m2 T2 m3 => name_HD h
  end.

Definition nas_name (b : nas) : name :=
  match b with
  | nas_H h m2 T2 => name_HD h
  end.

(* Will be aliased later to ctx *)
Inductive _ctx : Type :=
  | Ctx : forall (b : Type), (b ‚Üí name) ‚Üí CtxM.t b ‚Üí _ctx.

Definition P (G : CtxM.t pas) : _ctx := Ctx pas pas_name G.
Definition N (D : CtxM.t nas) : _ctx := Ctx nas nas_name D.

Definition pas_IsDest (b: pas) : Prop :=
  match b with
    | pas_V _ _ _ => False
    | pas_D _ _ _ _ => True
  end.

Definition ctx_Disjoint (C1 C2 : _ctx ) : Prop := match C1, C2 with
  | Ctx _ _ C1', Ctx _ _ C2' => forall n, ~(CtxM.In n C1' /\ CtxM.In n C2')
  end.

Definition ctx_NotMem (n : name) (C : _ctx ) : Prop := match C with
  | Ctx _ _ C' => ~ (CtxM.In n C')
  end.

Definition ctx_HvarNotMem (h : hvar) (C : _ctx ) : Prop := ctx_NotMem (name_HD h) C.

Definition ctx_Coherent (C : _ctx ) : Prop := match C with
  | Ctx _ name_proj C' => forall n b, CtxM.MapsTo n b C' ‚Üí name_proj b = n
  end.

Axiom all_pctx_Coherent: forall (G : CtxM.t pas), ctx_Coherent (P G).
Axiom all_nctx_Coherent: forall (D : CtxM.t nas), ctx_Coherent (N D).

Definition pctx_DestOnly (G : CtxM.t pas) : Prop :=
  forall n b, CtxM.MapsTo n b G ‚Üí pas_IsDest b.

Definition pctx_add (b : pas) (G : CtxM.t pas) (hyp: ctx_NotMem (pas_name b) (P G)) : CtxM.t pas :=
  CtxM.add (pas_name b) b G.

Definition pctx_from_list_unsafe (bs : list pas) : CtxM.t pas :=
  List.fold_left (fun G b => CtxM.add (pas_name b) b G) bs (CtxM.empty pas).

Definition nctx_add (b : nas) (D : CtxM.t nas) (hyp: ctx_NotMem (nas_name b) (N D)) : CtxM.t nas :=
  CtxM.add (nas_name b) b D.

Definition nctx_from_list_unsafe (bs : list nas) : CtxM.t nas :=
  List.fold_left (fun G b => CtxM.add (nas_name b) b G) bs (CtxM.empty nas).

Definition pctx_union (G1 G2 : CtxM.t pas) (hyp: ctx_Disjoint (P G1) (P G2)) : CtxM.t pas :=
  CtxM.fold (fun n b G => CtxM.add n b G) G2 G1.

Definition pctx_sprod (m1 : moda) (G : CtxM.t pas) : CtxM.t pas :=
  CtxM.map (fun b =>
    match b with
    | pas_V x m2 T2 => pas_V x (moda_times m1 m2) T2
    | pas_D h m2 T2 m3 => pas_D h (moda_times m1 m2) T2 m3
    end
  ) G.

Definition nctx_union (D1 D2 : CtxM.t nas) (hyp: ctx_Disjoint (N D1) (N D2)) : CtxM.t nas :=
  CtxM.fold (fun n b D => CtxM.add n b D) D2 D1.

Definition nctx_sprod (m1 : moda) (D : CtxM.t nas) : CtxM.t nas :=
  CtxM.map (fun b =>
    match b with
    | nas_H h m2 T2 => nas_H h (moda_times m1 m2) T2
    end
  ) D.

Definition nctx_minus (G : CtxM.t pas) (hyp: pctx_DestOnly G) : CtxM.t nas :=
  CtxM.map (fun b =>
    match b with
    | pas_V x m T => nas_H 0 (pair Lin (Fin 0)) typ_U (* Error case, TODO use hyp to remove this branch *)
    | pas_D h m T n => nas_H h (moda_times m n) T
    end
  ) G.
}}

grammar
pctx, G {{ tex \Gamma }} :: 'pctx_' ::= {{ com Positive typing context }} {{ coq (CtxM.t pas) }}
  | { pas1 , .. , pask } :: :: L {{ coq (pctx_from_list_unsafe [[pas1..pask]]) }}
  | m ¬∑ G :: :: S {{ com Multiply each binding by $[[m]]$ }} {{ coq (pctx_sprod [[m]] [[G]]) }}
  | G1 ‚à™ G2 :: :: U {{ coq (pctx_union [[G1]] [[G2]]) }}
  | ( G ) :: S :: Paren {{ coq [[G]] }}

nctx, D {{ tex \Delta }} :: 'nctx_' ::= {{ com Negative typing context }} {{ coq (CtxM.t nas) }}
  | { nas1 , .. , nask } :: :: L {{ coq (nctx_from_list_unsafe [[nas1..nask]]) }}
  | m ¬∑ D :: :: S {{ com Multiply each binding by $[[m]]$ }} {{ tex \topprod{[[m]]}[[D]] }} {{ coq (nctx_sprod [[m]] [[D]]) }}
  | - G :: :: M  {{ tex \ottshvar{@^{\scriptscriptstyle\text{-}1} }[[G]] }} {{ com Maps each destination of $[[G]]$ to a hole (requires \texttt{ctx\_DestOnly} $[[G]]$) }} {{ coq (nctx_minus [[G]]) }}
  | D1 ‚à™ D2   :: :: U {{ coq (nctx_union [[D1]] [[D2]]) }}
  | ( D ) :: S :: Paren {{ coq [[D]] }}

ctx, C :: 'ctx_' ::= {{ com Context }} {{ coq _ctx }}
  | P pctx :: :: P {{ coq (P [[pctx]]) }} {{ tex [[pctx]] }}
  | N nctx :: :: N {{ coq (N [[nctx]]) }} {{ tex [[nctx]] }}
  | ( C ) :: S :: InvisParen {{ coq [[C]] }} {{ tex [[C]] }}

grammar
term, t, u :: 'term_' ::=                                               {{ com Term }}
  | v :: :: Val {{ com Term value }}
  | x :: :: Var {{ com Variable }}
  | t ‚âª u                                    ::   :: App      {{ com Application }} {{ tex [[t]]\,\succ[[u]] }}
  % | t ; u                   ::   :: PatU {{ com Pattern-match on unit }} {{ tex [[t]]\,\succ\,\ottkw{case}\,\ottsctor{()}\,\mapsto\,[[u]] }}
  | t ; u                   ::   :: PatU {{ com Pattern-match on unit }} {{ tex [[t]]~;\,[[u]] }}
  | t ‚âª case { Inl x1 ‚üº u1 , Inr x2 ‚üº u2 }   ::   :: PatS (+ bind x1 in u1 +) (+ bind x2 in u2 +)     {{ com Pattern-match on sum }} {{ tex [[t]]\,\succ\ottkw{case}\,\{\,\ottsctor{Inl}\,[[x1]][[‚üº]][[u1]]\,,~\ottsctor{Inr}\,[[x2]][[‚üº]][[u2]]\,\} }}
  | t ‚âª case ( x1 , x2 ) ‚üº u            ::   :: PatP (+ bind x1 in u +) (+ bind x2 in u +)     {{ com Pattern-match on product }} {{ tex [[t]]\,\succ\ottkw{case}\,\ottsctor{(}[[x1]]\,\ottsctor{,}~[[x2]]\ottsctor{)}\![[‚üº]][[u]] }} 
  | t ‚âª case ‚¶Ü m x ‚üº u            ::   :: PatE (+ bind x in u +)    {{ com Pattern-match on exponential }} {{ tex [[t]]\,\succ\ottkw{case}~\expcons{[[m]]}[[x]][[‚üº]][[u]] }}
  | t ‚âª map x ‚üº u :: :: Map (+ bind x in u +) {{ com Map over the left side of the ampar }} {{ tex [[t]]\,\succ\ottkw{map}~[[x]]\![[‚üº]][[u]] }}

  % | toGlobal t :: :: ToGlobal {{ tex \ottkw{to}_{\ottsmoda{\scriptstyle G} } }} {{ com Mode coercion to ${\ottsmoda{\scriptstyle G} }$ }}
  % | fromGlobal t :: :: FromGlobal {{ tex \ottkw{from}_{\ottsmoda{\scriptstyle G} } }} {{ com Mode coercion from ${\ottsmoda{\scriptstyle G} }$ }}
  | to‚ßï t :: :: ToA {{ tex \ottkw{to}_{\ottstyp{\rtimes} }\,[[t]] }} {{ com Wrap $[[t]]$ into a trivial ampar }}
  | from‚ßï t :: :: FromA {{ tex \ottkw{from}_{\ottstyp{\rtimes} }\,[[t]] }} {{ com Extract value from trivial ampar }}

  | alloc T :: :: Alloc {{ com Return a fresh "identity" ampar object }} {{ tex \ottkw{alloc}_{ [[T]]} }}
  | t ‚®û () :: :: FillU {{ com Fill destination with unit }}
  | t ‚®û Inl                          ::   :: FillL   {{ com Fill destination with left variant }}
  | t ‚®û Inr                          ::   :: FillR   {{ com Fill destination with right variant }}
  | t ‚®û (,)                              ::   :: FillP    {{ com Fill destination with product constructor }}
  | t ‚®û ‚¶Ü m :: :: FillE {{ com Fill destination with exponential constructor }} {{ tex [[t]][[‚®û]]\expcons{[[m]]} }}
  | t ‚®û¬∑ u :: :: FillC {{ com Fill destination with root of ampar $[[u]]$ }} {{ tex [[t]]\triangleleft\!\mybullet\,[[u]] }}

  | ( t )                                   :: S :: Paren {{ coq [[t]] }}
  | t [ x ‚âî v ]                             :: M :: Sub {{ coq (term_sub [[t]] [[x]] [[v]]) }} {{ tex [[t]][ [[x]] \coloneq [[v]] ] }}
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpaacing2
  % | t b spe : : S :: BreakSpacing3

val, v :: 'val_' ::= {{ com Term value }}
  | ‚ü® v1 ‚ùü w2 ‚ü© D :: :: A {{ com Ampar }} {{ tex \ottsctor{\langle}[[v1]]\,\ottsctor{\bbcomma}~[[w2]]\ottsctor{\rangle}_{[[D]]} }}
  | @ h :: :: D {{ tex \ottshvar{@}[[h]] }} {{ com Destination }}
  | () :: :: U {{ com Unit }}
  | Inl v :: :: L {{ com Left variant for sum }}
  | Inr v :: :: R {{ com Right variant for sum }}
  | ( v1 , v2 ) :: :: P {{ tex \ottsctor{(}[[v1]]\,\ottsctor{,}~[[v2]]\ottsctor{)} }} {{ com Product }}
  | ‚¶Ü m v :: :: E {{ tex \expcons{[[m]]}[[v]] }} {{ com Exponential }}
  | Œª x ‚üº t :: :: F (+ bind x in t +) {{ tex \lamnt{[[x]]}{[[t]]} }} {{ com Linear function }}
  | ( v ) :: S :: Paren {{ coq [[v]] }}

xval, w :: 'xval_' ::= {{ com Pseudo-value that may contain holes }} {{ tex \ottsxval{[[xval]]} }}
  | v :: :: V {{ com Term value }}
  | h :: :: H {{ com Hole }}
  | Inl w :: :: L {{ com Left variant with val or hole }}
  | Inr w :: :: R {{ com Right variant with val or hole }}
  | ( w1 , w2 ) :: :: P {{ tex \ottsctor{(}[[w1]]\,\ottsctor{,}~[[w2]]\ottsctor{)} }} {{ com Product with val or hole }}
  | ‚¶Ü m w :: :: E {{ tex \expcons{[[m]]}[[w]] }} {{ com Exponential with val or hole }}
  | ( w ) :: S :: Paren {{ coq [[w]] }}
  | w [ e ] :: M :: Effect {{ coq (xval_effapp [[w]] [[e]]) }}

eff, e :: 'eff_' ::= {{ com Effect }} {{ tex \ottseff{[[eff]]} }}
  | Œµ :: :: n {{ tex \ottseff{\varepsilon} }}
  | h ‚âî w :: :: A {{ tex [[h]]\coloneq[[w]] }}
  | e1 , ... , ek :: :: P {{ com Chain effects }}
  | ( e ) :: S :: Paren {{ coq [[e]] }}

embed
{{ coq
Definition term_sub (t: term) (x : tvar) (v : val) : term := t.
(* TODO *)
Definition xval_effapp (w : xval) (e : eff) : xval := w.
(* TODO *)
}}

grammar

% spacing, sp :: 'sp_' ::= {{ tex \ottssp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottssp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=

% === Term syntax ===
  | ‚üº                                     ::   :: Mapsto       {{ tex \mapsto }}
  | () :: :: unit {{ tex \ottsctor{()} }}
  | Inl :: :: inl {{ tex \ottsctor{Inl} }}
  | Inr :: :: inr {{ tex \ottsctor{Inr} }}
  | (,) :: :: prod {{ tex \ottsctor{({,})} }}
  | ‚®û :: :: fill {{ tex \triangleleft }}
  | ¬∑ :: :: semiring {{ tex \ottsmoda{\hspace{-0.1ex}\cdot\hspace{-0.1ex} } }}

% === Contexts ===
  | ‚à™ :: :: union {{ tex \cup }}
  | ‚ó° :: :: sunion {{ tex ~{\scriptscriptstyle\cup}~ }}

% === Typing & Semantics ===
  | ‚§ã :: :: effred {{ tex ~\downdownarrows~ }}
  | ‚ãÑ :: :: diam {{ tex ~\diamond~ }}
  | ‚áì :: :: downto {{ tex ~\Downarrow~ }}
  | ‚ä¢ :: :: vdash {{ tex \,\vdash\, }}
  | ‚´¶ :: :: dvdash {{ tex \,\Vdash\, }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred :: '_' ::= {{ com Serves for the .mng file. Isn't used in the actual rules }}
  | ctx_Disjoint C1 C2 :: :: ctx_Disjoint {{ tex \texttt{ctx\_Disjoint}~[[C1]]~[[C2]] }}
  | ctx_HvarNotMem h C :: :: ctx_HvarNotMem {{ tex \texttt{ctx\_NotMem}~[[h]]~[[C]] }}
  | pctx_DestOnly G :: :: pctx_DestOnly {{ tex \texttt{pctx\_DestOnly}~[[G]] }}
  | hvar_Fresh h :: :: hvar_Fresh {{ tex \texttt{hvar\_Fresh}~[[h]] }}
  | G ‚ó° D ‚´¶ e :: :: Ty_eff
  | G ‚ä¢ v ‚ãÑ e : T :: :: Ty_cmd
  | G ‚ó° D ‚´¶ w : T :: :: Ty_xval
  | G ‚ä¢ t : T :: :: Ty_term
  | w1 D1 | e1 ‚§ã w2 D2 | e2 :: :: Sem_eff {{ tex [[w1]]_{~[[D1]]}\,|~[[e1]]~~[[‚§ã]]~~[[w2]]_{~[[D2]]}\,|~[[e2]] }}
  | t ‚áì v ‚ãÑ e :: :: Sem_term

parsing
pctx_U <= pctx_S
nctx_U <= nctx_M
nctx_U <= nctx_S