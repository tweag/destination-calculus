embed
{{ coq
Require Import Ott.ext_nat.
Require Import Coq.Structures.Equalities.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.Arith.Compare_dec.
Require Import Coq.MSets.MSetList.
Require Import Coq.MSets.MSetFacts.
Require List.
(* Grumble, grumble: we shouldn't need to Import Ott.Finitely, but if
   we don't we can't use the coercions. *)
Require Import Ott.Finitely.

Module Nat' <: OrderedTypeWithLeibniz.
  Include PeanoNat.Nat.
  Lemma eq_leibniz : forall x y, eq x y -> x = y.
  Proof. trivial.
  Qed.
End Nat'.
Module HdnsM := MSetList.MakeWithLeibniz(Nat').
Module HdnsFactsM := MSetFacts.Facts(HdnsM).

(* We need to predefine eq_dec for mode so that Ott can generate eq_dec for type *)
(* Will be aliased later to mul *)
Inductive _mul : Type :=
  | Lin : _mul
  | Ur : _mul.
Theorem mul_eq_dec : forall (p1 p2: _mul), {p1 = p2} + {p1 <> p2}.
Proof.
  decide equality.
Defined.
Definition age_eq_dec : forall (a1 a2: ext_nat), {a1 = a2} + {a1 <> a2} := ext_eq_dec.
Theorem mode_eq_dec : forall (m1 m2: option (_mul * ext_nat)), {m1 = m2} + {m1 <> m2}.
Proof.
  decide equality. destruct a, p.
  - destruct (mul_eq_dec _m _m0), (age_eq_dec e e0); subst; auto.
    * right. congruence.
    * right. congruence.
    * right. congruence.
Defined.
}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NAMES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

metavar var, x, y ::= {{ com Term-level variable name }}
 {{ tex \ottmv{[[var]]} }} {{ coq nat }}

indexvar k ::= {{ coq nat }} {{ com Index for ranges }}

grammar

hdn, h :: 'hdn_' ::= {{ com Hole or destination name ($\mathbb{N}$) }} {{ coq nat }} {{ tex \ottshdn{[[hdn]]} }}
  | 1 :: S :: O {{ coq 1 }} {{ tex \ottshdn{1} }}
  | 2 :: S :: T {{ coq 2 }} {{ tex \ottshdn{2} }}
  | h + h' :: M :: A {{ coq ([[h]] + [[h']]) }} {{ tex [[h]]\ottshdn{+}[[h']] }}
  | h [ H ⩲ h' ] :: M :: S {{ com Shift by $[[h']]$ if $[[h]] \in [[H]]$ }} {{ coq (hdn_shift [[h]] [[H]] [[h']]) }} {{ tex [[h]]\ottshdn{[}[[H]][[⩲]][[h']]\ottshdn{]} }}
  | max ( H ) :: M :: M {{ com Maximum of a set of holes }} {{ coq (hdns_max [[H]]) }} {{ tex \ottshdn{max(}[[H]]\ottshdn{)} }}
  | ( h ) :: S :: Paren {{ coq [[h]] }} {{ tex \ottshdn{(}[[h]]\ottshdn{)} }}

hdns, H :: 'hdns_' ::= {{ com Set of hole names }} {{ coq HdnsM.t }} {{ tex \ottshdn{[[hdns]]} }}
  | { h1 , .. , hk } :: :: L {{ coq (hdns_from_list [[h1..hk]]) }}
  | H1 ∪ H2 :: M :: U {{ com Union of sets }} {{ coq (HdnsM.union [[H1]] [[H2]]) }} {{ tex [[H1]]\ottshdn{\cup}\,[[H2]] }}
  | H ⩲ h' :: M :: S {{ com Shift all names from $[[H]]$ by $[[h']]$. }} {{ coq (hdns_shift [[H]] [[h']]) }}
  | hnames ( G ) :: M :: C {{ com Hole names of a context (requires $\texttt{ctx\_NoVar}([[G]])$) }} {{ tex \ottshdn{hnames(}[[G]]\ottshdn{)} }} {{ coq (hdns_from_ctx [[G]]) }}
  | hnames ( C ) :: M :: E {{ com Hole names of an evaluation context }} {{ tex \ottshdn{hnames(}[[C]]\ottshdn{)} }} {{ coq (hdns_from_ectxs [[C]]) }}
  | ( H ) :: S :: Paren {{ coq [[H]] }} {{ tex \ottshdn{(}[[H]]\ottshdn{)} }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LANGUAGE SYNTAX (STATIC)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

term, t, u :: 'term_' ::= {{ com Term }}
  | v :: :: Val {{ com Value }}
  | x :: :: Var {{ com Variable }}
  | t ≻ t' :: :: App {{ com Application }} {{ tex [[t]]\,\succ[[t']] }}
  | t ; u :: :: PatU {{ com Pattern-match on unit }} {{ tex [[t]]~;\,[[u]] }}
  | t ≻case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } :: :: PatS {{ com Pattern-match on sum }} {{ tex [[t]]\,\succ\ottkw{case}_{[[m]]}\,\{\,\ottsctor{Inl}\,[[x1]][[⟼]][[u1]]\,,~\ottsctor{Inr}\,[[x2]][[⟼]][[u2]]\,\} }} % (+ bind x1 in u1 +) (+ bind x2 in u2 +)
  | t ≻case m ( x1 , x2 ) ⟼ u :: :: PatP {{ com Pattern-match on product }} {{ tex [[t]]\,\succ\ottkw{case}_{[[m]]}\,\ottsctor{(}[[x1]]\,\ottsctor{,}~[[x2]]\ottsctor{)}\![[⟼]][[u]] }} % (+ bind x1 in u +) (+ bind x2 in u +)
  | t ≻case m ᴇ n x ⟼ u :: :: PatE {{ com Pattern-match on exponential }} {{ tex [[t]]\,\succ\ottkw{case}_{[[m]]}\,\expcons{[[n]]}[[x]][[⟼]][[u]] }} % (+ bind x in u +)
  | t ≻map x ⟼ t' :: :: Map {{ com Map over the right side of ampar $[[t]]$ }} {{ tex [[t]]\,\succ\ottkw{map}~[[x]]\![[⟼]][[t']] }} % (+ bind x in u +
  | to⧔ u :: :: ToA {{ tex \ottkw{to}_{\ottstype{\ltimes} }\,[[u]] }} {{ com Wrap $[[u]]$ into a trivial ampar }}
  | from⧔ t :: :: FromA {{ tex \ottkw{from}_{\ottstype{\ltimes} }\,[[t]] }} {{ com Extract value from trivial ampar }}

  | alloc :: :: Alloc {{ com Return a fresh "identity" ampar object }} {{ tex \ottkw{alloc} }}
  | t ⨞ () :: :: FillU {{ com Fill destination with unit }}
  | t ⨞ Inl :: :: FillL {{ com Fill destination with left variant }}
  | t ⨞ Inr :: :: FillR {{ com Fill destination with right variant }}
  | t ⨞ ᴇ m :: :: FillE {{ com Fill destination with exponential constructor }} {{ tex [[t]][[⨞]]\expcons{[[m]]} }}
  | t ⨞ (,) :: :: FillP {{ com Fill destination with product constructor }}
  | t ⨞ ( λ x m ⟼ u ) :: :: FillF {{ com Fill destination with function }} {{ tex [[t]][[⨞]](\lamnt{[[x]]}{[[m]]}{[[u]]}) }} % (+ bind x in u +)
  | t ⨞· t' :: :: FillC {{ com Fill destination with root of ampar $[[t']]$ }} {{ tex [[t]]\triangleleft\!\mybullet\,[[t']] }}

  | t [ x ≔ v ] :: M :: Sub {{ coq (term_sub [[t]] [[x]] [[v]]) }} {{ tex [[t]][ [[x]] \coloneq [[v]] ] }}
  | ( t ) :: S :: Paren {{ coq [[t]] }}
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpaacing2
  % | t b spe : : S :: BreakSpacing3

val, v :: 'val_' ::= {{ com Term value }}
  | - h :: :: H {{ com Hole }} {{ tex \ottshdn{-}[[h]] }}
  | + h :: :: D {{ tex \ottshdn{+}[[h]] }} {{ com Destination }}
  | () :: :: U {{ com Unit }}
  | λᵛ x m ⟼ u :: :: F {{ tex \lamvnt{[[x]]}{[[m]]}{[[u]]} }} {{ com Lambda abstraction }} % (+ bind x in t +)
  | Inl v :: :: L {{ com Left variant for sum }}
  | Inr v :: :: R {{ com Right variant for sum }}
  | ᴇ m v :: :: E {{ tex \expcons{[[m]]}[[v]] }} {{ com Exponential }}
  | ( v1 , v2 ) :: :: P {{ tex \ottsctor{(}[[v1]]\,\ottsctor{,}~[[v2]]\ottsctor{)} }} {{ com Product }}
  | H ⟨ v2 ❟ v1 ⟩ :: :: A {{ com Ampar }} {{ tex _{[[H]]\!}\ottsctor{\langle}[[v2]]\,\ottsctor{\bbcomma}~[[v1]]\ottsctor{\rangle} }}
  | v [ H ⩲ h' ] :: M :: S {{ com Shift hole names inside $[[v]]$ by $[[h']]$ if they belong to $[[H]]$. }} {{ coq (val_hdn_shift [[v]] [[H]] [[h']]) }} {{ tex [[v]]\ottshdn{[}[[H]][[⩲]][[h']]\ottshdn{]} }}
  | ( v ) :: S :: Paren {{ coq [[v]] }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DYNAMIC SYNTAX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

ectxs, C :: 'ectxs_' ::= {{ com Evaluation context stack }} {{ coq (list ectx) }}
  | ⬜ :: :: N {{ coq nil }} {{ com Represent the empty stack / "identity" evaluation context }}
%  | c :: S :: S {{ coq (cons [[c]] nil) }}
  | C ∘ c :: :: C {{ coq (cons [[c]] [[C]]) }} {{ tex [[C]]\,\circ\,[[c]] }} {{ com Push $[[c]]$ on top of $[[C]]$ }}
  | C [ h ≔ H v ] :: M :: Fill {{ tex [[C]][ [[h]]\coloneq_{[[H]]}\,[[v]] ] }} {{ com Fill $[[h]]$ in $[[C]]$ with value $[[v]]$ (that may contain holes) }} {{ coq (ectxs_fill [[C]] [[h]] [[H]] [[v]]) }}
  | ( C ) :: S :: Paren {{ coq [[C]] }}

ectx, c :: 'ectx_' ::= {{ com Evaluation context component }}
  | ⬜ ≻ t' :: :: AppFoc1 {{ com Application }} {{ tex [[⬜]]\,\succ[[t']] }}
  | v ≻ ⬜ :: :: AppFoc2 {{ com Application }} {{ tex [[v]]\,\succ[[⬜]] }}
  | ⬜ ; u :: :: PatUFoc {{ com Pattern-match on unit }} {{ tex [[⬜]]~;\,[[u]] }}
  | ⬜ ≻case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } :: :: PatSFoc {{ com Pattern-match on sum }} {{ tex [[⬜]]\,\succ\ottkw{case}_{[[m]]}\,\{\,\ottsctor{Inl}\,[[x1]][[⟼]][[u1]]\,,~\ottsctor{Inr}\,[[x2]][[⟼]][[u2]]\,\} }} % (+ bind x1 in u1 +) (+ bind x2 in u2 +)
  | ⬜ ≻case m ( x1 , x2 ) ⟼ u :: :: PatPFoc {{ com Pattern-match on product }} {{ tex [[⬜]]\,\succ\ottkw{case}_{[[m]]}\,\ottsctor{(}[[x1]]\,\ottsctor{,}~[[x2]]\ottsctor{)}\![[⟼]][[u]] }}  % (+ bind x1 in u +) (+ bind x2 in u +) 
  | ⬜ ≻case m ᴇ n x ⟼ u :: :: PatEFoc {{ com Pattern-match on exponential }} {{ tex [[⬜]]\,\succ\ottkw{case}_{[[m]]}\,\expcons{[[n]]}[[x]][[⟼]][[u]] }} % (+ bind x in u +)
  | ⬜ ≻map x ⟼ t' :: :: MapFoc {{ com Map over the right side of ampar }} {{ tex [[⬜]]\,\succ\ottkw{map}~[[x]]\![[⟼]][[t']] }} % (+ bind x in u +)

  | to⧔ ⬜ :: :: ToAFoc {{ tex \ottkw{to}_{\ottstype{\ltimes} }\,[[⬜]] }} {{ com Wrap into a trivial ampar }}
  | from⧔ ⬜ :: :: FromAFoc {{ tex \ottkw{from}_{\ottstype{\ltimes} }\,[[⬜]] }} {{ com Extract value from trivial ampar }}
  | ⬜ ⨞ () :: :: FillUFoc {{ com Fill destination with unit }}
  | ⬜ ⨞ Inl :: :: FillLFoc {{ com Fill destination with left variant }}
  | ⬜ ⨞ Inr :: :: FillRFoc {{ com Fill destination with right variant }}
  | ⬜ ⨞ ᴇ m :: :: FillEFoc {{ com Fill destination with exponential constructor }} {{ tex [[⬜]][[⨞]]\expcons{[[m]]} }}
  | ⬜ ⨞ (,) :: :: FillPFoc {{ com Fill destination with product constructor }}
  | ⬜ ⨞ ( λ x m ⟼ u ) :: :: FillFFoc {{ com Fill destination with function }} {{ tex [[⬜]][[⨞]](\lamnt{[[x]]}{[[m]]}{[[u]]}) }} % (+ bind x in u +)
  | ⬜ ⨞· t' :: :: FillCFoc1 {{ com Fill destination with root of ampar }} {{ tex [[⬜]]\triangleleft\!\mybullet\,[[t']] }}
  | v ⨞· ⬜ :: :: FillCFoc2 {{ com Fill destination with root of ampar }} {{ tex [[v]]\triangleleft\!\mybullet\,[[⬜]] }}
  | H ᵒᵖ⟨ v2 ❟ ⬜ :: :: AOpenFoc {{ tex ^{\text{op}\!}_{[[H]]\!}\ottsctor{\langle}[[v2]]\,\ottsctor{\bbcomma}~[[⬜]] }} {{ com Open ampar. \textcolor{red}{Only new addition to term shapes} }}
  | ( c ) :: S :: Paren {{ coq [[c]] }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TYPING SYNTAX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type, T, U :: 'type_' ::= {{ com Type }} {{ tex \ottstype{[[type]]} }} {{ coq-equality decide equality. apply mode_eq_dec. apply mode_eq_dec. apply mode_eq_dec. }}
  | ① :: :: U {{ tex \ottstype{1} }} {{ com Unit }}
  | T1 ⨁ T2 :: :: S {{ tex [[T1]]\ottstype{\oplus}[[T2]] }} {{ com Sum }}
  | T1 ⨂ T2 :: :: P {{ tex [[T1]]\ottstype{\otimes}[[T2]] }} {{ com Product }}
  | ! m T :: :: E {{ tex \ottstype{!}^{[[m]]}\,[[T]] }} {{ com Exponential }}
  | U ⧔ T :: :: A {{ tex [[U]]\,\ottstype{\ltimes}\,[[T]] }} {{ com Ampar type (consuming $[[T]]$ yields $[[U]]$) }}
  | T m → U :: :: F {{ tex [[T]]\,_{[[m]]}\!\ottstype{\to}\,[[U]] }} {{ com Function }}
  | ⌊ T ⌋ m :: :: D {{ tex \ottstype{\lfloor}[[T]]\ottstype{\rfloor}^{[[m]]} }} {{ com Destination }}
  | ( T ) :: S :: Paren {{ tex \ottstype{(}[[T]]\ottstype{)} }} {{ coq [[T]]}}

mode, m, n :: 'mode_' ::= {{ tex \ottsmode{[[mode]]} }} {{ com Mode (Semiring) }} {{ coq option (mul * age) }}
  | p a :: :: C {{ com Pair of a multiplicity and age }} {{ tex [[p]]\![[a]] }} {{ coq (Some (pair [[p]] [[a]])) }}
  | ☠ :: :: Err {{ tex \ottsmode{\skull} }} {{ coq None }} {{ com Error case (incompatible types, multiplicities, or ages) }}
  | m1 · ... · mk :: M :: P {{ com Semiring product }} {{ coq (mode_times' [[m1...mk]]) }}
  | ( m ) :: S :: Paren {{ tex \ottsmode{(}[[m]]\ottsmode{)} }} {{ coq [[m]] }}

mul, p :: 'mul_' ::= {{ tex \ottsmode{[[mul]]} }} {{ com Multiplicity (first component of modality) }} {{ coq _mul }}
  | ¹ :: :: Lin {{ tex \ottsmode{1} }} {{ com Linear. Neutral element of the product }} {{ coq Lin }}
  | ω :: :: Ur {{ tex \ottsmode{\omega} }} {{ com Non-linear. Absorbing for the product }} {{ coq Ur }}
  | p1 . ... . pk :: M :: P {{ com Semiring product }} {{ coq (mul_times' [[p1...pk]]) }}
  | ( p ) :: S :: Paren {{ tex \ottsmode{(}[[p]]\ottsmode{)} }} {{ coq [[p]] }}

age, a :: 'age_' ::= {{ tex \ottsmode{[[age]]} }} {{ com Age (second component of modality) }} {{ coq ext_nat }}
  | ν :: :: 0 {{ tex \ottsmode{\nu} }} {{ com Born now. Neutral element of the product }} {{ coq (Fin 0) }}
  | ↑ :: :: 1 {{ tex \ottsmode{\uparrow} }} {{ com One scope older }} {{ coq (Fin 1) }}
  | ∞ :: :: Inf {{ tex \ottsmode{\infty} }} {{ com Infinitely old / static. Absorbing for the product }} {{ coq Inf }}
  | a1 · ... · ak :: M :: P {{ com Semiring product }} {{ coq (age_times' [[a1...ak]]) }}
  | ( a ) :: S :: Paren {{ tex \ottsmode{(}[[a]]\ottsmode{)} }} {{ coq [[a]] }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Hidden in final document, just for Coq generation

tyb_var :: 'tyb_' ::=
  | ₓ m T :: :: Var {{ tex \,\!_{[[m]]}[[T]] }}
tyb_dh :: 'tyb_' ::=
  | ₊ m ⌊ T ⌋ n :: :: Dest {{ tex \,\!_{[[m]]}\ottstype{\lfloor}[[T]]\ottstype{\rfloor}^{[[n]]} }}
  | ₋ T n :: :: Hole {{ tex [[T]]^{[[n]]} }}

name :: 'name_' ::=
  | ˣ x :: :: Var {{ tex [[x]] }}
  | ʰ h :: :: DH {{ tex [[h]] }}

embed
{{ coq

Definition binding_type_of (n : name) : Type :=
  match n with
  | name_Var _ => tyb_var
  | name_DH _ => tyb_dh
  end.

Definition cast_binding_rename (h : hdn) (h' : hdn) (b : binding_type_of (name_DH h)): binding_type_of (name_DH h') :=
  b.

Definition name_eq_dec (x y : name) : {x = y} + {x<>y}.
Proof.
  decide equality.
  - apply Nat.eq_dec.
  - apply Nat.eq_dec.
Defined.

}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grammar

ctx, G {{ tex \Gamma }}, D {{ tex \Delta }}, P {{ tex \Pi }} :: 'ctx_' ::= {{ com Typing context }} {{ coq Finitely.T name binding_type_of }}
  % | ⦅ mvar mdest mhole ⦆ :: :: Maps {{ com Actual representation of contexts for Coq proofs (cannot hide) }} {{ tex \llparenthesis\,[[mvar]]~[[mdest]]~[[mhole]]\,\rrparenthesis }}
  | { } :: S :: E {{ coq ctx_empty }}
  | { x : m T } :: :: V {{ coq (ctx_singleton (name_Var [[x]]) (tyb_Var [[m]] [[T]])) }} {{ tex \{[[x]]:\,\!_{[[m]]}[[T]]\} }}
  | { + h : m ⌊ T ⌋ n } :: :: D {{ coq (ctx_singleton (name_DH [[h]]) (tyb_Dest [[m]] [[T]] [[n]])) }} {{ tex \{\ottshdn{+}[[h]]:\,\!_{[[m]]}\ottstype{\lfloor}[[T]]\ottstype{\rfloor}^{[[n]]}\} }}
  | { - h : T n } :: :: H {{ coq (ctx_singleton (name_DH [[h]]) (tyb_Hole [[T]] [[n]])) }} {{ tex \{\ottshdn{-}[[h]]:[[T]]^{[[n]]}\} }}
  | m · G :: M :: P {{ com Multiply each binding by $[[m]]$ }} {{ coq (ctx_stimes [[m]] [[G]]) }}
  | G1 ⨄ G2 :: M :: U {{ coq (ctx_union [[G1]] [[G2]]) }} {{ com Sum contexts $[[G1]]$ and $[[G2]]$. Duplicate keys with incompatible values will be tagged with $\ottsmode{\skull}$ }}
  | - G :: M :: M {{ coq (ctx_minus [[G]]) }} {{ com Transforms dest bindings into a hole bindings (requires \texttt{ctx\_DestOnly} $[[G]]$ and \texttt{ctx\_LinOnly} $[[G]]$) }}
  | － G :: M :: iM {{ coq (ctx_invminus [[G]]) }} {{ com Transforms hole bindings into dest bindings with left mode $\ottsmode{1\nu}$ (requires \texttt{ctx\_HoleOnly} $[[G]]$) }} {{ tex -^{-1}[[G]] }}
  | G [ H ⩲ h' ] :: M :: S {{ com Shift hole/dest names by $[[h']]$ if they belong to $[[H]]$ }} {{ coq (ctx_hdn_shift [[G]] [[H]] [[h']]) }} {{ tex [[G]]\ottshdn{[}[[H]][[⩲]][[h']]\ottshdn{]} }}
  | ( G ) :: S :: Paren {{ coq [[G]] }}

embed
{{ coq
(******************************************************************************
 * NAMES
 *****************************************************************************)

Definition hdn_shift (h : hdn) (H : HdnsM.t) (h' : hdn) : hdn :=
  match HdnsM.mem h H with
  | true => h + h'
  | false => h
  end.

Fixpoint hdns_from_list (l : list nat) : HdnsM.t :=
  match l with
  | nil => HdnsM.empty
  | h :: t => HdnsM.add h (hdns_from_list t)
  end.

Definition hdns_max (H : HdnsM.t) : nat := match HdnsM.max_elt H with
  | Some h => h
  | None => 0
  end.

Definition hdns_shift (H : HdnsM.t) (h' : nat) : HdnsM.t :=
  HdnsM.fold (fun h acc => HdnsM.add (h + h') acc) H HdnsM.empty.

Fixpoint hdns_from_ctxdom (dom: list name) : HdnsM.t :=
  match dom with
  | nil => HdnsM.empty
  | name_Var _ :: xs => hdns_from_ctxdom xs
  | name_DH h :: xs => HdnsM.add h (hdns_from_ctxdom xs)
  end.
Definition hdns_from_ctx (G : ctx) : HdnsM.t :=
  hdns_from_ctxdom (dom G).

Fixpoint hdns_from_ectxs (C : ectxs) : HdnsM.t := match C with
  | nil => HdnsM.empty
  | cons c xs => let H := match c with
    | ectx_AOpenFoc H' v => H'
    | _ => HdnsM.empty
  end in (HdnsM.union H (hdns_from_ectxs xs))
end.

Definition hdns_Disjoint (H1 H2 : HdnsM.t) : Prop :=
  HdnsM.Empty (HdnsM.inter H1 H2).

(******************************************************************************
 * TERMS STATIC BEHAVIOUR
 *****************************************************************************)

(******************************************************************************
 * TERMS DYNAMIC BEHAVIOUR
 *****************************************************************************)

Fixpoint term_sub (te: term) (x':var) (v':val) : term := match te with
  (* | term_Val v => val_sub v x' v' *)
  | term_Val v => term_Val v
  | term_Var x => match Nat.eq_dec x x' with | left _ => term_Val v' | right _ => term_Var x end
  | term_App t t' => term_App (term_sub t x' v') (term_sub t' x' v')
  | term_PatU t u => term_PatU (term_sub t x' v') (term_sub u x' v')
  | term_PatS t m x1 u1 x2 u2 =>
    let u1' := match Nat.eq_dec x1 x' with | left _ => u1 | right _ => term_sub u1 x' v' end in
    let u2' := match Nat.eq_dec x2 x' with | left _ => u2 | right _ => term_sub u2 x' v' end in
    term_PatS (term_sub t x' v') m x1 u1' x2 u2'
  | term_PatP t m x1 x2 u =>
    let u' := match Nat.eq_dec x1 x', Nat.eq_dec x2 x' with | left _, left _ | left _, right _ | right _, left _ => u | right _, right _ => term_sub u x' v' end in
    term_PatP (term_sub t x' v') m x1 x2 u'
  | term_PatE t m n x u => 
    let u' := match Nat.eq_dec x x' with | left _ => u | right _ => term_sub u x' v' end in
    term_PatE (term_sub t x' v') m n x u'
  | term_Map t x t' =>
    let t'' := match Nat.eq_dec x x' with | left _ => t' | right _ => term_sub t' x' v' end in
    term_Map (term_sub t x' v') x t''
  | term_ToA u => term_ToA (term_sub u x' v')
  | term_FromA t => term_FromA (term_sub t x' v')
  | term_Alloc => term_Alloc
  | term_FillU t => term_FillU (term_sub t x' v')
  | term_FillL t => term_FillL (term_sub t x' v')
  | term_FillR t => term_FillR (term_sub t x' v')
  | term_FillE t m => term_FillE (term_sub t x' v') m
  | term_FillP t => term_FillP (term_sub t x' v')
  | term_FillF t x m u =>
    let u' := match Nat.eq_dec x x' with | left _ => u | right _ => term_sub u x' v' end in
    term_FillF (term_sub t x' v') x m u'
  | term_FillC t t' => term_FillC (term_sub t x' v') (term_sub t' x' v')
end

(* with
(* TODO: Do we really need val_sub as value functions cannot capture anything except dests? *)
val_sub (va: val) (x': var) (v': val) : val := match va with
  | val_H h => val_H h
  | val_D h => val_D h
  | val_U => val_U
  | val_F x m u =>
    let u' := match Nat.eq_dec x x' with | left _ => u | right _ => term_sub u x' v' end in
    val_F x m u'
  | val_L v => val_L (val_sub v x' v')
  | val_R v => val_R (val_sub v x' v')
  | val_E m v => val_E m (val_sub v x' v')
  | val_P v1 v2 => val_P (val_sub v1 x' v') (val_sub v2 x' v')
  | val_A H v2 v1 => val_A H (val_sub v2 x' v') (val_sub v1 x' v')
end *)
.

Fixpoint val_fill (va: val) (h':hdn) (H':hdns) (v':val) : val := match va with
  | val_H h => match Nat.eq_dec h h' with | left _ => v' | right _ => val_H h end
  | val_D h => val_D h
  | val_U => val_U
  | val_F x m u => val_F x m u (* No hole in a value function allowed *)
  | val_L v => val_L (val_fill v h' H' v')
  | val_R v => val_R (val_fill v h' H' v')
  | val_E m v => val_E m (val_fill v h' H' v')
  | val_P v1 v2 => val_P (val_fill v1 h' H' v') (val_fill v2 h' H' v')
  | val_A H v2 v1 => val_A H v2 v1 (* No foreign hole allowed in ampar *)
end.

Definition ectxs_fill (C: ectxs) (h':hdn) (H' : hdns) (v':val) : ectxs := List.map (fun c => match c with
  | ectx_AOpenFoc H v => ectx_AOpenFoc (HdnsM.union (HdnsM.remove h' H) H') (val_fill v h' H' v')
  | _ => c
end) C.

Fixpoint val_hdn_shift (va : val) (H : hdns) (h' : hdn) : val :=
  match va with
  | val_H h => val_H (hdn_shift h H h')
  | val_D h => val_D (hdn_shift h H h')
  | val_U => val_U
  | val_F x m u => val_F x m (term_hdn_shift u H h') (* We can have dests captured in a function *)
  | val_L v => val_L (val_hdn_shift v H h')
  | val_R v => val_R (val_hdn_shift v H h')
  | val_E m v => val_E m (val_hdn_shift v H h')
  | val_P v1 v2 => val_P (val_hdn_shift v1 H h') (val_hdn_shift v2 H h')
  | val_A H' v2 v1 => val_A H' (val_hdn_shift v2 H h') (val_hdn_shift v1 H h') (* We can have foreign dests captured in both sides of an ampar, but this shouldn't touch H' *)
  end
with term_hdn_shift (te : term) (H : hdns) (h' : hdn) : term :=
  match te with
  | term_Val v => term_Val (val_hdn_shift v H h')
  | term_Var x => term_Var x
  | term_App t t' => term_App (term_hdn_shift t H h') (term_hdn_shift t' H h')
  | term_PatU t u => term_PatU (term_hdn_shift t H h') (term_hdn_shift u H h')
  | term_PatS t m x1 u1 x2 u2 => term_PatS (term_hdn_shift t H h') m x1 (term_hdn_shift u1 H h') x2 (term_hdn_shift u2 H h')
  | term_PatP t m x1 x2 u => term_PatP (term_hdn_shift t H h') m x1 x2 (term_hdn_shift u H h')
  | term_PatE t m n x u => term_PatE (term_hdn_shift t H h') m n x (term_hdn_shift u H h')
  | term_Map t x t' => term_Map (term_hdn_shift t H h') x (term_hdn_shift t' H h')
  | term_ToA u => term_ToA (term_hdn_shift u H h')
  | term_FromA t => term_FromA (term_hdn_shift t H h')
  | term_Alloc => term_Alloc
  | term_FillU t => term_FillU (term_hdn_shift t H h')
  | term_FillL t => term_FillL (term_hdn_shift t H h')
  | term_FillR t => term_FillR (term_hdn_shift t H h')
  | term_FillE t m => term_FillE (term_hdn_shift t H h') m
  | term_FillP t => term_FillP (term_hdn_shift t H h')
  | term_FillF t x m u => term_FillF (term_hdn_shift t H h') x m (term_hdn_shift u H h')
  | term_FillC t t' => term_FillC (term_hdn_shift t H h') (term_hdn_shift t' H h')
end.

Definition term_NotVal (t: term) : Prop := forall (v : val), t <> term_Val v.

(******************************************************************************
 * TYPE
 *****************************************************************************)

(* Alias to the one defined by Ott *)
Definition type_eq_dec : forall (T1 T2: type), {T1 = T2} + {T1 <> T2} := eq_type.

(******************************************************************************
 * MULTIPLICITY
 *****************************************************************************)

Definition mul_plus (p1 p2: _mul) : _mul := Ur.
Definition mul_times (p1 p2: _mul) : _mul :=
  match p1, p2 with
  | Lin, Lin => Lin
  | _, _ => Ur
  end.
Definition mul_times' (pl: list _mul) : _mul :=
  List.fold_right mul_times Lin pl.
Inductive mul_IsSubtype : _mul -> _mul -> Prop :=
  | mul_IsSubtypeProofEq : forall (p : _mul), mul_IsSubtype p p
  | mul_IsSubtypeProofUr : forall (p2 : _mul), mul_IsSubtype Ur p2.
Theorem mul_IsSubtype_dec : forall (p1 p2: _mul), {mul_IsSubtype p1 p2} + {~mul_IsSubtype p1 p2}.
Proof.
  intros p1 p2. destruct p1, p2.
  - left. exact (mul_IsSubtypeProofEq Lin).
  - right. intros contra. inversion contra.
  - left. exact (mul_IsSubtypeProofUr Lin).
  - left. exact (mul_IsSubtypeProofEq Ur).
Defined.

(******************************************************************************
 * AGE
 *****************************************************************************)

Definition age_times (a1 a2 : age) : age := ext_plus a1 a2.
Definition age_times' (al: list age) : age := ext_plus' al.
Definition age_plus (a1 a2: age) : age :=
  match age_eq_dec a1 a2 with
  | left _ => a1
  | right _ => Inf
  end.
Inductive age_IsSubtype : age -> age -> Prop :=
  | age_IsSubtypeProofEq : forall (a : age), age_IsSubtype a a
  | age_IsSubtypeProofInf : forall (a2 : age), age_IsSubtype Inf a2.
Theorem age_IsSubtype_dec : forall (a1 a2: age), {age_IsSubtype a1 a2} + {~(age_IsSubtype a1 a2)}.
Proof.
  intros a1 a2. destruct a1, a2.
  - assert ({n = n0} + {n <> n0}) by apply Nat.eq_dec. destruct H.
    * rewrite e. left. exact (age_IsSubtypeProofEq (Fin n0)).
    * right. intros contra. inversion contra. congruence.
  - right. intros contra. inversion contra.
  - left. exact (age_IsSubtypeProofInf (Fin n)).
  - left. exact (age_IsSubtypeProofEq Inf).
Defined.

(******************************************************************************
 * MODE
 *****************************************************************************)

Definition mode_plus (m1 m2: mode) : mode :=
  match m1, m2 with
  | None, _ => None
  | _, None => None
  | Some (p1, a1), Some (p2, a2) => Some (mul_plus p1 p2, age_plus a1 a2)end.
Definition mode_times (m1 m2: mode) : mode :=
  match m1, m2 with
  | None, _ => None
  | _, None => None
  | Some (p1, a1), Some (p2, a2) => Some (mul_times p1 p2, age_times a1 a2)
  end.
Definition mode_times' (ml: list mode) : mode :=
  List.fold_right mode_times (Some (Lin, Fin 0)) ml.
Inductive mode_IsSubtype : mode -> mode -> Prop :=
  | mode_IsSubtypeProofNone : forall (m2 : mode), mode_IsSubtype None m2 (* skull represents contradictory requirements, so we must never be able to provide a value with multiplicity skull *)
  | mode_IsSubtypeProofPair : forall (p1 p2 : _mul) (a1 a2 : age), mul_IsSubtype p1 p2 -> age_IsSubtype a1 a2 -> mode_IsSubtype (Some (p1, a1)) (Some (p2, a2)).
Theorem mode_IsSubtype_dec : forall (m1 m2: mode), {mode_IsSubtype m1 m2} + {~mode_IsSubtype m1 m2}.
Proof.
  intros m1 m2. destruct m1 as [(p1 & a1)|], m2 as [(p2 & a2)|].
  - destruct (mul_IsSubtype_dec p1 p2), (age_IsSubtype_dec a1 a2).
    + left. exact (mode_IsSubtypeProofPair p1 p2 a1 a2 m a).
    + right. intros contra. inversion contra. congruence.
    + right. intros contra. inversion contra. congruence.
    + right. intros contra. inversion contra. congruence.
  - right. intros contra. inversion contra.
  - left. exact (mode_IsSubtypeProofNone (Some (p2, a2))).
  - left. exact (mode_IsSubtypeProofNone None).
Defined.
Inductive mode_IsValid : mode -> Prop :=
  mode_IsValidProof : forall (pa : mul * age), mode_IsValid (Some pa).
Theorem mode_IsValid_dec : forall (m : mode), {mode_IsValid m} + {~mode_IsValid m}.
Proof.
  intros m. destruct m as [pa|].
  - left. exact (mode_IsValidProof pa).
  - right. intros contra. inversion contra.
Qed.
Inductive mode_IsLin : mode -> Prop :=
  mode_IsLinProof : forall (a : age), mode_IsLin (Some (Lin, a)).
Theorem mode_IsLin_dec : forall (m : mode), {mode_IsLin m} + {~mode_IsLin m}.
Proof.
  intros m. destruct m as [pa|].
  - destruct pa as [p a]. destruct p.
    + left. exact (mode_IsLinProof a).
    + right. intros contra. inversion contra.
  - right. intros contra. inversion contra.
Qed.
Inductive mode_IsFinAge : mode -> Prop :=
  mode_IsFinAgeProof : forall (p : mul) (k : nat), mode_IsFinAge (Some (p, Fin k)).
Theorem mode_IsFinAge_dec : forall (m : mode), {mode_IsFinAge m} + {~mode_IsFinAge m}.
Proof.
  intros m. destruct m as [pa|].
  - destruct pa as [p a]. destruct a.
    + left. exact (mode_IsFinAgeProof p n).
    + right. intros contra. inversion contra.
  - right. intros contra. inversion contra.
Qed.
Definition mode_IsLinNu (m : mode) : Prop := m = Some (Lin, Fin 0).
Theorem mode_IsLinNu_dec : forall (m : mode), {mode_IsLinNu m} + {~mode_IsLinNu m}.
Proof.
  unfold mode_IsLinNu. intros m. apply mode_eq_dec.
Qed.
Inductive mode_IsUr : mode -> Prop :=
  mode_IsUrProof : forall (a : age), mode_IsUr (Some (Ur, a)).
Theorem mode_IsUr_dec : forall (m : mode), {mode_IsUr m} + {~mode_IsUr m}.
Proof.
  intros m. destruct m as [pa|].
  - destruct pa as [p a]. destruct p.
    + right. intros contra. inversion contra.
    + left. exact (mode_IsUrProof a).
  - right. intros contra. inversion contra.
Qed.

(******************************************************************************
 * BINDERS
 *****************************************************************************)

Definition tyb_mode {n : name} (tyb: binding_type_of n): mode :=
  match n return (binding_type_of n) -> mode with
  | name_Var _ => fun tyb => match tyb with
    | tyb_Var m _ => m
    end
  | name_DH _ => fun tyb => match tyb with
    | tyb_Dest m _ _ => m
    | tyb_Hole _ n => n
    end
  end tyb.

(******************************************************************************
 * CONTEXTS
 *****************************************************************************)

(******************************************************************************
 * CONTEXTS
 *****************************************************************************)

Definition IsDest x : binding_type_of x -> Prop :=
  match x with
  | name_Var _ => fun _ => False
  | name_DH h => fun b => match b with tyb_Dest _  _  _ => True | _ => False end
  end.

Definition ctx_DestOnly G : Prop := forall x b, G x = Some b -> IsDest x b.

Definition ctx_LinNuOnly (G : ctx) : Prop := forall (n : name) (tyb: binding_type_of n), G n = Some tyb -> mode_IsLinNu (tyb_mode tyb).
Definition ctx_LinOnly (G : ctx) : Prop := forall (n : name) (tyb: binding_type_of n), G n = Some tyb -> mode_IsLin (tyb_mode tyb).
Definition ctx_FinAgeOnly (G : ctx) : Prop := forall (n : name) (tyb: binding_type_of n), G n = Some tyb -> mode_IsFinAge (tyb_mode tyb).
Definition ctx_ValidOnly (G: ctx) : Prop := forall (n : name) (tyb: binding_type_of n), G n = Some tyb -> mode_IsValid (tyb_mode tyb).
Definition ctx_Disjoint (G1 G2 : ctx) : Prop :=
  forall x, Finitely.In x G1 -> Finitely.In x G2 -> False.

Definition ctx_CompatibleDH (G: ctx) (h: hdn) (tyb: tyb_dh) : Prop :=
  forall (n' : name) (tyb' : binding_type_of n'), G n' = Some tyb' ->
    ( match n' return binding_type_of n' -> Prop with
      | name_DH h' => match Nat.eq_dec h h' with
        | left h_eqrefl => fun tyb' => match tyb, tyb' with
          | tyb_Dest m T n, tyb_Dest m' T' n' => mode_IsSubtype m m' /\ T = T' /\ n = n'
          | tyb_Hole T n, tyb_Hole T' n' => T = T' /\ n = n'
          | _, _ => False
          end
        | right h_eqcontra => fun tyb' => mode_IsUr (tyb_mode tyb')
        end
      | name_Var x' => fun tyb' => mode_IsUr (tyb_mode tyb')
    end tyb').

Definition ctx_CompatibleVar (G: ctx) (x: var) (tyb: tyb_var) : Prop := 
  forall (n' : name) (tyb' : binding_type_of n'), G n' = Some tyb' ->
    ( match n' return binding_type_of n' -> Prop with
      | name_Var x' => match Nat.eq_dec x x' with
        | left x_eqrefl => fun tyb' => match tyb, tyb' with
          | tyb_Var m T, tyb_Var m' T' => mode_IsSubtype m m' /\ T = T'
          end
        | right x_eqcontra => fun tyb' => mode_IsUr (tyb_mode tyb')
        end
      | name_DH h' => fun tyb' => mode_IsUr (tyb_mode tyb')
    end tyb').

Definition union_tyb_var (b1 b2 : tyb_var) : tyb_var := match b1, b2 with
  | tyb_Var m1 T1, tyb_Var m2 T2 => match type_eq_dec T1 T2 with
    | left _ => tyb_Var (mode_plus m1 m2) T1
    | right _ => tyb_Var None type_U
    end
  end.

Definition union_tyb_dh (b1 b2 : tyb_dh) : tyb_dh := match b1, b2 with
  | tyb_Dest m11 T1 m12, tyb_Dest m21 T2 m22 => match type_eq_dec T1 T2, mode_eq_dec m12 m22 with
    | left _, left _ => tyb_Dest (mode_plus m11 m21) T1 m12
    | _, _ => tyb_Dest None type_U None
    end
  | tyb_Hole T1 n1, tyb_Hole T2 n2 => match type_eq_dec T1 T2 with
    | left _ => tyb_Hole T1 (mode_plus n1 n2)
    | right _ => tyb_Hole type_U None
    end
  | _, _ => tyb_Hole type_U None
  end.

Definition ctx_union (G1 G2 : ctx) : ctx :=
  Finitely.merge_with (fun n =>
    match n return (binding_type_of n) -> (binding_type_of n) -> (binding_type_of n) with
    | name_Var _ => union_tyb_var
    | name_DH _ => union_tyb_dh
    end
  ) G1 G2.

Definition stimes_tyb_var (m' : mode) (b : tyb_var) : tyb_var := match b with
  | tyb_Var m T => tyb_Var (mode_times m' m) T
end.
Definition stimes_tyb_dh (m' : mode) (b : tyb_dh) : tyb_dh := match b with
  | tyb_Dest m T n => tyb_Dest (mode_times m' m) T n
  | tyb_Hole T n => tyb_Hole T (mode_times m' n)
end.

Definition ctx_stimes (m' : mode) (G : ctx) : ctx :=
  Finitely.map (fun n =>
    match n return (binding_type_of n) -> (binding_type_of n) with
    | name_Var _ => stimes_tyb_var m'
    | name_DH _ => stimes_tyb_dh m'
    end
  ) G.

Definition ctx_minus (G : ctx) : ctx :=
  Finitely.map (fun n =>
    match n return (binding_type_of n) -> (binding_type_of n) with
    | name_Var _ => fun tyb => tyb_Var None type_U
    | name_DH _ => fun tyb => match tyb with
      | tyb_Dest (Some (Lin, (Fin 0))) T n => tyb_Hole T n
      | tyb_Dest _ _ _ => tyb_Dest None type_U None
      | tyb_Hole _ _ => tyb_Hole type_U None
      end
    end
  ) G.

Definition ctx_invminus (G : ctx) : ctx :=
  Finitely.map (fun n =>
    match n return (binding_type_of n) -> (binding_type_of n) with
    | name_Var _ => fun tyb => tyb_Var None type_U
    | name_DH _ => fun tyb => match tyb with
      | tyb_Dest _ _ _ => tyb_Dest None type_U None
      | tyb_Hole T n => tyb_Dest (Some (Lin, (Fin 0))) T n
      (* TODO: should we check that n is valid? *)
      end
    end
  ) G.

#[program]
Definition ctx_hdn_shift (G : ctx) (H : hdns) (h' : hdn) : ctx :=
  {|
    support := List.map (fun n => match n with
      | name_Var x => name_Var x
      | name_DH h => name_DH (hdn_shift h H h')
    end) G.(support);
    underlying := fun n => match n with
      | name_Var x => G.(underlying) (name_Var x)
      | name_DH h => G.(underlying) (name_DH (
          match (ge_dec h h'), (HdnsM.mem (h-h') H) with
          | left _, true => h-h'
          | _, _ => h
          end
        ))
      end;
  |}.
Next Obligation.
  admit.
Admitted.

(******************************************************************************
 * EVALUATION CONTEXTS
 *****************************************************************************)

Definition ctx_singleton (v : name) (tyb: binding_type_of v): ctx :=
  Finitely.singleton v (name_eq_dec) tyb.

Definition ctx_empty : ctx := Finitely.empty.

(*****************************************************************************)
}}

grammar

% spacing, sp :: 'sp_' ::= {{ tex \ottssp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottssp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=

% === Term syntax ===
  | ⬜ :: :: idectx {{ tex \square }}
  | ⟼ :: :: mapsto {{ tex \mapsto }}
  | () :: :: unit {{ tex \ottsctor{()} }}
  | Inl :: :: inl {{ tex \ottsctor{Inl} }}
  | Inr :: :: inr {{ tex \ottsctor{Inr} }}
  | (,) :: :: prod {{ tex \ottsctor{({,})} }}
  | ⨞ :: :: fill {{ tex \triangleleft }}
  | · :: :: semiring {{ tex \ottsmode{\hspace{-0.1ex}\cdot\hspace{-0.1ex} } }}
  | ⩲ :: :: rename {{ tex \pluseq }}

% === Contexts ===
  | ⨄ :: :: union {{ tex \cupplus }}

% === Typing & Semantics ===
  | ⟶ :: :: red {{ tex ~\longrightarrow~ }}
  | ⊢ :: :: vdash {{ tex \,\vdash\, }}
  | ⊣ :: :: dashv {{ tex \,\dashv\, }}
  | ⫦ :: :: dvdash {{ tex \,\Vdash\, }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred :: '_' ::= {{ com Serves for the .mng file. Isn't used in the actual rules }}
  | ctx_DestOnly G :: :: ctx_DestOnly {{ tex \texttt{ctx\_DestOnly}~[[G]] }}
  | ctx_LinOnly G :: :: ctx_LinOnly {{ tex \texttt{ctx\_LinOnly}~[[G]] }}
  | ctx_ValidOnly G :: :: ctx_ValidOnly {{ tex \texttt{ctx\_Valid}~[[G]] }}
  | ctx_Compatible G b :: :: ctx_Compatible {{ tex \texttt{ctx\_Compatible}~[[G]]~[[b]] }}
  | ctx_Disjoint G1 G2 :: :: ctx_Disjoint {{ tex \texttt{ctx\_Disjoint}~[[G1]]~[[G2]] }}
  | mode_IsValid m :: :: mode_IsValid {{ tex \texttt{mode\_Valid}~[[m]] }}
  | mode_IsLin m :: :: mode_IsLin {{ tex \texttt{mode\_Lin}~[[m]] }}
  | mode_IsUr m :: :: mode_IsUr {{ tex \texttt{mode\_Ur}~[[m]] }}
  | term_NotVal t :: :: term_NotVal {{ tex \texttt{NotVal}~[[t]] }}

  | G ⫦ v : T :: :: TyR_val
  | P ⊢ t : T :: :: Ty_term
  | D ⊣ C : T1 ↣ T2 :: :: Ty_ectxs {{ com Typing of evaluation contexts }} {{ tex [[D]][[⊣]][[C]]:[[T1]]\ottstype{\rightarrowtail}[[T2]] }}
  | ⊢ C [ t ] : T :: :: Ty_eterm
  | C [ t ] ⟶ C' [ t' ] :: :: Sem_eterm

parsing
ctx_U <= ctx_P
ctx_P <= ctx_M
ctx_U left ctx_U
term_Val <= term_Paren
