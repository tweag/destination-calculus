embed
{{ coq
Require Import Ott.ext_nat.
Require Import Coq.Structures.Equalities.
Require Import Coq.Structures.Orders.
Require Import Coq.Structures.OrdersAlt.
Require Import Coq.Structures.OrdersEx.
Require Import Coq.FSets.FMapWeakList.
Require Import Coq.FSets.FMapFacts.
}}

metavar tvar, x, y, d ::= {{ com Term-level variable }}
  {{ tex \ottmv{[[tvar]]} }} {{ coq nat }}

metavar hvar, h ::= {{ com Hole }}
  {{ tex \otthol{[[hvar]]} }} {{ coq nat }}

indexvar k ::= {{ coq nat }}

grammar

mul, m, n :: 'mul_' ::= {{ tex \ottmod{[[mul]]} }} {{ com Multiplicity (Semiring with product $[[.]]$) }} {{ coq ext_nat }}
  | 0 :: :: 0 {{ tex \ottmod{\nu} }} {{ com Born now. Identity of the product }} {{ coq (Fin 0) }}
  | 1 :: :: 1 {{ tex \ottmod{\uparrow} }} {{ com One scope older }} {{ coq (Fin 1) }}
  | Inf :: :: Inf {{ tex \ottmod{\infty} }} {{ com Infinitely old / static. Absorbing for product }} {{ coq Inf }}
  | m1 . ... . mk :: :: P {{ com Semiring product }} {{ coq (ext_plus' [[m1...mk]]) }}
  | ( m ) :: S :: Paren {{ tex \ottmod{(}[[m]]\ottmod{)} }} {{ coq [[m]] }}

typ, T, U :: 'typ_' ::= {{ com Type }} {{ tex \ottty{[[typ]]} }}
  | I :: :: U {{ tex \ottty{1} }} {{ com Unit }}
  | T1 + T2 :: :: S {{ tex [[T1]]\ottty{\oplus}[[T2]] }} {{ com Sum }}
  | T1 * T2 :: :: P {{ tex [[T1]]\ottty{\otimes}[[T2]] }} {{ com Product }}
  | ! m T :: :: E {{ tex \ottty{!}^{[[m]]}\,[[T]] }} {{ com Exponential }}
  | T1 ><| T2 :: :: A {{ tex [[T1]]\,[[><|]]\,[[T2]] }} {{ com Ampar type (consuming $[[T1]]$ yields $[[T2]]$) }}
  | T1 m -> T2 :: :: F {{ tex [[T1]]\,_{[[m]]}\!\ottty{\to}\,[[T2]] }} {{ com Linear function }}
  | | T | m :: :: D {{ tex \,^{[[m]]}\hspace{-0.2ex}\ottty{\lfloor}[[T]]\ottty{\rfloor} }} {{ com Destination }}
  | ( T ) :: S :: Paren {{ tex \ottty{(}[[T]]\ottty{)} }} {{ coq [[T]]}}

pas :: 'pas_' ::= {{ com Positive type assignment }}
  | x : m T :: :: V {{ com Variable }} {{ tex [[x]]:_{[[m]]}[[T]] }}
  | @ h : m | T | n :: :: D {{ com Destination ($[[m]]$ is its own age; $[[n]]$ is the age of values it accepts) }} {{ tex \otthol{@}[[h]]:_{[[m]]}\,\!^{[[n]]}\!\ottty{\lfloor}[[T]]\ottty{\rfloor} }}

nas :: 'nas_' ::= {{ com Negative type assignment }}
  | h : n T :: :: H {{ com Hole ($[[n]]$ is the age of values it accepts, its own age is undefined) }} {{ tex [[h]]:^{[[n]]}[[T]] }}

embed
{{ coq
Inductive name : Type :=
  | name_X : tvar -> name
  | name_HD : hvar -> name.

Module Name_as_UDT <: UsualDecidableType.
  Definition t := name.

  Definition eq := @eq name.
  Definition eq_refl := @eq_refl name.
  Definition eq_sym := @eq_sym name.
  Definition eq_trans := @eq_trans name.

  (* Define the eq_dec function *)
  Theorem eq_dec : forall x y : name, {x = y} + {x <> y}.
  Proof.
    intros x y. induction x.
    - induction y.
        + assert ({t0 = t1} + {t0 <> t1}) by apply Nat.eq_dec. destruct H.
           * left. rewrite e. reflexivity.
           * right. congruence.
        + right. congruence.
    - induction y.
        + right. congruence.
        + assert ({h = h0} + {h <> h0}) by apply Nat.eq_dec. destruct H.
           * left. rewrite e. reflexivity.
           * right. congruence.
    Defined.

  Instance eq_equiv : Equivalence Name_as_UDT.eq. split. exact eq_refl. exact eq_sym. exact eq_trans. Defined.

End Name_as_UDT.

Module Name_as_UDTOrig := Backport_DT(Name_as_UDT).
Module Ctx := FMapWeakList.Make(Name_as_UDTOrig).
Module CtxFacts := FMapFacts.Properties(Ctx).

Definition pas_name (b : pas) : name :=
  match b with
  | pas_V x m2 T2 => name_X x
  | pas_D h m2 T2 m3 => name_HD h
  end.

Definition pctx_add (b : pas) (G : Ctx.t pas) (hyp: ~(Ctx.In (pas_name b) G)) : Ctx.t pas :=
  Ctx.add (pas_name b) b G.

Definition pctx_from_list_unsafe (bs : list pas) : Ctx.t pas :=
  List.fold_left (fun G b => Ctx.add (pas_name b) b G) bs (Ctx.empty pas).

Definition nas_name (b : nas) : name :=
  match b with
  | nas_H h m2 T2 => name_HD h
  end.

Definition nctx_add (b : nas) (D : Ctx.t nas) (hyp: ~(Ctx.In (nas_name b) D)) : Ctx.t nas :=
  Ctx.add (nas_name b) b D.

Definition nctx_from_list_unsafe (bs : list nas) : Ctx.t nas :=
  List.fold_left (fun G b => Ctx.add (nas_name b) b G) bs (Ctx.empty nas).

Definition pctx_union (G1 G2 : Ctx.t pas) (hyp: CtxFacts.Disjoint G1 G2) : Ctx.t pas :=
  Ctx.fold (fun n b G => Ctx.add n b G) G2 G1.

Definition pctx_sprod (m1 : mul) (G : Ctx.t pas) : Ctx.t pas :=
  Ctx.map (fun b =>
    match b with
    | pas_V x m2 T2 => pas_V x (ext_plus m1 m2) T2
    | pas_D h m2 T2 m3 => pas_D h (ext_plus m1 m2) T2 m3
    end
  ) G.

Definition nctx_union (D1 D2 : Ctx.t nas) (hyp: CtxFacts.Disjoint D1 D2) : Ctx.t nas :=
  Ctx.fold (fun n b D => Ctx.add n b D) D2 D1.

Definition nctx_sprod (m1 : mul) (D : Ctx.t nas) : Ctx.t nas :=
  Ctx.map (fun b =>
    match b with
    | nas_H h m2 T2 => nas_H h (ext_plus m1 m2) T2
    end
  ) D.

Definition ctx_Has {elt: Type} (b : elt) (G : Ctx.t elt) : Prop :=
  exists n, Ctx.MapsTo n b G.

Definition pas_IsDest (b: pas) : Prop :=
  match b with
    | pas_V _ _ _ => False
    | pas_D _ _ _ _ => True
  end.

Definition ctx_Coherent {elt: Type} (name_proj: elt -> name) (G: Ctx.t elt)  : Prop :=
  forall n b, Ctx.MapsTo n b G -> name_proj b = n.

Definition pctx_Coherent (G: Ctx.t pas) : Prop := ctx_Coherent pas_name G.
Definition nctx_Coherent (D: Ctx.t nas) : Prop := ctx_Coherent nas_name D.

Axiom all_pctx_Coherent: forall (G : Ctx.t pas), pctx_Coherent G.
Axiom all_nctx_Coherent: forall (D : Ctx.t nas), nctx_Coherent D.

Definition pctx_DestOnly (G : Ctx.t pas) : Prop :=
  forall b, ctx_Has b G -> pas_IsDest b.

Definition nctx_minus (G : Ctx.t pas) (hyp: pctx_DestOnly G) : Ctx.t nas :=
  Ctx.map (fun b =>
    match hyp b (pas_name b) with
    | pas_D h m2 T2 m3 => nas_H h (ext_plus m2 m3) T2
    end
  ) G.
}}

grammar
pctx, G {{ tex \Gamma }} :: 'pctx_' ::= {{ com Positive typing context }} {{ coq option (Ctx.t pas) }}
  | { pas1 , .. , pask } :: :: L {{ coq (pctx_from_pas_list [[pas1..pask]]) }}
  | m . G :: :: S {{ com Increase age of bindings by $[[m]]$ }} {{ coq (pctx_sprod [[m]] [[G]]) }}
  | G1 µ G2 :: :: U {{ coq (pctx_union [[G1]] [[G2]]) }}
  | ( G ) :: S :: Paren {{ coq [[G]] }}

nctx, D {{ tex \Delta }} :: 'nctx_' ::= {{ com Negative typing context }} {{ coq option (Ctx.t nas) }}
  | { nas1 , .. , nask } :: :: L {{ coq (nctx_from_nas_list [[nas1..nask]]) }}
  | m . D :: :: S {{ com Increase age of bindings by $[[m]]$ }} {{ tex \topprod{[[m]]}[[D]] }} {{ coq (nctx_sprod [[m]] [[D]]) }}
  | - G :: :: M  {{ tex \otthol{@^{\scriptscriptstyle\text{-}1} }[[G]] }} {{ com Invert the sign of the context }} {{ coq (nctx_minus [[G]]) }}
  | D1 µ D2   :: :: U {{ coq (nctx_union [[D1]] [[D2]]) }}
  | ( D ) :: S :: Paren {{ coq [[D]] }}

ctx, C :: 'ctx_' ::= {{ com Context }}
  | pctx :: :: P
  | nctx :: :: n

grammar
term, t, u :: 'term_' ::=                                               {{ com Term }}
  | v :: :: Val {{ com Term value }}
  | x :: :: Var {{ com Variable }}
  | t & u                                    ::   :: App      {{ com Application }} {{ tex [[t]]~\succ~[[u]] }}
  | t ; u                   ::   :: PatU {{ com Pattern-match on unit }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,[[()]]\![[->]]\,[[u]] }}
  | t & \case { Inl x1 -> u1 , Inr x2 -> u2 }   ::   :: PatS (+ bind x1 in u1 +) (+ bind x2 in u2 +)     {{ com Pattern-match on sum }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\{\,\ottcons{Inl}\,[[x1]][[->]][[u1]]\,,~\ottcons{Inr}\,[[x2]][[->]][[u2]]\,\} }}
  | t & \case ( x1 , x2 ) -> u            ::   :: PatP (+ bind x1 in u +) (+ bind x2 in u +)     {{ com Pattern-match on product }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\ottcons{(}[[x1]]\,\ottcons{,}~[[x2]]\ottcons{)}\![[->]]\,[[u]] }} 
  | t & \case exp m x -> u            ::   :: PatE (+ bind x in u +)    {{ com Pattern-match on exponential }} {{ tex [[t]]~\succ\!\!\ottkw{case}\,\expcons{[[m]]}[[x]][[->]]\,[[u]] }}
  | t <&> \ x -> u :: :: Map (+ bind x in u +) {{ com Map over the left side of the ampar }} {{ tex [[t]]~\succ\!\!\ottkw{mapL}\,[[x]]\![[->]]\,[[u]] }} 

  % | toGlobal t :: :: ToGlobal {{ tex \ottkw{to}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion to ${\ottmod{\scriptstyle G} }$ }}
  % | fromGlobal t :: :: FromGlobal {{ tex \ottkw{from}_{\ottmod{\scriptstyle G} } }} {{ com Mode coercion from ${\ottmod{\scriptstyle G} }$ }}
  | toAmpar t :: :: ToA {{ tex \ottkw{to}_{[[><|]]}\,[[t]] }} {{ com Wrap $[[t]]$ into a trivial ampar }}
  | fromAmpar t :: :: FromA {{ tex \ottkw{from}_{[[><|]]}\,[[t]] }} {{ com Extract value from trivial ampar }}

  | alloc T :: :: Alloc {{ com Return a fresh "identity" ampar object }} {{ tex \ottkw{alloc}_{ [[T]]} }}
  | t <| () :: :: FillU {{ com Fill destination with unit }}
  | t <| Inl                          ::   :: FillL   {{ com Fill destination with left variant }}
  | t <| Inr                          ::   :: FillR   {{ com Fill destination with right variant }}
  | t <| (,)                              ::   :: FillP    {{ com Fill destination with product constructor }}
  | t <| exp m :: :: FillE {{ com Fill destination with exponential constructor }} {{ tex [[t]][[<|]]\expcons{[[m]]} }}
  | t <|. u :: :: FillC {{ com Fill destination with root of ampar $[[u]]$ }}

  | ( t )                                   :: S :: Paren {{ coq [[t]] }}
  | t [ x := v ]                             :: M :: Sub {{ coq (term_sub [[t]] [[x]] [[v]]) }}
  % | b sp t b spe :: S :: BreakSpacing1
  % | b sp t :: S :: BreakSpaacing2
  % | t b spe : : S :: BreakSpacing3

val, v :: 'val_' ::= {{ com Term value }}
  | < v1 ¤ w2 > D :: :: A {{ com Ampar }} {{ tex \ottcons{\langle}[[v1]]\,\ottcons{\bbcomma}~[[w2]]\ottcons{\rangle}_{[[D]]} }}
  | @ h :: :: D {{ tex \otthol{@}[[h]] }} {{ com Destination }}
  | () :: :: U {{ com Unit }}
  | Inl v :: :: L {{ com Left variant for sum }}
  | Inr v :: :: R {{ com Right variant for sum }}
  | ( v1 , v2 ) :: :: P {{ tex \ottcons{(}[[v1]]\,\ottcons{,}~[[v2]]\ottcons{)} }} {{ com Product }}
  | exp m v :: :: E {{ tex \expcons{[[m]]}[[v]] }} {{ com Exponential }}
  | \ x -> t :: :: F (+ bind x in t +) {{ tex \lamnt{[[x]]}{[[t]]} }} {{ com Linear function }} 
  | ( v ) :: S :: Paren {{ coq [[v]] }}

xval, w :: 'xval_' ::= {{ com Pseudo-value that may contain holes }} {{ tex \ottextval{[[xval]]} }}
  | v :: :: V {{ com Term value }}
  | h :: :: H {{ com Hole }}
  | Inl w :: :: L {{ com Left variant with val or hole }}
  | Inr w :: :: R {{ com Right variant with val or hole }}
  | ( w1 , w2 ) :: :: P {{ tex \ottcons{(}[[w1]]\,\ottcons{,}~[[w2]]\ottcons{)} }} {{ com Product with val or hole }}
  | exp m w :: :: E {{ tex \expcons{[[m]]}[[w]] }} {{ com Exponential with val or hole }}
  | ( w ) :: S :: Paren {{ coq [[w]] }}
  | w [ e ] :: M :: Effect {{ coq (xval_effapp [[w]] [[e]]) }}

eff, e :: 'eff_' ::= {{ com Effect }} {{ tex \otteff{[[eff]]} }}
  | o :: :: n {{ tex \otteff{\varepsilon} }}
  | h := w :: :: A
  | e1 , ... , ek :: :: P {{ com Chain effects }}
  | ( e ) :: S :: InvisParen {{ coq [[e]] }} {{ tex [[e]] }}

embed
{{ coq
Definition term_sub (t: term) (x : tvar) (v : val) : term := t.
(* TODO *)
Definition xval_effapp (w : xval) (e : eff) : xval := w.
(* TODO *)
}}

grammar

% spacing, sp :: 'sp_' ::= {{ tex \ottsp{[[spacing]]} }}
%   | s :: :: space1 {{ tex \myspace{1} }}
%   | ss :: :: space2 {{ tex \myspace{2} }}
%   | sss :: :: space3 {{ tex \myspace{3} }}
%   | ssss :: :: space4 {{ tex \myspace{4} }}
%   | sssss :: :: space5 {{ tex \myspace{5} }}
%   | ssssss :: :: space6 {{ tex \myspace{6} }}

% spacing_end, spe :: 'spe_' ::= {{ tex \ottsp{[[spacing_end]]} }}
%   | se :: :: space1e {{ tex \myspace{1} }}
%   | sse :: :: space2e {{ tex \myspace{2} }}
%   | ssse :: :: space3e {{ tex \myspace{3} }}
%   | sssse :: :: space4e {{ tex \myspace{4} }}
%   | ssssse :: :: space5e {{ tex \myspace{5} }}
%   | sssssse :: :: space6e {{ tex \myspace{6} }}

terminals :: 'terminals_' ::=
% === Type syntax ===
  | --o :: :: linarr {{ tex \ottty{\multimap} }}
  | ><| :: :: rtimes {{ tex \ottty{\rtimes} }}

% === Term syntax ===
  | ->                                     ::   :: Mapsto       {{ tex \mapsto }}
  | () :: :: unit {{ tex \ottcons{()} }}
  | Inl :: :: inl {{ tex \ottcons{Inl} }}
  | Inr :: :: inr {{ tex \ottcons{Inr} }}
  | (,) :: :: prod {{ tex \ottcons{({,})} }}
  | <| :: :: fill {{ tex \triangleleft }}
  | <|. :: :: fillcomp {{ tex \triangleleft\!\mybullet\, }}
  | := :: :: assign {{ tex \coloneq }}
  | '.' :: :: semiring {{ tex \ottmod{\hspace{-0.1ex}\cdot\hspace{-0.1ex} } }}

% === Contexts ===
  | µ :: :: dunion {{ tex \sqcup }}
%  | µ+ :: :: sdunion {{ tex \,\text{\makebox[0pt][l]{$\sqcup$}\raisebox{.40ex}{\hspace{.15ex}$\scriptscriptstyle\pm$} } }}
%  | '{}' :: :: empty {{ tex \emptyset }}

% === Judgements ===
%  | exists :: :: exists {{ tex \exists }}
%  | != :: :: neq {{ tex \neq }}
%  | <= :: :: leq {{ tex \leq }}
%  | in :: :: in {{ tex \in }}
  | notin :: :: notin {{ tex \notin }}
%  | includedin :: :: includedin {{ tex \subset }}
  % | names :: :: names {{ tex \mathcal{n} }}

% === Typing ===
  | |- :: :: turnstile {{ tex \,\vdash\, }}
  | ||- :: :: dturnstile {{ tex \,\Vdash\, }}

% === Semantics ===
  | '~>' :: :: effred {{ tex \rightsquigarrow }}
  | '<>' :: :: diam {{ tex \diamond }}
  | '|' :: :: eff {{ tex ~|~ }}
  | !! :: :: downto {{ tex ~\Downarrow~ }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Used only to allow predicates in body text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

P :: '_' ::=
  | C1 ## C2 :: :: ctx_Dis {{ tex [[dom]]([[C1]]) \cap [[dom]]([[C2]]) = \emptyset }}
  | h notin dom ( C ) :: :: ctx_NotMem {{ tex [[h]] \notin [[dom]]([[C]]) }}
  | destOnly G :: :: pctx_DestOnly
  | fresh h :: :: ctx_Fresh
  | G u D ||- e :: :: Ty_eff {{ com Typing of effects (require both positive and negative contexts) }}
  | G |- v <> e : T :: :: Ty_cmd {{ com Typing of commands (only a positive context is needed) }}
  | G u D ||- w : T :: :: Ty_xval {{ com Typing of extended values (require both positive and negative contexts) }}
  | G |- t : T :: :: Ty_term {{ com Typing of terms (only a positive context is needed) }}
  | w1 D1 | e1 ~> w2 D2 | e2 :: :: Sem_eff {{ com Semantics of effects }}
  | t !! v <> e :: :: Sem_term {{ com Big-step evaluation into commands }}

parsing
pctx_U <= pctx_S
nctx_U <= nctx_M
nctx_U <= nctx_S
