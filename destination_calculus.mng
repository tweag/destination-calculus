% -*- latex -*-
\pdfmapfile{+zi4-sl.map}
\documentclass[acmsmall, screen]{acmart}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\let\Bbbk\relax % needed because of a conflict between amssymb and newtx
\usepackage{amssymb}
\usepackage{subcaption}

% For OTT rendering
\usepackage[supertabular]{ottalt}
\inputott{destination_calculus_ott.tex}
\usepackage{ottstyling}
% Hide "Index for ranges" from the metavars displayed tabular
\patchcmd{\ottmetavars}{$ \ottmv{k} $ & \ottcom{Index for ranges} \\}{}{}{}

% \setlength\textfloatsep{\baselineskip}
% \setlength{\intextsep}{\baselineskip}

\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }

\newtheorem{lem}{Lemma}
\newtheorem{thm}{Theorem}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TITLE SECTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\acmJournal{PACMPL}
\acmConference[POPL'25]{Principles of Programming Languages}{January 19 -- 25, 2025}{Denver, Colorado}
\title{Destination calculus}
\subtitle{A linear $\lambda-$calculus for pure, functional memory updates}

\author{Arnaud Spiwack}
\orcid{0TBD-0TBD-0TBD-0TBD}
\affiliation{
  \institution{Modus Create}
  \department{TWEAG - OSPO}
  \position{Director of Research}
  \city{Paris}
  \country{France}
}
\email{arnaud.spiwack@tweag.io}

\author{Thomas Bagrel}
\orcid{0009-0008-8700-2741}
\affiliation{
  \institution{LORIA/Inria}
  \department{MOSEL VERIDIS}
  \city{Nancy}
  \country{France}
}
\affiliation{
  \institution{Modus Create}
  \department{TWEAG - OSPO}
  \city{Paris}
  \country{France}
}
\email{thomas.bagrel@loria.fr}
\email{thomas.bagrel@tweag.io}

\begin{abstract}
  We present the destination calculus, a linear $\lambda-$calculus for
  pure, functional memory updates. We introduce the
  syntax, type system, and operational semantics of the destination
  calculus, and prove type safety formally in the Coq proof assistant.
  
  We show how the principles of the destination calculus can form a theoretical ground
  for destination-passing style programming in functional languages. In particular,
  we detail how the present work can be applied to Linear Haskell to lift the main 
  restriction of DPS programming in Haskell as developed in \cite{bagrel_destination-passing_2024}.
  We illustrate this with a range of pseudo-Haskell examples.
\end{abstract}

\maketitle

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\section{System in action on simple examples}

Build up to DList.

\section{Limitions of the previous approach}

\subsection{Breadth-first tree traversal}
\subsection{Storing linear data in destination-based data structures}
\subsection{Need for scope control}

\section{Updated breadth-first tree traversal}

\clearpage

\section{Language syntax}

\subsection{Names and variables}

\ottmetavars

\ottgrammartabular{
\otthvar\ottinterrule
\otthvars\ottafterlastrule
}

\subsection{Term and value core syntax}

\ottgrammartabular{
\ottterm\ottinterrule
\ottval\ottafterlastrule
}

\subsection{Syntactic sugar for constructors and commonly used operations}

\ottgrammartabular{
\ottsterm\ottafterlastrule
}

\activespaces

\begin{table}[h]
\centering\small
\setlength\tabcolsep{0.4ex}
\begin{tabular}{|lcl|lcl|}
\hline

$[[alloc]]$ & $\triangleq$ & $\begin{array}[t]{l}[[
  H ⟨ -1 ❟ +1 ⟩
]]\end{array}$ &

$[[t ˢ⨞ t']]$ & $\triangleq$ & $\begin{array}[t]{l}[[
t ⨞· (to⧔ t')
]]\end{array}$ \\\hline

$[[from⧔' t]]$ & $\triangleq$ & $\begin{array}[t]{l}[[
(from⧔ (t map un ⟼ un ; ᴇ ¹∞ () )) case ¹ν⮒
‥‥( st , ex ) ⟼ ex case ¹ν⮒
‥‥‥‥ᴇ ¹∞ un ⟼ un ; st
]]\end{array}$ &

$[[ˢλ x m ⟼ u]]$ & $\triangleq$ & $\begin{array}[t]{l}[[
from⧔' (⮒
‥‥alloc map d ⟼⮒
‥‥‥‥d ⨞ ( λ x m ⟼ u )⮒
)
]]\end{array}$ \\\hline

$[[ˢInl t]]$ & $\triangleq$ & $\begin{array}[t]{l}[[
from⧔' (⮒
‥‥alloc map d ⟼⮒
‥‥‥‥d ⨞ Inl ˢ⨞ t⮒
)
]]\end{array}$ &

$[[ˢInr t]]$ & $\triangleq$ & $\begin{array}[t]{l}[[
from⧔' (⮒
‥‥alloc map d ⟼⮒
‥‥‥‥d ⨞ Inr ˢ⨞ t⮒
)
]]\end{array}$ \\\hline

$[[ˢᴇ m t]]$ & $\triangleq$ & $\begin{array}[t]{l}[[
from⧔' (⮒
‥‥alloc map d ⟼⮒
‥‥‥‥d ⨞ ᴇ m ˢ⨞ t⮒
)
]]\end{array}$ &

$[[ˢ( t1 , t2 )]]$ & $\triangleq$ & $\begin{array}[t]{l}[[
from⧔' (⮒
‥‥alloc map d ⟼⮒
‥‥‥‥(d ⨞ (,)) case ¹ν⮒
‥‥‥‥‥‥( d1 , d2 ) ⟼ d1 ˢ⨞ t1 ; d2 ˢ⨞ t2⮒
)
]]\end{array}$ \\\hline

\end{tabular}
\caption{Desugaring of syntactic sugar forms for terms}
\label{tab:desugaring}
\end{table}

\clearpage

\section{Type system}

\subsection{Syntax for types, modes, and typing contexts}

\ottgrammartabular{
\otttype\ottinterrule
\ottmode\ottinterrule
\ottmul\ottinterrule
\ottage\ottinterrule
\ottctx\ottafterlastrule
}

\subsection{Typing of terms and values}

\ottdefnTyXXval{}
\ottdefnTyXXterm{}

\subsection{Derived typing rules for syntactic sugar forms}

\ottdefnTyXXsterm{}

\section{Evaluation contexts and semantics}

\subsection{Evaluation contexts forms}

\ottgrammartabular{
\ottectx\ottinterrule
\ottectxs\ottafterlastrule
}

\subsection{Typing of evaluation contexts and commands}

\ottdefnTyXXectxs{}
\ottdefnTy{}

\subsection{Small-step semantics}

\ottdefnSem{}

\section{Proof of type safety using Coq proof assistant}

\begin{itemize}
\item Not particularly elegant. Max number of goals observed 232
  (solved by a single call to the \verb|congruence| tactic). When you
  have a computer, brute force is a viable strategy. (in particular,
  no semiring formalisation, it was quicker to do directly)
\item Rules generated by ott, same as in the article (up to some
  notational difference). Contexts are not generated purely by syntax,
  and are interpreted in a semantic domain (finite functions).
\item Reasoning on closed terms avoids almost all complications on
  binder manipulation. Makes proofs tractable.
\item Finite functions: making a custom library was less headache than
  using existing libraries (including \verb|MMap|). Existing libraries
  don't provide some of the tools that we needed, but the most important
  factor ended up being the need for a modicum of dependency between
  key and value. There wasn't really that out there. Backed by actual
  functions for simplicity; cost: equality is complicated.
\item Most of the proofs done by author with very little prior
  experience to Coq.
\item Did proofs in Coq because context manipulations are tricky.
\item Context sum made total by adding an extra invalid \emph{mode}
  (rather than an extra context). It seems to be much simpler this
  way.
\item It might be a good idea to provide statistics on the number of
  lemmas and size of Coq codebase.
\item (possibly) renaming as permutation, inspired by nominal sets,
  make more lemmas don't require a condition (but some lemmas that
  wouldn't in a straight renaming do in exchange).
\item (possibly) methodology: assume a lot of lemmas, prove main
  theorem, prove assumptions, some wrong, fix. A number of wrong lemma
  initially assumed, but replacing them by correct variant was always
  easy to fix in proofs.
\item Axioms that we use and why (in particular setoid equality not
  very natural with ott-generated typing rules).
\item Talk about the use and benefits of Copilot.
\end{itemize}

\section{Implementation of destination calculus using in-place memory mutations}

What needs to be changed (e.g. linear alloc)

\section{Related work}

\section{Conclusion and future work}

\clearpage{}
\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}{}

\end{document}
