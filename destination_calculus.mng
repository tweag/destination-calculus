\documentclass[10pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,left=0.75cm,right=0.75cm,top=1.25cm,bottom=2cm]{geometry}
\usepackage{lmodern}
\usepackage[dvipsnames]{xcolor}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
  }

\usepackage[backend=biber,citestyle=authoryear,style=alphabetic]{biblatex}
\addbibresource{bibliography.bib}

% For OTT rendering
\usepackage[supertabular]{ottalt}
\inputott{destination_calculus_ott.tex}
\usepackage{ottstyling}

\newcommand{\TODO}[1]{~\textnormal{\textcolor{red}{TODO: #1} } }

\newtheorem{lem}{Lemma}
\newtheorem{thm}{Theorem}

\begin{document}

\title{Destination $\lambda$-calculus}
\author{Thomas \textsc{Bagrel}}
\date{\today}

\maketitle

\section{Term and value syntax}

\ottmetavars

\ottgrammartabular{
\otthdn\ottinterrule
\otthdns\ottinterrule
\ottval\ottinterrule
\ottterm\ottinterrule
\otteterm\ottinterrule
\ottectx\ottafterlastrule
}

%\ottsub\ottinterrule

\clearpage
\section{Type system}

\ottgrammartabular{
\otttype\ottinterrule
\ottmode\ottinterrule
\ottmul\ottinterrule
\ottage\ottinterrule
\ottctx\ottinterrule
\ottbndr\ottafterlastrule
}

\clearpage

\ottdefnTyRXXval{}
\ottdefnTyXXterm{}
\ottdefnTyRXXectx{}

\clearpage
\section{Effects and big-step semantics}

\ottdefnSemXXeterm{}

% \clearpage
% \section{Type safety}

% \begin{thm}[Type safety]
% If $[[ctx_DestOnly G]]$ and $[[ G ⊢ t : T ]]$ then $[[t ‿d ⇓ v ⋄ e]]$ and $[[G ⊢ v ⋄ e : T]]$.
% \end{thm}

% \begin{thm}[Type safety for complete programs]
%   If $[[ {} ⊢ t : T ]]$ then $[[t ‿⋆ ⇓ v ⋄ ε]]$ and $[[{} ⊢ v : T]]$
% \end{thm}

% \textbf{Proof.} By induction on the typing derivation.

% \begin{itemize}

% \item \textsc{TyTerm\_Val}: (0) $[[ G ⊢ v : T ]]$\\
% (0) gives (1) $[[v ‿d ⇓ v ⋄ ε]]$ immediately. From \textsc{TyEff\_NoEff} and \textsc{TyCmd\_Cmd} we conclude (2) $[[G ⊢ v ⋄ e : T]]$.

% \item \textsc{TyTerm\_App}: (0) $[[ m·G1 ⨄ G2 ⊢ t ≻ u : T2 ]]$\\
% We have\\
% (1) $[[ G1 ⊢ t : T1 ]]$\\
% (2) $[[ G2 ⊢ u : T1 m → T2 ]]$\\
% (3) $[[ctx_Disjoint G1 G2]]$\\
% Using recursion hypothesis on (1) we get (4) $[[t ‿d.1 ⇓ v1 ⋄ e1]]$ where (5) $[[G1 ⊢ v1 ⋄ e1 : T1]]$.\\
% Inverting \textsc{TyCmd\_Cmd} we get (5) $[[ G11 ⨄ G13 ⊢ v1 : T1 ]]$ and (6) $[[G12 ⨄ -G13 ⫦ e1]]$ where (7) $[[G1]]$ = $[[G11 ⨄ G12]]$.\\
% Using recursion hypothesis on (2) we get (8) $[[u ‿d.2 ⇓ v2 ⋄ e2]]$ where (9) $[[G2 ⊢ v2 ⋄ e2 : T1 m → T2]]$.\\
% Inverting \textsc{TyCmd\_Cmd} we get (10) $[[ G21 ⨄ G23 ⊢ v2 : T1 m → T2 ]]$ and (11) $[[G22 ⨄ -G23 ⫦ e2]]$ where (12) $[[G2]]$ = $[[G21 ⨄ G22]]$.\\
% Using Lemma~\ref{lem:canonical} on (9) we get (13) $[[v2]]$ = $[[λᵥx ⟼ t']]$ and (14) $[[G21 ⨄ G23 ⨄ {x : m T1} ⊢ t' : T2]]$.

% \textit{Typing value part of the result}

% Using Lemma~\ref{lem:subst} on (14) and (5) we get (15) $[[ m·(G11 ⨄ G13) ⨄ (G21 ⨄ G23) ⊢ t'[x ≔ v1] : T2]]$.\\
% Using recursion hypothesis on (15) we get (16) $[[t'[x ≔ v1] ‿d.3 ⇓ v3 ⋄ e3]]$ where (17) $[[ m·(G11 ⨄ G13) ⨄ (G21 ⨄ G23) ⊢ v3 ⋄ e3: T2]]$.

% \textit{Typing effect part of the result}

% We have\\
% (6) $[[G12 ⨄ -G13 ⫦ e1]]$ \\
% (11) $[[G22 ⨄ -G23 ⫦ e2]]$

% $[[ctx_Disjoint G12 G22]]$ comes naturally from (3), (7) and (12).

% We must show:\\
% $[[ctx_Disjoint G12 G23]]$: holes in $[[e2]]$ (associated to $[[u]]$) are fresh so they cannot match a destination name from $[[t]]$ as they don't exist yet when $[[t]]$ is evaluated.\\
% $[[ctx_Disjoint G22 G13]]$: slightly harder. Holes in $[[e1]]$ (associated to $[[t]]$) are fresh too, so I don't see a way for $[[u]]$ to create a term that could mention them, but sequentially, at least, they exist during $[[u]]$ evaluation. In fact, $[[G22]]$ might have intersection with $[[G13]]$ (see \textsc{TyEff\_Union}) as long as they share the same modalities (it's even harder to prove I think).\\
% $[[ctx_Disjoint G13 G23]]$: freshness of holes in both effects, executed sequentially, should be enough.

% Let say this is solved by Lemma~\ref{lem:freshholes}, with no holes of $[[e1]]$ negative context appearing as dests in $[[e2]]$ positive context.

% By \textsc{TyEff\_Union} we get (18) $[[G12 ⨄ G22 ⨄ -G13 ⨄ -G23 ⫦ e1 » e2]]$.\\
% Inverting \textsc{TyCmd\_Cmd} on (17) we get (19) $[[m·(G111 ⨄ G131) ⨄ G211 ⨄ G231 ⨄ G3 ⊢ v3 : T2 ]]$ and (20) $[[m·(G112 ⨄ G132) ⨄ G212 ⨄ G232 ⨄ -G3 ⫦ e3 ]]$ where (21) $[[Gk1 ⨄ Gk2]]$ = $[[Gk]]$

% We have\\
% (18) $[[G12 ⨄ G22 ⨄ -G13 ⨄ -G23 ⫦ e1 » e2]]$\\
% (20) $[[m·(G112 ⨄ G132) ⨄ G212 ⨄ G232 ⨄ -G3 ⫦ e3 ]]$\\

% Using (21) on (18) to decompose $[[-G23]]$, we get (22) $[[G12 ⨄ G22 ⨄ -(G131 ⨄ G231) ⨄ -(G132 ⨄ G232) ⫦ e1 » e2]]$

% We want $[[G132]]$ from (22) to cancel $[[m·G132]]$ from (20), but the multiplicity doesn't match apparently.

% $[[G13]]$ contains dests associated to holes that may have been created when evaluating $[[t]]$ into $[[v1]]$ $[[⋄]]$ $[[e1]]$. If $[[v1]]$ is used with delay (result of multiplying its context by $[[m]]$), then should we also delay the RHS of its associated effect?
% In other terms, if we have $[[{+h : ¹ν ⌊T1⨁T2⌋n } ⊢ +h' ⋄ h ≔ Inl -h' : ⌊T1⌋n]]$, and use $[[h']]$ with delay $[[m]]$ (e.g stored inside another dest in the body of the function), should we also type the RHS of $[[h ≔ Inl -h']]$ with delay ? I think so, if we want to keep the property that age of dests and age of the associated holes are the same. Which means a more refined substitution lemma.

% $[[(+h0 ⨞ (,) ≻case (x1, x2) ⟼ x1 ⨞· (to⧔ +h1) ; x2) ≻ (λᵥx2 ⟼ +h3 ⨞· (to⧔ x2))]]$

% $[[+h0 ⨞ (,) ‿d ⇓ (+dyn d.2, +dyn d.3) ⋄ h0 ≔ (-dyn d.2, -dyn d.3)]]$

% $[[(x1 ⨞· (to⧔ +h1) ; x2)[x1 ≔ +dyn d.2][x2 ≔ +dyn d.3] ‿d' ⇓ +dyn d.3 ⋄ dyn d.2 ≔ +h1]]$

% $[[(+h0 ⨞ (,) ≻case (x1, x2) ⟼ x1 ⨞· (to⧔ +h1) ; x2) ‿d'' ⇓ +dyn d.3 ⋄ h0 ≔ (-dyn d.2, -dyn d.3) » dyn d.2 ≔ +h1]]$

% $[[(+h3 ⨞· (to⧔ x2))[x2 ≔ +dyn d.3] ‿d''' ⇓ () ⋄ h3 ≔ +dyn d.3]]$

% $[[t ‿d'''' ⇓ () ⋄ h0 ≔ (-dyn d.2, -dyn d.3) » dyn d.2 ≔ +h1 » h3 ≔ +dyn d.3]]$

% \end{itemize}

% \begin{lem}[Freshness of holes]\label{lem:freshholes}
% Let $[[t]]$ be a program with no pre-existing ampar sharing hole names.

% During the reduction of $[[t]]$, the only other place where the names of the holes on the RHS of an effect can appear is in the accompanying value of the command, as destinations.
% \end{lem}
% \begin{proof}
% Names of the holes on the RHS of a new effect:
% \begin{itemize}
%   \item either are $\ottkw{fresh}$ (in all \textsc{BigStep\_Fill$\langle$\textnormal{\textit{Ctor}$\rangle$}} rules), which means the only other place where those names are known and can show up is as destinations on the accompanying value of the command ($[[G12]]$ in \textsc{TyCmd\_Cmd}), but not in positive or negative contexts of the command given by the evaluation of a sibling subterm;

    
%   \item or are those of pre-existing holes coming from the extended value $[[v2]]$ of an ampar, when \textsc{BigStep\_FillComp} is evaluated. Because they come from an ampar, they must be neutralized by this ampar, so the left value $[[v1]]$ of the ampar is the only place where those names can show up, as destinations, if we disallow pre-existing ampar with shared hole names in the body of the initial program· And $[[v1]]$ is exactly the accompanying value returned by the evaluation of \textsc{BigStep\_FillComp}
%   \end{itemize}

%   \item TODO: prove that this property is preserved by typing rules
% \end{proof}


\end{document}
